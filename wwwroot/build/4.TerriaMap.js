((self || window)["webpackJsonp"] = (self || window)["webpackJsonp"] || []).push([[4],{

/***/ "./node_modules/@petamoriken/float16/browser/float16.js":
/*!**************************************************************!*\
  !*** ./node_modules/@petamoriken/float16/browser/float16.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*! @petamoriken/float16 v3.8.7 | MIT License - https://github.com/petamoriken/float16 */\n\nvar float16 = (function (exports) {\n  'use strict';\n\n  const THIS_IS_NOT_AN_OBJECT = \"This is not an object\";\n  const THIS_IS_NOT_A_FLOAT16ARRAY_OBJECT = \"This is not a Float16Array object\";\n  const THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY =\n    \"This constructor is not a subclass of Float16Array\";\n  const THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT =\n    \"The constructor property value is not an object\";\n  const SPECIES_CONSTRUCTOR_DIDNT_RETURN_TYPEDARRAY_OBJECT =\n    \"Species constructor didn't return TypedArray object\";\n  const DERIVED_CONSTRUCTOR_CREATED_TYPEDARRAY_OBJECT_WHICH_WAS_TOO_SMALL_LENGTH =\n    \"Derived constructor created TypedArray object which was too small length\";\n  const ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER =\n    \"Attempting to access detached ArrayBuffer\";\n  const CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT =\n    \"Cannot convert undefined or null to object\";\n  const CANNOT_MIX_BIGINT_AND_OTHER_TYPES =\n    \"Cannot mix BigInt and other types, use explicit conversions\";\n  const ITERATOR_PROPERTY_IS_NOT_CALLABLE = \"@@iterator property is not callable\";\n  const REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE =\n    \"Reduce of empty array with no initial value\";\n  const THE_COMPARISON_FUNCTION_MUST_BE_EITHER_A_FUNCTION_OR_UNDEFINED =\n    \"The comparison function must be either a function or undefined\";\n  const OFFSET_IS_OUT_OF_BOUNDS = \"Offset is out of bounds\";\n\n  function uncurryThis(target) {\n    return (thisArg, ...args) => {\n      return ReflectApply(target, thisArg, args);\n    };\n  }\n  function uncurryThisGetter(target, key) {\n    return uncurryThis(\n      ReflectGetOwnPropertyDescriptor(\n        target,\n        key\n      ).get\n    );\n  }\n  const {\n    apply: ReflectApply,\n    construct: ReflectConstruct,\n    defineProperty: ReflectDefineProperty,\n    get: ReflectGet,\n    getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor,\n    getPrototypeOf: ReflectGetPrototypeOf,\n    has: ReflectHas,\n    ownKeys: ReflectOwnKeys,\n    set: ReflectSet,\n    setPrototypeOf: ReflectSetPrototypeOf,\n  } = Reflect;\n  const NativeProxy = Proxy;\n  const {\n    EPSILON,\n    MAX_SAFE_INTEGER,\n    isFinite: NumberIsFinite,\n    isNaN: NumberIsNaN,\n  } = Number;\n  const {\n    iterator: SymbolIterator,\n    species: SymbolSpecies,\n    toStringTag: SymbolToStringTag,\n    for: SymbolFor,\n  } = Symbol;\n  const NativeObject = Object;\n  const {\n    create: ObjectCreate,\n    defineProperty: ObjectDefineProperty,\n    freeze: ObjectFreeze,\n    is: ObjectIs,\n  } = NativeObject;\n  const ObjectPrototype = NativeObject.prototype;\n  const ObjectPrototype__lookupGetter__ =  (ObjectPrototype).__lookupGetter__\n    ? uncurryThis( (ObjectPrototype).__lookupGetter__)\n    : (object, key) => {\n      if (object == null) {\n        throw NativeTypeError(\n          CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT\n        );\n      }\n      let target = NativeObject(object);\n      do {\n        const descriptor = ReflectGetOwnPropertyDescriptor(target, key);\n        if (descriptor !== undefined) {\n          if (ObjectHasOwn(descriptor, \"get\")) {\n            return descriptor.get;\n          }\n          return;\n        }\n      } while ((target = ReflectGetPrototypeOf(target)) !== null);\n    };\n  const ObjectHasOwn =  (NativeObject).hasOwn ||\n    uncurryThis(ObjectPrototype.hasOwnProperty);\n  const NativeArray = Array;\n  const ArrayIsArray = NativeArray.isArray;\n  const ArrayPrototype = NativeArray.prototype;\n  const ArrayPrototypeJoin = uncurryThis(ArrayPrototype.join);\n  const ArrayPrototypePush = uncurryThis(ArrayPrototype.push);\n  const ArrayPrototypeToLocaleString = uncurryThis(\n    ArrayPrototype.toLocaleString\n  );\n  const NativeArrayPrototypeSymbolIterator = ArrayPrototype[SymbolIterator];\n  const ArrayPrototypeSymbolIterator = uncurryThis(NativeArrayPrototypeSymbolIterator);\n  const {\n    abs: MathAbs,\n    trunc: MathTrunc,\n  } = Math;\n  const NativeArrayBuffer = ArrayBuffer;\n  const ArrayBufferIsView = NativeArrayBuffer.isView;\n  const ArrayBufferPrototype = NativeArrayBuffer.prototype;\n  const ArrayBufferPrototypeSlice = uncurryThis(ArrayBufferPrototype.slice);\n  const ArrayBufferPrototypeGetByteLength = uncurryThisGetter(ArrayBufferPrototype, \"byteLength\");\n  const NativeSharedArrayBuffer = typeof SharedArrayBuffer !== \"undefined\" ? SharedArrayBuffer : null;\n  const SharedArrayBufferPrototypeGetByteLength = NativeSharedArrayBuffer\n    && uncurryThisGetter(NativeSharedArrayBuffer.prototype, \"byteLength\");\n  const TypedArray = ReflectGetPrototypeOf(Uint8Array);\n  const TypedArrayFrom = TypedArray.from;\n  const TypedArrayPrototype = TypedArray.prototype;\n  const NativeTypedArrayPrototypeSymbolIterator = TypedArrayPrototype[SymbolIterator];\n  const TypedArrayPrototypeKeys = uncurryThis(TypedArrayPrototype.keys);\n  const TypedArrayPrototypeValues = uncurryThis(\n    TypedArrayPrototype.values\n  );\n  const TypedArrayPrototypeEntries = uncurryThis(\n    TypedArrayPrototype.entries\n  );\n  const TypedArrayPrototypeSet = uncurryThis(TypedArrayPrototype.set);\n  const TypedArrayPrototypeReverse = uncurryThis(\n    TypedArrayPrototype.reverse\n  );\n  const TypedArrayPrototypeFill = uncurryThis(TypedArrayPrototype.fill);\n  const TypedArrayPrototypeCopyWithin = uncurryThis(\n    TypedArrayPrototype.copyWithin\n  );\n  const TypedArrayPrototypeSort = uncurryThis(TypedArrayPrototype.sort);\n  const TypedArrayPrototypeSlice = uncurryThis(TypedArrayPrototype.slice);\n  const TypedArrayPrototypeSubarray = uncurryThis(\n    TypedArrayPrototype.subarray\n  );\n  const TypedArrayPrototypeGetBuffer = uncurryThisGetter(\n    TypedArrayPrototype,\n    \"buffer\"\n  );\n  const TypedArrayPrototypeGetByteOffset = uncurryThisGetter(\n    TypedArrayPrototype,\n    \"byteOffset\"\n  );\n  const TypedArrayPrototypeGetLength = uncurryThisGetter(\n    TypedArrayPrototype,\n    \"length\"\n  );\n  const TypedArrayPrototypeGetSymbolToStringTag = uncurryThisGetter(\n    TypedArrayPrototype,\n    SymbolToStringTag\n  );\n  const NativeUint8Array = Uint8Array;\n  const NativeUint16Array = Uint16Array;\n  const Uint16ArrayFrom = (...args) => {\n    return ReflectApply(TypedArrayFrom, NativeUint16Array, args);\n  };\n  const NativeUint32Array = Uint32Array;\n  const NativeFloat32Array = Float32Array;\n  const ArrayIteratorPrototype = ReflectGetPrototypeOf([][SymbolIterator]());\n  const ArrayIteratorPrototypeNext = uncurryThis(ArrayIteratorPrototype.next);\n  const GeneratorPrototypeNext = uncurryThis((function* () {})().next);\n  const IteratorPrototype = ReflectGetPrototypeOf(ArrayIteratorPrototype);\n  const DataViewPrototype = DataView.prototype;\n  const DataViewPrototypeGetUint16 = uncurryThis(\n    DataViewPrototype.getUint16\n  );\n  const DataViewPrototypeSetUint16 = uncurryThis(\n    DataViewPrototype.setUint16\n  );\n  const NativeTypeError = TypeError;\n  const NativeRangeError = RangeError;\n  const NativeWeakSet = WeakSet;\n  const WeakSetPrototype = NativeWeakSet.prototype;\n  const WeakSetPrototypeAdd = uncurryThis(WeakSetPrototype.add);\n  const WeakSetPrototypeHas = uncurryThis(WeakSetPrototype.has);\n  const NativeWeakMap = WeakMap;\n  const WeakMapPrototype = NativeWeakMap.prototype;\n  const WeakMapPrototypeGet = uncurryThis(WeakMapPrototype.get);\n  const WeakMapPrototypeHas = uncurryThis(WeakMapPrototype.has);\n  const WeakMapPrototypeSet = uncurryThis(WeakMapPrototype.set);\n\n  const arrayIterators = new NativeWeakMap();\n  const SafeIteratorPrototype = ObjectCreate(null, {\n    next: {\n      value: function next() {\n        const arrayIterator = WeakMapPrototypeGet(arrayIterators, this);\n        return ArrayIteratorPrototypeNext(arrayIterator);\n      },\n    },\n    [SymbolIterator]: {\n      value: function values() {\n        return this;\n      },\n    },\n  });\n  function safeIfNeeded(array) {\n    if (\n      array[SymbolIterator] === NativeArrayPrototypeSymbolIterator &&\n      ArrayIteratorPrototype.next === ArrayIteratorPrototypeNext\n    ) {\n      return array;\n    }\n    const safe = ObjectCreate(SafeIteratorPrototype);\n    WeakMapPrototypeSet(arrayIterators, safe, ArrayPrototypeSymbolIterator(array));\n    return safe;\n  }\n  const generators = new NativeWeakMap();\n  const DummyArrayIteratorPrototype = ObjectCreate(IteratorPrototype, {\n    next: {\n      value: function next() {\n        const generator = WeakMapPrototypeGet(generators, this);\n        return GeneratorPrototypeNext(generator);\n      },\n      writable: true,\n      configurable: true,\n    },\n  });\n  for (const key of ReflectOwnKeys(ArrayIteratorPrototype)) {\n    if (key === \"next\") {\n      continue;\n    }\n    ObjectDefineProperty(DummyArrayIteratorPrototype, key, ReflectGetOwnPropertyDescriptor(ArrayIteratorPrototype, key));\n  }\n  function wrap(generator) {\n    const dummy = ObjectCreate(DummyArrayIteratorPrototype);\n    WeakMapPrototypeSet(generators, dummy, generator);\n    return dummy;\n  }\n\n  function isObject(value) {\n    return (\n      (value !== null && typeof value === \"object\") ||\n      typeof value === \"function\"\n    );\n  }\n  function isObjectLike(value) {\n    return value !== null && typeof value === \"object\";\n  }\n  function isNativeTypedArray(value) {\n    return TypedArrayPrototypeGetSymbolToStringTag(value) !== undefined;\n  }\n  function isNativeBigIntTypedArray(value) {\n    const typedArrayName = TypedArrayPrototypeGetSymbolToStringTag(value);\n    return (\n      typedArrayName === \"BigInt64Array\" ||\n      typedArrayName === \"BigUint64Array\"\n    );\n  }\n  function isArrayBuffer(value) {\n    try {\n      if (ArrayIsArray(value)) {\n        return false;\n      }\n      ArrayBufferPrototypeGetByteLength( (value));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  function isSharedArrayBuffer(value) {\n    if (NativeSharedArrayBuffer === null) {\n      return false;\n    }\n    try {\n      SharedArrayBufferPrototypeGetByteLength( (value));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  function isAnyArrayBuffer(value) {\n    return isArrayBuffer(value) || isSharedArrayBuffer(value);\n  }\n  function isOrdinaryArray(value) {\n    if (!ArrayIsArray(value)) {\n      return false;\n    }\n    return (\n      value[SymbolIterator] === NativeArrayPrototypeSymbolIterator &&\n      ArrayIteratorPrototype.next === ArrayIteratorPrototypeNext\n    );\n  }\n  function isOrdinaryNativeTypedArray(value) {\n    if (!isNativeTypedArray(value)) {\n      return false;\n    }\n    return (\n      value[SymbolIterator] === NativeTypedArrayPrototypeSymbolIterator &&\n      ArrayIteratorPrototype.next === ArrayIteratorPrototypeNext\n    );\n  }\n  function isCanonicalIntegerIndexString(value) {\n    if (typeof value !== \"string\") {\n      return false;\n    }\n    const number = +value;\n    if (value !== number + \"\") {\n      return false;\n    }\n    if (!NumberIsFinite(number)) {\n      return false;\n    }\n    return number === MathTrunc(number);\n  }\n\n  const brand = SymbolFor(\"__Float16Array__\");\n  function hasFloat16ArrayBrand(target) {\n    if (!isObjectLike(target)) {\n      return false;\n    }\n    const prototype = ReflectGetPrototypeOf(target);\n    if (!isObjectLike(prototype)) {\n      return false;\n    }\n    const constructor = prototype.constructor;\n    if (constructor === undefined) {\n      return false;\n    }\n    if (!isObject(constructor)) {\n      throw NativeTypeError(THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT);\n    }\n    return ReflectHas(constructor, brand);\n  }\n\n  const INVERSE_OF_EPSILON = 1 / EPSILON;\n  function roundTiesToEven(num) {\n    return (num + INVERSE_OF_EPSILON) - INVERSE_OF_EPSILON;\n  }\n  const FLOAT16_MIN_VALUE = 6.103515625e-05;\n  const FLOAT16_MAX_VALUE = 65504;\n  const FLOAT16_EPSILON = 0.0009765625;\n  const FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE = FLOAT16_EPSILON * FLOAT16_MIN_VALUE;\n  const FLOAT16_EPSILON_DEVIDED_BY_EPSILON = FLOAT16_EPSILON * INVERSE_OF_EPSILON;\n  function roundToFloat16(num) {\n    const number = +num;\n    if (!NumberIsFinite(number) || number === 0) {\n      return number;\n    }\n    const sign = number > 0 ? 1 : -1;\n    const absolute = MathAbs(number);\n    if (absolute < FLOAT16_MIN_VALUE) {\n      return sign * roundTiesToEven(absolute / FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE) * FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE;\n    }\n    const temp = (1 + FLOAT16_EPSILON_DEVIDED_BY_EPSILON) * absolute;\n    const result = temp - (temp - absolute);\n    if (result > FLOAT16_MAX_VALUE || NumberIsNaN(result)) {\n      return sign * Infinity;\n    }\n    return sign * result;\n  }\n  const buffer = new NativeArrayBuffer(4);\n  const floatView = new NativeFloat32Array(buffer);\n  const uint32View = new NativeUint32Array(buffer);\n  const baseTable = new NativeUint16Array(512);\n  const shiftTable = new NativeUint8Array(512);\n  for (let i = 0; i < 256; ++i) {\n    const e = i - 127;\n    if (e < -24) {\n      baseTable[i]         = 0x0000;\n      baseTable[i | 0x100] = 0x8000;\n      shiftTable[i]         = 24;\n      shiftTable[i | 0x100] = 24;\n    } else if (e < -14) {\n      baseTable[i]         =  0x0400 >> (-e - 14);\n      baseTable[i | 0x100] = (0x0400 >> (-e - 14)) | 0x8000;\n      shiftTable[i]         = -e - 1;\n      shiftTable[i | 0x100] = -e - 1;\n    } else if (e <= 15) {\n      baseTable[i]         =  (e + 15) << 10;\n      baseTable[i | 0x100] = ((e + 15) << 10) | 0x8000;\n      shiftTable[i]         = 13;\n      shiftTable[i | 0x100] = 13;\n    } else if (e < 128) {\n      baseTable[i]         = 0x7c00;\n      baseTable[i | 0x100] = 0xfc00;\n      shiftTable[i]         = 24;\n      shiftTable[i | 0x100] = 24;\n    } else {\n      baseTable[i]         = 0x7c00;\n      baseTable[i | 0x100] = 0xfc00;\n      shiftTable[i]         = 13;\n      shiftTable[i | 0x100] = 13;\n    }\n  }\n  function roundToFloat16Bits(num) {\n    floatView[0] = roundToFloat16(num);\n    const f = uint32View[0];\n    const e = (f >> 23) & 0x1ff;\n    return baseTable[e] + ((f & 0x007fffff) >> shiftTable[e]);\n  }\n  const mantissaTable = new NativeUint32Array(2048);\n  for (let i = 1; i < 1024; ++i) {\n    let m = i << 13;\n    let e = 0;\n    while ((m & 0x00800000) === 0) {\n      m <<= 1;\n      e -= 0x00800000;\n    }\n    m &= ~0x00800000;\n    e += 0x38800000;\n    mantissaTable[i] = m | e;\n  }\n  for (let i = 1024; i < 2048; ++i) {\n    mantissaTable[i] = 0x38000000 + ((i - 1024) << 13);\n  }\n  const exponentTable = new NativeUint32Array(64);\n  for (let i = 1; i < 31; ++i) {\n    exponentTable[i] = i << 23;\n  }\n  exponentTable[31] = 0x47800000;\n  exponentTable[32] = 0x80000000;\n  for (let i = 33; i < 63; ++i) {\n    exponentTable[i] = 0x80000000 + ((i - 32) << 23);\n  }\n  exponentTable[63] = 0xc7800000;\n  const offsetTable = new NativeUint16Array(64);\n  for (let i = 1; i < 64; ++i) {\n    if (i !== 32) {\n      offsetTable[i] = 1024;\n    }\n  }\n  function convertToNumber(float16bits) {\n    const i = float16bits >> 10;\n    uint32View[0] = mantissaTable[offsetTable[i] + (float16bits & 0x3ff)] + exponentTable[i];\n    return floatView[0];\n  }\n\n  function ToIntegerOrInfinity(target) {\n    const number = +target;\n    if (NumberIsNaN(number) || number === 0) {\n      return 0;\n    }\n    return MathTrunc(number);\n  }\n  function ToLength(target) {\n    const length = ToIntegerOrInfinity(target);\n    if (length < 0) {\n      return 0;\n    }\n    return length < MAX_SAFE_INTEGER\n      ? length\n      : MAX_SAFE_INTEGER;\n  }\n  function SpeciesConstructor(target, defaultConstructor) {\n    if (!isObject(target)) {\n      throw NativeTypeError(THIS_IS_NOT_AN_OBJECT);\n    }\n    const constructor = target.constructor;\n    if (constructor === undefined) {\n      return defaultConstructor;\n    }\n    if (!isObject(constructor)) {\n      throw NativeTypeError(THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT);\n    }\n    const species = constructor[SymbolSpecies];\n    if (species == null) {\n      return defaultConstructor;\n    }\n    return species;\n  }\n  function IsDetachedBuffer(buffer) {\n    if (isSharedArrayBuffer(buffer)) {\n      return false;\n    }\n    try {\n      ArrayBufferPrototypeSlice(buffer, 0, 0);\n      return false;\n    } catch (e) {}\n    return true;\n  }\n  function defaultCompare(x, y) {\n    const isXNaN = NumberIsNaN(x);\n    const isYNaN = NumberIsNaN(y);\n    if (isXNaN && isYNaN) {\n      return 0;\n    }\n    if (isXNaN) {\n      return 1;\n    }\n    if (isYNaN) {\n      return -1;\n    }\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    if (x === 0 && y === 0) {\n      const isXPlusZero = ObjectIs(x, 0);\n      const isYPlusZero = ObjectIs(y, 0);\n      if (!isXPlusZero && isYPlusZero) {\n        return -1;\n      }\n      if (isXPlusZero && !isYPlusZero) {\n        return 1;\n      }\n    }\n    return 0;\n  }\n\n  const BYTES_PER_ELEMENT = 2;\n  const float16bitsArrays = new NativeWeakMap();\n  function isFloat16Array(target) {\n    return WeakMapPrototypeHas(float16bitsArrays, target) ||\n      (!ArrayBufferIsView(target) && hasFloat16ArrayBrand(target));\n  }\n  function assertFloat16Array(target) {\n    if (!isFloat16Array(target)) {\n      throw NativeTypeError(THIS_IS_NOT_A_FLOAT16ARRAY_OBJECT);\n    }\n  }\n  function assertSpeciesTypedArray(target, count) {\n    const isTargetFloat16Array = isFloat16Array(target);\n    const isTargetTypedArray = isNativeTypedArray(target);\n    if (!isTargetFloat16Array && !isTargetTypedArray) {\n      throw NativeTypeError(SPECIES_CONSTRUCTOR_DIDNT_RETURN_TYPEDARRAY_OBJECT);\n    }\n    if (typeof count === \"number\") {\n      let length;\n      if (isTargetFloat16Array) {\n        const float16bitsArray = getFloat16BitsArray(target);\n        length = TypedArrayPrototypeGetLength(float16bitsArray);\n      } else {\n        length = TypedArrayPrototypeGetLength(target);\n      }\n      if (length < count) {\n        throw NativeTypeError(\n          DERIVED_CONSTRUCTOR_CREATED_TYPEDARRAY_OBJECT_WHICH_WAS_TOO_SMALL_LENGTH\n        );\n      }\n    }\n    if (isNativeBigIntTypedArray(target)) {\n      throw NativeTypeError(CANNOT_MIX_BIGINT_AND_OTHER_TYPES);\n    }\n  }\n  function getFloat16BitsArray(float16) {\n    const float16bitsArray = WeakMapPrototypeGet(float16bitsArrays, float16);\n    if (float16bitsArray !== undefined) {\n      const buffer = TypedArrayPrototypeGetBuffer(float16bitsArray);\n      if (IsDetachedBuffer(buffer)) {\n        throw NativeTypeError(ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);\n      }\n      return float16bitsArray;\n    }\n    const buffer =  (float16).buffer;\n    if (IsDetachedBuffer(buffer)) {\n      throw NativeTypeError(ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);\n    }\n    const cloned = ReflectConstruct(Float16Array, [\n      buffer,\n       (float16).byteOffset,\n       (float16).length,\n    ], float16.constructor);\n    return WeakMapPrototypeGet(float16bitsArrays, cloned);\n  }\n  function copyToArray(float16bitsArray) {\n    const length = TypedArrayPrototypeGetLength(float16bitsArray);\n    const array = [];\n    for (let i = 0; i < length; ++i) {\n      array[i] = convertToNumber(float16bitsArray[i]);\n    }\n    return array;\n  }\n  const TypedArrayPrototypeGetters = new NativeWeakSet();\n  for (const key of ReflectOwnKeys(TypedArrayPrototype)) {\n    if (key === SymbolToStringTag) {\n      continue;\n    }\n    const descriptor = ReflectGetOwnPropertyDescriptor(TypedArrayPrototype, key);\n    if (ObjectHasOwn(descriptor, \"get\") && typeof descriptor.get === \"function\") {\n      WeakSetPrototypeAdd(TypedArrayPrototypeGetters, descriptor.get);\n    }\n  }\n  const handler = ObjectFreeze( ({\n    get(target, key, receiver) {\n      if (isCanonicalIntegerIndexString(key) && ObjectHasOwn(target, key)) {\n        return convertToNumber(ReflectGet(target, key));\n      }\n      if (WeakSetPrototypeHas(TypedArrayPrototypeGetters, ObjectPrototype__lookupGetter__(target, key))) {\n        return ReflectGet(target, key);\n      }\n      return ReflectGet(target, key, receiver);\n    },\n    set(target, key, value, receiver) {\n      if (isCanonicalIntegerIndexString(key) && ObjectHasOwn(target, key)) {\n        return ReflectSet(target, key, roundToFloat16Bits(value));\n      }\n      return ReflectSet(target, key, value, receiver);\n    },\n    getOwnPropertyDescriptor(target, key) {\n      if (isCanonicalIntegerIndexString(key) && ObjectHasOwn(target, key)) {\n        const descriptor = ReflectGetOwnPropertyDescriptor(target, key);\n        descriptor.value = convertToNumber(descriptor.value);\n        return descriptor;\n      }\n      return ReflectGetOwnPropertyDescriptor(target, key);\n    },\n    defineProperty(target, key, descriptor) {\n      if (\n        isCanonicalIntegerIndexString(key) &&\n        ObjectHasOwn(target, key) &&\n        ObjectHasOwn(descriptor, \"value\")\n      ) {\n        descriptor.value = roundToFloat16Bits(descriptor.value);\n        return ReflectDefineProperty(target, key, descriptor);\n      }\n      return ReflectDefineProperty(target, key, descriptor);\n    },\n  }));\n  class Float16Array {\n    constructor(input, _byteOffset, _length) {\n      let float16bitsArray;\n      if (isFloat16Array(input)) {\n        float16bitsArray = ReflectConstruct(NativeUint16Array, [getFloat16BitsArray(input)], new.target);\n      } else if (isObject(input) && !isAnyArrayBuffer(input)) {\n        let list;\n        let length;\n        if (isNativeTypedArray(input)) {\n          list = input;\n          length = TypedArrayPrototypeGetLength(input);\n          const buffer = TypedArrayPrototypeGetBuffer(input);\n          if (IsDetachedBuffer(buffer)) {\n            throw NativeTypeError(ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);\n          }\n          if (isNativeBigIntTypedArray(input)) {\n            throw NativeTypeError(CANNOT_MIX_BIGINT_AND_OTHER_TYPES);\n          }\n          const data = new NativeArrayBuffer(\n            length * BYTES_PER_ELEMENT\n          );\n          float16bitsArray = ReflectConstruct(NativeUint16Array, [data], new.target);\n        } else {\n          const iterator = input[SymbolIterator];\n          if (iterator != null && typeof iterator !== \"function\") {\n            throw NativeTypeError(ITERATOR_PROPERTY_IS_NOT_CALLABLE);\n          }\n          if (iterator != null) {\n            if (isOrdinaryArray(input)) {\n              list = input;\n              length = input.length;\n            } else {\n              list = [...  (input)];\n              length = list.length;\n            }\n          } else {\n            list =  (input);\n            length = ToLength(list.length);\n          }\n          float16bitsArray = ReflectConstruct(NativeUint16Array, [length], new.target);\n        }\n        for (let i = 0; i < length; ++i) {\n          float16bitsArray[i] = roundToFloat16Bits(list[i]);\n        }\n      } else {\n        float16bitsArray = ReflectConstruct(NativeUint16Array, arguments, new.target);\n      }\n      const proxy =  (new NativeProxy(float16bitsArray, handler));\n      WeakMapPrototypeSet(float16bitsArrays, proxy, float16bitsArray);\n      return proxy;\n    }\n    static from(src, ...opts) {\n      const Constructor = this;\n      if (!ReflectHas(Constructor, brand)) {\n        throw NativeTypeError(\n          THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY\n        );\n      }\n      if (Constructor === Float16Array) {\n        if (isFloat16Array(src) && opts.length === 0) {\n          const float16bitsArray = getFloat16BitsArray(src);\n          const uint16 = new NativeUint16Array(\n            TypedArrayPrototypeGetBuffer(float16bitsArray),\n            TypedArrayPrototypeGetByteOffset(float16bitsArray),\n            TypedArrayPrototypeGetLength(float16bitsArray)\n          );\n          return new Float16Array(\n            TypedArrayPrototypeGetBuffer(TypedArrayPrototypeSlice(uint16))\n          );\n        }\n        if (opts.length === 0) {\n          return new Float16Array(\n            TypedArrayPrototypeGetBuffer(\n              Uint16ArrayFrom(src, roundToFloat16Bits)\n            )\n          );\n        }\n        const mapFunc = opts[0];\n        const thisArg = opts[1];\n        return new Float16Array(\n          TypedArrayPrototypeGetBuffer(\n            Uint16ArrayFrom(src, function (val, ...args) {\n              return roundToFloat16Bits(\n                ReflectApply(mapFunc, this, [val, ...safeIfNeeded(args)])\n              );\n            }, thisArg)\n          )\n        );\n      }\n      let list;\n      let length;\n      const iterator = src[SymbolIterator];\n      if (iterator != null && typeof iterator !== \"function\") {\n        throw NativeTypeError(ITERATOR_PROPERTY_IS_NOT_CALLABLE);\n      }\n      if (iterator != null) {\n        if (isOrdinaryArray(src)) {\n          list = src;\n          length = src.length;\n        } else if (isOrdinaryNativeTypedArray(src)) {\n          list = src;\n          length = TypedArrayPrototypeGetLength(src);\n        } else {\n          list = [...src];\n          length = list.length;\n        }\n      } else {\n        if (src == null) {\n          throw NativeTypeError(\n            CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT\n          );\n        }\n        list = NativeObject(src);\n        length = ToLength(list.length);\n      }\n      const array = new Constructor(length);\n      if (opts.length === 0) {\n        for (let i = 0; i < length; ++i) {\n          array[i] =  (list[i]);\n        }\n      } else {\n        const mapFunc = opts[0];\n        const thisArg = opts[1];\n        for (let i = 0; i < length; ++i) {\n          array[i] = ReflectApply(mapFunc, thisArg, [list[i], i]);\n        }\n      }\n      return array;\n    }\n    static of(...items) {\n      const Constructor = this;\n      if (!ReflectHas(Constructor, brand)) {\n        throw NativeTypeError(\n          THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY\n        );\n      }\n      const length = items.length;\n      if (Constructor === Float16Array) {\n        const proxy = new Float16Array(length);\n        const float16bitsArray = getFloat16BitsArray(proxy);\n        for (let i = 0; i < length; ++i) {\n          float16bitsArray[i] = roundToFloat16Bits(items[i]);\n        }\n        return proxy;\n      }\n      const array = new Constructor(length);\n      for (let i = 0; i < length; ++i) {\n        array[i] = items[i];\n      }\n      return array;\n    }\n    keys() {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      return TypedArrayPrototypeKeys(float16bitsArray);\n    }\n    values() {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      return wrap((function* () {\n        for (const val of TypedArrayPrototypeValues(float16bitsArray)) {\n          yield convertToNumber(val);\n        }\n      })());\n    }\n    entries() {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      return wrap((function* () {\n        for (const [i, val] of TypedArrayPrototypeEntries(float16bitsArray)) {\n          yield  ([i, convertToNumber(val)]);\n        }\n      })());\n    }\n    at(index) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      const relativeIndex = ToIntegerOrInfinity(index);\n      const k = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;\n      if (k < 0 || k >= length) {\n        return;\n      }\n      return convertToNumber(float16bitsArray[k]);\n    }\n    with(index, value) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      const relativeIndex = ToIntegerOrInfinity(index);\n      const k = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;\n      const number = +value;\n      if (k < 0 || k >= length) {\n        throw NativeRangeError(OFFSET_IS_OUT_OF_BOUNDS);\n      }\n      const uint16 = new NativeUint16Array(\n        TypedArrayPrototypeGetBuffer(float16bitsArray),\n        TypedArrayPrototypeGetByteOffset(float16bitsArray),\n        TypedArrayPrototypeGetLength(float16bitsArray)\n      );\n      const cloned = new Float16Array(\n        TypedArrayPrototypeGetBuffer(\n          TypedArrayPrototypeSlice(uint16)\n        )\n      );\n      const array = getFloat16BitsArray(cloned);\n      array[k] = roundToFloat16Bits(number);\n      return cloned;\n    }\n    map(callback, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      const thisArg = opts[0];\n      const Constructor = SpeciesConstructor(float16bitsArray, Float16Array);\n      if (Constructor === Float16Array) {\n        const proxy = new Float16Array(length);\n        const array = getFloat16BitsArray(proxy);\n        for (let i = 0; i < length; ++i) {\n          const val = convertToNumber(float16bitsArray[i]);\n          array[i] = roundToFloat16Bits(\n            ReflectApply(callback, thisArg, [val, i, this])\n          );\n        }\n        return proxy;\n      }\n      const array = new Constructor(length);\n      assertSpeciesTypedArray(array, length);\n      for (let i = 0; i < length; ++i) {\n        const val = convertToNumber(float16bitsArray[i]);\n        array[i] = ReflectApply(callback, thisArg, [val, i, this]);\n      }\n      return  (array);\n    }\n    filter(callback, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      const thisArg = opts[0];\n      const kept = [];\n      for (let i = 0; i < length; ++i) {\n        const val = convertToNumber(float16bitsArray[i]);\n        if (ReflectApply(callback, thisArg, [val, i, this])) {\n          ArrayPrototypePush(kept, val);\n        }\n      }\n      const Constructor = SpeciesConstructor(float16bitsArray, Float16Array);\n      const array = new Constructor(kept);\n      assertSpeciesTypedArray(array);\n      return  (array);\n    }\n    reduce(callback, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      if (length === 0 && opts.length === 0) {\n        throw NativeTypeError(REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE);\n      }\n      let accumulator, start;\n      if (opts.length === 0) {\n        accumulator = convertToNumber(float16bitsArray[0]);\n        start = 1;\n      } else {\n        accumulator = opts[0];\n        start = 0;\n      }\n      for (let i = start; i < length; ++i) {\n        accumulator = callback(\n          accumulator,\n          convertToNumber(float16bitsArray[i]),\n          i,\n          this\n        );\n      }\n      return accumulator;\n    }\n    reduceRight(callback, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      if (length === 0 && opts.length === 0) {\n        throw NativeTypeError(REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE);\n      }\n      let accumulator, start;\n      if (opts.length === 0) {\n        accumulator = convertToNumber(float16bitsArray[length - 1]);\n        start = length - 2;\n      } else {\n        accumulator = opts[0];\n        start = length - 1;\n      }\n      for (let i = start; i >= 0; --i) {\n        accumulator = callback(\n          accumulator,\n          convertToNumber(float16bitsArray[i]),\n          i,\n          this\n        );\n      }\n      return accumulator;\n    }\n    forEach(callback, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      const thisArg = opts[0];\n      for (let i = 0; i < length; ++i) {\n        ReflectApply(callback, thisArg, [\n          convertToNumber(float16bitsArray[i]),\n          i,\n          this,\n        ]);\n      }\n    }\n    find(callback, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      const thisArg = opts[0];\n      for (let i = 0; i < length; ++i) {\n        const value = convertToNumber(float16bitsArray[i]);\n        if (ReflectApply(callback, thisArg, [value, i, this])) {\n          return value;\n        }\n      }\n    }\n    findIndex(callback, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      const thisArg = opts[0];\n      for (let i = 0; i < length; ++i) {\n        const value = convertToNumber(float16bitsArray[i]);\n        if (ReflectApply(callback, thisArg, [value, i, this])) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    findLast(callback, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      const thisArg = opts[0];\n      for (let i = length - 1; i >= 0; --i) {\n        const value = convertToNumber(float16bitsArray[i]);\n        if (ReflectApply(callback, thisArg, [value, i, this])) {\n          return value;\n        }\n      }\n    }\n    findLastIndex(callback, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      const thisArg = opts[0];\n      for (let i = length - 1; i >= 0; --i) {\n        const value = convertToNumber(float16bitsArray[i]);\n        if (ReflectApply(callback, thisArg, [value, i, this])) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    every(callback, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      const thisArg = opts[0];\n      for (let i = 0; i < length; ++i) {\n        if (\n          !ReflectApply(callback, thisArg, [\n            convertToNumber(float16bitsArray[i]),\n            i,\n            this,\n          ])\n        ) {\n          return false;\n        }\n      }\n      return true;\n    }\n    some(callback, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      const thisArg = opts[0];\n      for (let i = 0; i < length; ++i) {\n        if (\n          ReflectApply(callback, thisArg, [\n            convertToNumber(float16bitsArray[i]),\n            i,\n            this,\n          ])\n        ) {\n          return true;\n        }\n      }\n      return false;\n    }\n    set(input, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const targetOffset = ToIntegerOrInfinity(opts[0]);\n      if (targetOffset < 0) {\n        throw NativeRangeError(OFFSET_IS_OUT_OF_BOUNDS);\n      }\n      if (input == null) {\n        throw NativeTypeError(\n          CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT\n        );\n      }\n      if (isNativeBigIntTypedArray(input)) {\n        throw NativeTypeError(\n          CANNOT_MIX_BIGINT_AND_OTHER_TYPES\n        );\n      }\n      if (isFloat16Array(input)) {\n        return TypedArrayPrototypeSet(\n          getFloat16BitsArray(this),\n          getFloat16BitsArray(input),\n          targetOffset\n        );\n      }\n      if (isNativeTypedArray(input)) {\n        const buffer = TypedArrayPrototypeGetBuffer(input);\n        if (IsDetachedBuffer(buffer)) {\n          throw NativeTypeError(ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);\n        }\n      }\n      const targetLength = TypedArrayPrototypeGetLength(float16bitsArray);\n      const src = NativeObject(input);\n      const srcLength = ToLength(src.length);\n      if (targetOffset === Infinity || srcLength + targetOffset > targetLength) {\n        throw NativeRangeError(OFFSET_IS_OUT_OF_BOUNDS);\n      }\n      for (let i = 0; i < srcLength; ++i) {\n        float16bitsArray[i + targetOffset] = roundToFloat16Bits(src[i]);\n      }\n    }\n    reverse() {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      TypedArrayPrototypeReverse(float16bitsArray);\n      return this;\n    }\n    toReversed() {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const uint16 = new NativeUint16Array(\n        TypedArrayPrototypeGetBuffer(float16bitsArray),\n        TypedArrayPrototypeGetByteOffset(float16bitsArray),\n        TypedArrayPrototypeGetLength(float16bitsArray)\n      );\n      const cloned = new Float16Array(\n        TypedArrayPrototypeGetBuffer(\n          TypedArrayPrototypeSlice(uint16)\n        )\n      );\n      const clonedFloat16bitsArray = getFloat16BitsArray(cloned);\n      TypedArrayPrototypeReverse(clonedFloat16bitsArray);\n      return cloned;\n    }\n    fill(value, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      TypedArrayPrototypeFill(\n        float16bitsArray,\n        roundToFloat16Bits(value),\n        ...safeIfNeeded(opts)\n      );\n      return this;\n    }\n    copyWithin(target, start, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      TypedArrayPrototypeCopyWithin(float16bitsArray, target, start, ...safeIfNeeded(opts));\n      return this;\n    }\n    sort(compareFn) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const sortCompare = compareFn !== undefined ? compareFn : defaultCompare;\n      TypedArrayPrototypeSort(float16bitsArray, (x, y) => {\n        return sortCompare(convertToNumber(x), convertToNumber(y));\n      });\n      return this;\n    }\n    toSorted(compareFn) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      if (compareFn !== undefined && typeof compareFn !== \"function\") {\n        throw new NativeTypeError(THE_COMPARISON_FUNCTION_MUST_BE_EITHER_A_FUNCTION_OR_UNDEFINED);\n      }\n      const sortCompare = compareFn !== undefined ? compareFn : defaultCompare;\n      const uint16 = new NativeUint16Array(\n        TypedArrayPrototypeGetBuffer(float16bitsArray),\n        TypedArrayPrototypeGetByteOffset(float16bitsArray),\n        TypedArrayPrototypeGetLength(float16bitsArray)\n      );\n      const cloned = new Float16Array(\n        TypedArrayPrototypeGetBuffer(\n          TypedArrayPrototypeSlice(uint16)\n        )\n      );\n      const clonedFloat16bitsArray = getFloat16BitsArray(cloned);\n      TypedArrayPrototypeSort(clonedFloat16bitsArray, (x, y) => {\n        return sortCompare(convertToNumber(x), convertToNumber(y));\n      });\n      return cloned;\n    }\n    slice(start, end) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const Constructor = SpeciesConstructor(float16bitsArray, Float16Array);\n      if (Constructor === Float16Array) {\n        const uint16 = new NativeUint16Array(\n          TypedArrayPrototypeGetBuffer(float16bitsArray),\n          TypedArrayPrototypeGetByteOffset(float16bitsArray),\n          TypedArrayPrototypeGetLength(float16bitsArray)\n        );\n        return new Float16Array(\n          TypedArrayPrototypeGetBuffer(\n            TypedArrayPrototypeSlice(uint16, start, end)\n          )\n        );\n      }\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      const relativeStart = ToIntegerOrInfinity(start);\n      const relativeEnd = end === undefined ? length : ToIntegerOrInfinity(end);\n      let k;\n      if (relativeStart === -Infinity) {\n        k = 0;\n      } else if (relativeStart < 0) {\n        k = length + relativeStart > 0 ? length + relativeStart : 0;\n      } else {\n        k = length < relativeStart ? length : relativeStart;\n      }\n      let final;\n      if (relativeEnd === -Infinity) {\n        final = 0;\n      } else if (relativeEnd < 0) {\n        final = length + relativeEnd > 0 ? length + relativeEnd : 0;\n      } else {\n        final = length < relativeEnd ? length : relativeEnd;\n      }\n      const count = final - k > 0 ? final - k : 0;\n      const array = new Constructor(count);\n      assertSpeciesTypedArray(array, count);\n      if (count === 0) {\n        return array;\n      }\n      const buffer = TypedArrayPrototypeGetBuffer(float16bitsArray);\n      if (IsDetachedBuffer(buffer)) {\n        throw NativeTypeError(ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER);\n      }\n      let n = 0;\n      while (k < final) {\n        array[n] = convertToNumber(float16bitsArray[k]);\n        ++k;\n        ++n;\n      }\n      return  (array);\n    }\n    subarray(begin, end) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const Constructor = SpeciesConstructor(float16bitsArray, Float16Array);\n      const uint16 = new NativeUint16Array(\n        TypedArrayPrototypeGetBuffer(float16bitsArray),\n        TypedArrayPrototypeGetByteOffset(float16bitsArray),\n        TypedArrayPrototypeGetLength(float16bitsArray)\n      );\n      const uint16Subarray = TypedArrayPrototypeSubarray(uint16, begin, end);\n      const array = new Constructor(\n        TypedArrayPrototypeGetBuffer(uint16Subarray),\n        TypedArrayPrototypeGetByteOffset(uint16Subarray),\n        TypedArrayPrototypeGetLength(uint16Subarray)\n      );\n      assertSpeciesTypedArray(array);\n      return  (array);\n    }\n    indexOf(element, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      let from = ToIntegerOrInfinity(opts[0]);\n      if (from === Infinity) {\n        return -1;\n      }\n      if (from < 0) {\n        from += length;\n        if (from < 0) {\n          from = 0;\n        }\n      }\n      for (let i = from; i < length; ++i) {\n        if (\n          ObjectHasOwn(float16bitsArray, i) &&\n          convertToNumber(float16bitsArray[i]) === element\n        ) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    lastIndexOf(element, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      let from = opts.length >= 1 ? ToIntegerOrInfinity(opts[0]) : length - 1;\n      if (from === -Infinity) {\n        return -1;\n      }\n      if (from >= 0) {\n        from = from < length - 1 ? from : length - 1;\n      } else {\n        from += length;\n      }\n      for (let i = from; i >= 0; --i) {\n        if (\n          ObjectHasOwn(float16bitsArray, i) &&\n          convertToNumber(float16bitsArray[i]) === element\n        ) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    includes(element, ...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const length = TypedArrayPrototypeGetLength(float16bitsArray);\n      let from = ToIntegerOrInfinity(opts[0]);\n      if (from === Infinity) {\n        return false;\n      }\n      if (from < 0) {\n        from += length;\n        if (from < 0) {\n          from = 0;\n        }\n      }\n      const isNaN = NumberIsNaN(element);\n      for (let i = from; i < length; ++i) {\n        const value = convertToNumber(float16bitsArray[i]);\n        if (isNaN && NumberIsNaN(value)) {\n          return true;\n        }\n        if (value === element) {\n          return true;\n        }\n      }\n      return false;\n    }\n    join(separator) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const array = copyToArray(float16bitsArray);\n      return ArrayPrototypeJoin(array, separator);\n    }\n    toLocaleString(...opts) {\n      assertFloat16Array(this);\n      const float16bitsArray = getFloat16BitsArray(this);\n      const array = copyToArray(float16bitsArray);\n      return ArrayPrototypeToLocaleString(array, ...safeIfNeeded(opts));\n    }\n    get [SymbolToStringTag]() {\n      if (isFloat16Array(this)) {\n        return  (\"Float16Array\");\n      }\n    }\n  }\n  ObjectDefineProperty(Float16Array, \"BYTES_PER_ELEMENT\", {\n    value: BYTES_PER_ELEMENT,\n  });\n  ObjectDefineProperty(Float16Array, brand, {});\n  ReflectSetPrototypeOf(Float16Array, TypedArray);\n  const Float16ArrayPrototype = Float16Array.prototype;\n  ObjectDefineProperty(Float16ArrayPrototype, \"BYTES_PER_ELEMENT\", {\n    value: BYTES_PER_ELEMENT,\n  });\n  ObjectDefineProperty(Float16ArrayPrototype, SymbolIterator, {\n    value: Float16ArrayPrototype.values,\n    writable: true,\n    configurable: true,\n  });\n  ReflectSetPrototypeOf(Float16ArrayPrototype, TypedArrayPrototype);\n\n  function isTypedArray(target) {\n    return isNativeTypedArray(target) || isFloat16Array(target);\n  }\n\n  function getFloat16(dataView, byteOffset, ...opts) {\n    return convertToNumber(\n      DataViewPrototypeGetUint16(dataView, byteOffset, ...safeIfNeeded(opts))\n    );\n  }\n  function setFloat16(dataView, byteOffset, value, ...opts) {\n    return DataViewPrototypeSetUint16(\n      dataView,\n      byteOffset,\n      roundToFloat16Bits(value),\n      ...safeIfNeeded(opts)\n    );\n  }\n\n  function f16round(x) {\n    return roundToFloat16(x);\n  }\n\n  exports.Float16Array = Float16Array;\n  exports.f16round = f16round;\n  exports.getFloat16 = getFloat16;\n  exports.hfround = f16round;\n  exports.isFloat16Array = isFloat16Array;\n  exports.isTypedArray = isTypedArray;\n  exports.setFloat16 = setFloat16;\n\n  Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\n  return exports;\n\n})({});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBldGFtb3Jpa2VuL2Zsb2F0MTYvYnJvd3Nlci9mbG9hdDE2LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BwZXRhbW9yaWtlbi9mbG9hdDE2L2Jyb3dzZXIvZmxvYXQxNi5qcz9lNTA0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISBAcGV0YW1vcmlrZW4vZmxvYXQxNiB2My44LjcgfCBNSVQgTGljZW5zZSAtIGh0dHBzOi8vZ2l0aHViLmNvbS9wZXRhbW9yaWtlbi9mbG9hdDE2ICovXG5cbnZhciBmbG9hdDE2ID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBjb25zdCBUSElTX0lTX05PVF9BTl9PQkpFQ1QgPSBcIlRoaXMgaXMgbm90IGFuIG9iamVjdFwiO1xuICBjb25zdCBUSElTX0lTX05PVF9BX0ZMT0FUMTZBUlJBWV9PQkpFQ1QgPSBcIlRoaXMgaXMgbm90IGEgRmxvYXQxNkFycmF5IG9iamVjdFwiO1xuICBjb25zdCBUSElTX0NPTlNUUlVDVE9SX0lTX05PVF9BX1NVQkNMQVNTX09GX0ZMT0FUMTZBUlJBWSA9XG4gICAgXCJUaGlzIGNvbnN0cnVjdG9yIGlzIG5vdCBhIHN1YmNsYXNzIG9mIEZsb2F0MTZBcnJheVwiO1xuICBjb25zdCBUSEVfQ09OU1RSVUNUT1JfUFJPUEVSVFlfVkFMVUVfSVNfTk9UX0FOX09CSkVDVCA9XG4gICAgXCJUaGUgY29uc3RydWN0b3IgcHJvcGVydHkgdmFsdWUgaXMgbm90IGFuIG9iamVjdFwiO1xuICBjb25zdCBTUEVDSUVTX0NPTlNUUlVDVE9SX0RJRE5UX1JFVFVSTl9UWVBFREFSUkFZX09CSkVDVCA9XG4gICAgXCJTcGVjaWVzIGNvbnN0cnVjdG9yIGRpZG4ndCByZXR1cm4gVHlwZWRBcnJheSBvYmplY3RcIjtcbiAgY29uc3QgREVSSVZFRF9DT05TVFJVQ1RPUl9DUkVBVEVEX1RZUEVEQVJSQVlfT0JKRUNUX1dISUNIX1dBU19UT09fU01BTExfTEVOR1RIID1cbiAgICBcIkRlcml2ZWQgY29uc3RydWN0b3IgY3JlYXRlZCBUeXBlZEFycmF5IG9iamVjdCB3aGljaCB3YXMgdG9vIHNtYWxsIGxlbmd0aFwiO1xuICBjb25zdCBBVFRFTVBUSU5HX1RPX0FDQ0VTU19ERVRBQ0hFRF9BUlJBWUJVRkZFUiA9XG4gICAgXCJBdHRlbXB0aW5nIHRvIGFjY2VzcyBkZXRhY2hlZCBBcnJheUJ1ZmZlclwiO1xuICBjb25zdCBDQU5OT1RfQ09OVkVSVF9VTkRFRklORURfT1JfTlVMTF9UT19PQkpFQ1QgPVxuICAgIFwiQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0XCI7XG4gIGNvbnN0IENBTk5PVF9NSVhfQklHSU5UX0FORF9PVEhFUl9UWVBFUyA9XG4gICAgXCJDYW5ub3QgbWl4IEJpZ0ludCBhbmQgb3RoZXIgdHlwZXMsIHVzZSBleHBsaWNpdCBjb252ZXJzaW9uc1wiO1xuICBjb25zdCBJVEVSQVRPUl9QUk9QRVJUWV9JU19OT1RfQ0FMTEFCTEUgPSBcIkBAaXRlcmF0b3IgcHJvcGVydHkgaXMgbm90IGNhbGxhYmxlXCI7XG4gIGNvbnN0IFJFRFVDRV9PRl9FTVBUWV9BUlJBWV9XSVRIX05PX0lOSVRJQUxfVkFMVUUgPVxuICAgIFwiUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZVwiO1xuICBjb25zdCBUSEVfQ09NUEFSSVNPTl9GVU5DVElPTl9NVVNUX0JFX0VJVEhFUl9BX0ZVTkNUSU9OX09SX1VOREVGSU5FRCA9XG4gICAgXCJUaGUgY29tcGFyaXNvbiBmdW5jdGlvbiBtdXN0IGJlIGVpdGhlciBhIGZ1bmN0aW9uIG9yIHVuZGVmaW5lZFwiO1xuICBjb25zdCBPRkZTRVRfSVNfT1VUX09GX0JPVU5EUyA9IFwiT2Zmc2V0IGlzIG91dCBvZiBib3VuZHNcIjtcblxuICBmdW5jdGlvbiB1bmN1cnJ5VGhpcyh0YXJnZXQpIHtcbiAgICByZXR1cm4gKHRoaXNBcmcsIC4uLmFyZ3MpID0+IHtcbiAgICAgIHJldHVybiBSZWZsZWN0QXBwbHkodGFyZ2V0LCB0aGlzQXJnLCBhcmdzKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHVuY3VycnlUaGlzR2V0dGVyKHRhcmdldCwga2V5KSB7XG4gICAgcmV0dXJuIHVuY3VycnlUaGlzKFxuICAgICAgUmVmbGVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBrZXlcbiAgICAgICkuZ2V0XG4gICAgKTtcbiAgfVxuICBjb25zdCB7XG4gICAgYXBwbHk6IFJlZmxlY3RBcHBseSxcbiAgICBjb25zdHJ1Y3Q6IFJlZmxlY3RDb25zdHJ1Y3QsXG4gICAgZGVmaW5lUHJvcGVydHk6IFJlZmxlY3REZWZpbmVQcm9wZXJ0eSxcbiAgICBnZXQ6IFJlZmxlY3RHZXQsXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBSZWZsZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAgIGdldFByb3RvdHlwZU9mOiBSZWZsZWN0R2V0UHJvdG90eXBlT2YsXG4gICAgaGFzOiBSZWZsZWN0SGFzLFxuICAgIG93bktleXM6IFJlZmxlY3RPd25LZXlzLFxuICAgIHNldDogUmVmbGVjdFNldCxcbiAgICBzZXRQcm90b3R5cGVPZjogUmVmbGVjdFNldFByb3RvdHlwZU9mLFxuICB9ID0gUmVmbGVjdDtcbiAgY29uc3QgTmF0aXZlUHJveHkgPSBQcm94eTtcbiAgY29uc3Qge1xuICAgIEVQU0lMT04sXG4gICAgTUFYX1NBRkVfSU5URUdFUixcbiAgICBpc0Zpbml0ZTogTnVtYmVySXNGaW5pdGUsXG4gICAgaXNOYU46IE51bWJlcklzTmFOLFxuICB9ID0gTnVtYmVyO1xuICBjb25zdCB7XG4gICAgaXRlcmF0b3I6IFN5bWJvbEl0ZXJhdG9yLFxuICAgIHNwZWNpZXM6IFN5bWJvbFNwZWNpZXMsXG4gICAgdG9TdHJpbmdUYWc6IFN5bWJvbFRvU3RyaW5nVGFnLFxuICAgIGZvcjogU3ltYm9sRm9yLFxuICB9ID0gU3ltYm9sO1xuICBjb25zdCBOYXRpdmVPYmplY3QgPSBPYmplY3Q7XG4gIGNvbnN0IHtcbiAgICBjcmVhdGU6IE9iamVjdENyZWF0ZSxcbiAgICBkZWZpbmVQcm9wZXJ0eTogT2JqZWN0RGVmaW5lUHJvcGVydHksXG4gICAgZnJlZXplOiBPYmplY3RGcmVlemUsXG4gICAgaXM6IE9iamVjdElzLFxuICB9ID0gTmF0aXZlT2JqZWN0O1xuICBjb25zdCBPYmplY3RQcm90b3R5cGUgPSBOYXRpdmVPYmplY3QucHJvdG90eXBlO1xuICBjb25zdCBPYmplY3RQcm90b3R5cGVfX2xvb2t1cEdldHRlcl9fID0gIChPYmplY3RQcm90b3R5cGUpLl9fbG9va3VwR2V0dGVyX19cbiAgICA/IHVuY3VycnlUaGlzKCAoT2JqZWN0UHJvdG90eXBlKS5fX2xvb2t1cEdldHRlcl9fKVxuICAgIDogKG9iamVjdCwga2V5KSA9PiB7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgTmF0aXZlVHlwZUVycm9yKFxuICAgICAgICAgIENBTk5PVF9DT05WRVJUX1VOREVGSU5FRF9PUl9OVUxMX1RPX09CSkVDVFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgbGV0IHRhcmdldCA9IE5hdGl2ZU9iamVjdChvYmplY3QpO1xuICAgICAgZG8ge1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gUmVmbGVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSk7XG4gICAgICAgIGlmIChkZXNjcmlwdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0SGFzT3duKGRlc2NyaXB0b3IsIFwiZ2V0XCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvci5nZXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoKHRhcmdldCA9IFJlZmxlY3RHZXRQcm90b3R5cGVPZih0YXJnZXQpKSAhPT0gbnVsbCk7XG4gICAgfTtcbiAgY29uc3QgT2JqZWN0SGFzT3duID0gIChOYXRpdmVPYmplY3QpLmhhc093biB8fFxuICAgIHVuY3VycnlUaGlzKE9iamVjdFByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG4gIGNvbnN0IE5hdGl2ZUFycmF5ID0gQXJyYXk7XG4gIGNvbnN0IEFycmF5SXNBcnJheSA9IE5hdGl2ZUFycmF5LmlzQXJyYXk7XG4gIGNvbnN0IEFycmF5UHJvdG90eXBlID0gTmF0aXZlQXJyYXkucHJvdG90eXBlO1xuICBjb25zdCBBcnJheVByb3RvdHlwZUpvaW4gPSB1bmN1cnJ5VGhpcyhBcnJheVByb3RvdHlwZS5qb2luKTtcbiAgY29uc3QgQXJyYXlQcm90b3R5cGVQdXNoID0gdW5jdXJyeVRoaXMoQXJyYXlQcm90b3R5cGUucHVzaCk7XG4gIGNvbnN0IEFycmF5UHJvdG90eXBlVG9Mb2NhbGVTdHJpbmcgPSB1bmN1cnJ5VGhpcyhcbiAgICBBcnJheVByb3RvdHlwZS50b0xvY2FsZVN0cmluZ1xuICApO1xuICBjb25zdCBOYXRpdmVBcnJheVByb3RvdHlwZVN5bWJvbEl0ZXJhdG9yID0gQXJyYXlQcm90b3R5cGVbU3ltYm9sSXRlcmF0b3JdO1xuICBjb25zdCBBcnJheVByb3RvdHlwZVN5bWJvbEl0ZXJhdG9yID0gdW5jdXJyeVRoaXMoTmF0aXZlQXJyYXlQcm90b3R5cGVTeW1ib2xJdGVyYXRvcik7XG4gIGNvbnN0IHtcbiAgICBhYnM6IE1hdGhBYnMsXG4gICAgdHJ1bmM6IE1hdGhUcnVuYyxcbiAgfSA9IE1hdGg7XG4gIGNvbnN0IE5hdGl2ZUFycmF5QnVmZmVyID0gQXJyYXlCdWZmZXI7XG4gIGNvbnN0IEFycmF5QnVmZmVySXNWaWV3ID0gTmF0aXZlQXJyYXlCdWZmZXIuaXNWaWV3O1xuICBjb25zdCBBcnJheUJ1ZmZlclByb3RvdHlwZSA9IE5hdGl2ZUFycmF5QnVmZmVyLnByb3RvdHlwZTtcbiAgY29uc3QgQXJyYXlCdWZmZXJQcm90b3R5cGVTbGljZSA9IHVuY3VycnlUaGlzKEFycmF5QnVmZmVyUHJvdG90eXBlLnNsaWNlKTtcbiAgY29uc3QgQXJyYXlCdWZmZXJQcm90b3R5cGVHZXRCeXRlTGVuZ3RoID0gdW5jdXJyeVRoaXNHZXR0ZXIoQXJyYXlCdWZmZXJQcm90b3R5cGUsIFwiYnl0ZUxlbmd0aFwiKTtcbiAgY29uc3QgTmF0aXZlU2hhcmVkQXJyYXlCdWZmZXIgPSB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIgPyBTaGFyZWRBcnJheUJ1ZmZlciA6IG51bGw7XG4gIGNvbnN0IFNoYXJlZEFycmF5QnVmZmVyUHJvdG90eXBlR2V0Qnl0ZUxlbmd0aCA9IE5hdGl2ZVNoYXJlZEFycmF5QnVmZmVyXG4gICAgJiYgdW5jdXJyeVRoaXNHZXR0ZXIoTmF0aXZlU2hhcmVkQXJyYXlCdWZmZXIucHJvdG90eXBlLCBcImJ5dGVMZW5ndGhcIik7XG4gIGNvbnN0IFR5cGVkQXJyYXkgPSBSZWZsZWN0R2V0UHJvdG90eXBlT2YoVWludDhBcnJheSk7XG4gIGNvbnN0IFR5cGVkQXJyYXlGcm9tID0gVHlwZWRBcnJheS5mcm9tO1xuICBjb25zdCBUeXBlZEFycmF5UHJvdG90eXBlID0gVHlwZWRBcnJheS5wcm90b3R5cGU7XG4gIGNvbnN0IE5hdGl2ZVR5cGVkQXJyYXlQcm90b3R5cGVTeW1ib2xJdGVyYXRvciA9IFR5cGVkQXJyYXlQcm90b3R5cGVbU3ltYm9sSXRlcmF0b3JdO1xuICBjb25zdCBUeXBlZEFycmF5UHJvdG90eXBlS2V5cyA9IHVuY3VycnlUaGlzKFR5cGVkQXJyYXlQcm90b3R5cGUua2V5cyk7XG4gIGNvbnN0IFR5cGVkQXJyYXlQcm90b3R5cGVWYWx1ZXMgPSB1bmN1cnJ5VGhpcyhcbiAgICBUeXBlZEFycmF5UHJvdG90eXBlLnZhbHVlc1xuICApO1xuICBjb25zdCBUeXBlZEFycmF5UHJvdG90eXBlRW50cmllcyA9IHVuY3VycnlUaGlzKFxuICAgIFR5cGVkQXJyYXlQcm90b3R5cGUuZW50cmllc1xuICApO1xuICBjb25zdCBUeXBlZEFycmF5UHJvdG90eXBlU2V0ID0gdW5jdXJyeVRoaXMoVHlwZWRBcnJheVByb3RvdHlwZS5zZXQpO1xuICBjb25zdCBUeXBlZEFycmF5UHJvdG90eXBlUmV2ZXJzZSA9IHVuY3VycnlUaGlzKFxuICAgIFR5cGVkQXJyYXlQcm90b3R5cGUucmV2ZXJzZVxuICApO1xuICBjb25zdCBUeXBlZEFycmF5UHJvdG90eXBlRmlsbCA9IHVuY3VycnlUaGlzKFR5cGVkQXJyYXlQcm90b3R5cGUuZmlsbCk7XG4gIGNvbnN0IFR5cGVkQXJyYXlQcm90b3R5cGVDb3B5V2l0aGluID0gdW5jdXJyeVRoaXMoXG4gICAgVHlwZWRBcnJheVByb3RvdHlwZS5jb3B5V2l0aGluXG4gICk7XG4gIGNvbnN0IFR5cGVkQXJyYXlQcm90b3R5cGVTb3J0ID0gdW5jdXJyeVRoaXMoVHlwZWRBcnJheVByb3RvdHlwZS5zb3J0KTtcbiAgY29uc3QgVHlwZWRBcnJheVByb3RvdHlwZVNsaWNlID0gdW5jdXJyeVRoaXMoVHlwZWRBcnJheVByb3RvdHlwZS5zbGljZSk7XG4gIGNvbnN0IFR5cGVkQXJyYXlQcm90b3R5cGVTdWJhcnJheSA9IHVuY3VycnlUaGlzKFxuICAgIFR5cGVkQXJyYXlQcm90b3R5cGUuc3ViYXJyYXlcbiAgKTtcbiAgY29uc3QgVHlwZWRBcnJheVByb3RvdHlwZUdldEJ1ZmZlciA9IHVuY3VycnlUaGlzR2V0dGVyKFxuICAgIFR5cGVkQXJyYXlQcm90b3R5cGUsXG4gICAgXCJidWZmZXJcIlxuICApO1xuICBjb25zdCBUeXBlZEFycmF5UHJvdG90eXBlR2V0Qnl0ZU9mZnNldCA9IHVuY3VycnlUaGlzR2V0dGVyKFxuICAgIFR5cGVkQXJyYXlQcm90b3R5cGUsXG4gICAgXCJieXRlT2Zmc2V0XCJcbiAgKTtcbiAgY29uc3QgVHlwZWRBcnJheVByb3RvdHlwZUdldExlbmd0aCA9IHVuY3VycnlUaGlzR2V0dGVyKFxuICAgIFR5cGVkQXJyYXlQcm90b3R5cGUsXG4gICAgXCJsZW5ndGhcIlxuICApO1xuICBjb25zdCBUeXBlZEFycmF5UHJvdG90eXBlR2V0U3ltYm9sVG9TdHJpbmdUYWcgPSB1bmN1cnJ5VGhpc0dldHRlcihcbiAgICBUeXBlZEFycmF5UHJvdG90eXBlLFxuICAgIFN5bWJvbFRvU3RyaW5nVGFnXG4gICk7XG4gIGNvbnN0IE5hdGl2ZVVpbnQ4QXJyYXkgPSBVaW50OEFycmF5O1xuICBjb25zdCBOYXRpdmVVaW50MTZBcnJheSA9IFVpbnQxNkFycmF5O1xuICBjb25zdCBVaW50MTZBcnJheUZyb20gPSAoLi4uYXJncykgPT4ge1xuICAgIHJldHVybiBSZWZsZWN0QXBwbHkoVHlwZWRBcnJheUZyb20sIE5hdGl2ZVVpbnQxNkFycmF5LCBhcmdzKTtcbiAgfTtcbiAgY29uc3QgTmF0aXZlVWludDMyQXJyYXkgPSBVaW50MzJBcnJheTtcbiAgY29uc3QgTmF0aXZlRmxvYXQzMkFycmF5ID0gRmxvYXQzMkFycmF5O1xuICBjb25zdCBBcnJheUl0ZXJhdG9yUHJvdG90eXBlID0gUmVmbGVjdEdldFByb3RvdHlwZU9mKFtdW1N5bWJvbEl0ZXJhdG9yXSgpKTtcbiAgY29uc3QgQXJyYXlJdGVyYXRvclByb3RvdHlwZU5leHQgPSB1bmN1cnJ5VGhpcyhBcnJheUl0ZXJhdG9yUHJvdG90eXBlLm5leHQpO1xuICBjb25zdCBHZW5lcmF0b3JQcm90b3R5cGVOZXh0ID0gdW5jdXJyeVRoaXMoKGZ1bmN0aW9uKiAoKSB7fSkoKS5uZXh0KTtcbiAgY29uc3QgSXRlcmF0b3JQcm90b3R5cGUgPSBSZWZsZWN0R2V0UHJvdG90eXBlT2YoQXJyYXlJdGVyYXRvclByb3RvdHlwZSk7XG4gIGNvbnN0IERhdGFWaWV3UHJvdG90eXBlID0gRGF0YVZpZXcucHJvdG90eXBlO1xuICBjb25zdCBEYXRhVmlld1Byb3RvdHlwZUdldFVpbnQxNiA9IHVuY3VycnlUaGlzKFxuICAgIERhdGFWaWV3UHJvdG90eXBlLmdldFVpbnQxNlxuICApO1xuICBjb25zdCBEYXRhVmlld1Byb3RvdHlwZVNldFVpbnQxNiA9IHVuY3VycnlUaGlzKFxuICAgIERhdGFWaWV3UHJvdG90eXBlLnNldFVpbnQxNlxuICApO1xuICBjb25zdCBOYXRpdmVUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG4gIGNvbnN0IE5hdGl2ZVJhbmdlRXJyb3IgPSBSYW5nZUVycm9yO1xuICBjb25zdCBOYXRpdmVXZWFrU2V0ID0gV2Vha1NldDtcbiAgY29uc3QgV2Vha1NldFByb3RvdHlwZSA9IE5hdGl2ZVdlYWtTZXQucHJvdG90eXBlO1xuICBjb25zdCBXZWFrU2V0UHJvdG90eXBlQWRkID0gdW5jdXJyeVRoaXMoV2Vha1NldFByb3RvdHlwZS5hZGQpO1xuICBjb25zdCBXZWFrU2V0UHJvdG90eXBlSGFzID0gdW5jdXJyeVRoaXMoV2Vha1NldFByb3RvdHlwZS5oYXMpO1xuICBjb25zdCBOYXRpdmVXZWFrTWFwID0gV2Vha01hcDtcbiAgY29uc3QgV2Vha01hcFByb3RvdHlwZSA9IE5hdGl2ZVdlYWtNYXAucHJvdG90eXBlO1xuICBjb25zdCBXZWFrTWFwUHJvdG90eXBlR2V0ID0gdW5jdXJyeVRoaXMoV2Vha01hcFByb3RvdHlwZS5nZXQpO1xuICBjb25zdCBXZWFrTWFwUHJvdG90eXBlSGFzID0gdW5jdXJyeVRoaXMoV2Vha01hcFByb3RvdHlwZS5oYXMpO1xuICBjb25zdCBXZWFrTWFwUHJvdG90eXBlU2V0ID0gdW5jdXJyeVRoaXMoV2Vha01hcFByb3RvdHlwZS5zZXQpO1xuXG4gIGNvbnN0IGFycmF5SXRlcmF0b3JzID0gbmV3IE5hdGl2ZVdlYWtNYXAoKTtcbiAgY29uc3QgU2FmZUl0ZXJhdG9yUHJvdG90eXBlID0gT2JqZWN0Q3JlYXRlKG51bGwsIHtcbiAgICBuZXh0OiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgY29uc3QgYXJyYXlJdGVyYXRvciA9IFdlYWtNYXBQcm90b3R5cGVHZXQoYXJyYXlJdGVyYXRvcnMsIHRoaXMpO1xuICAgICAgICByZXR1cm4gQXJyYXlJdGVyYXRvclByb3RvdHlwZU5leHQoYXJyYXlJdGVyYXRvcik7XG4gICAgICB9LFxuICAgIH0sXG4gICAgW1N5bWJvbEl0ZXJhdG9yXToge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgIH0sXG4gIH0pO1xuICBmdW5jdGlvbiBzYWZlSWZOZWVkZWQoYXJyYXkpIHtcbiAgICBpZiAoXG4gICAgICBhcnJheVtTeW1ib2xJdGVyYXRvcl0gPT09IE5hdGl2ZUFycmF5UHJvdG90eXBlU3ltYm9sSXRlcmF0b3IgJiZcbiAgICAgIEFycmF5SXRlcmF0b3JQcm90b3R5cGUubmV4dCA9PT0gQXJyYXlJdGVyYXRvclByb3RvdHlwZU5leHRcbiAgICApIHtcbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG4gICAgY29uc3Qgc2FmZSA9IE9iamVjdENyZWF0ZShTYWZlSXRlcmF0b3JQcm90b3R5cGUpO1xuICAgIFdlYWtNYXBQcm90b3R5cGVTZXQoYXJyYXlJdGVyYXRvcnMsIHNhZmUsIEFycmF5UHJvdG90eXBlU3ltYm9sSXRlcmF0b3IoYXJyYXkpKTtcbiAgICByZXR1cm4gc2FmZTtcbiAgfVxuICBjb25zdCBnZW5lcmF0b3JzID0gbmV3IE5hdGl2ZVdlYWtNYXAoKTtcbiAgY29uc3QgRHVtbXlBcnJheUl0ZXJhdG9yUHJvdG90eXBlID0gT2JqZWN0Q3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7XG4gICAgbmV4dDoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRvciA9IFdlYWtNYXBQcm90b3R5cGVHZXQoZ2VuZXJhdG9ycywgdGhpcyk7XG4gICAgICAgIHJldHVybiBHZW5lcmF0b3JQcm90b3R5cGVOZXh0KGdlbmVyYXRvcik7XG4gICAgICB9LFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgfSxcbiAgfSk7XG4gIGZvciAoY29uc3Qga2V5IG9mIFJlZmxlY3RPd25LZXlzKEFycmF5SXRlcmF0b3JQcm90b3R5cGUpKSB7XG4gICAgaWYgKGtleSA9PT0gXCJuZXh0XCIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBPYmplY3REZWZpbmVQcm9wZXJ0eShEdW1teUFycmF5SXRlcmF0b3JQcm90b3R5cGUsIGtleSwgUmVmbGVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcihBcnJheUl0ZXJhdG9yUHJvdG90eXBlLCBrZXkpKTtcbiAgfVxuICBmdW5jdGlvbiB3cmFwKGdlbmVyYXRvcikge1xuICAgIGNvbnN0IGR1bW15ID0gT2JqZWN0Q3JlYXRlKER1bW15QXJyYXlJdGVyYXRvclByb3RvdHlwZSk7XG4gICAgV2Vha01hcFByb3RvdHlwZVNldChnZW5lcmF0b3JzLCBkdW1teSwgZ2VuZXJhdG9yKTtcbiAgICByZXR1cm4gZHVtbXk7XG4gIH1cblxuICBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiAoXG4gICAgICAodmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB8fFxuICAgICAgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCI7XG4gIH1cbiAgZnVuY3Rpb24gaXNOYXRpdmVUeXBlZEFycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIFR5cGVkQXJyYXlQcm90b3R5cGVHZXRTeW1ib2xUb1N0cmluZ1RhZyh2YWx1ZSkgIT09IHVuZGVmaW5lZDtcbiAgfVxuICBmdW5jdGlvbiBpc05hdGl2ZUJpZ0ludFR5cGVkQXJyYXkodmFsdWUpIHtcbiAgICBjb25zdCB0eXBlZEFycmF5TmFtZSA9IFR5cGVkQXJyYXlQcm90b3R5cGVHZXRTeW1ib2xUb1N0cmluZ1RhZyh2YWx1ZSk7XG4gICAgcmV0dXJuIChcbiAgICAgIHR5cGVkQXJyYXlOYW1lID09PSBcIkJpZ0ludDY0QXJyYXlcIiB8fFxuICAgICAgdHlwZWRBcnJheU5hbWUgPT09IFwiQmlnVWludDY0QXJyYXlcIlxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoQXJyYXlJc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBBcnJheUJ1ZmZlclByb3RvdHlwZUdldEJ5dGVMZW5ndGgoICh2YWx1ZSkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyKHZhbHVlKSB7XG4gICAgaWYgKE5hdGl2ZVNoYXJlZEFycmF5QnVmZmVyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBTaGFyZWRBcnJheUJ1ZmZlclByb3RvdHlwZUdldEJ5dGVMZW5ndGgoICh2YWx1ZSkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpc0FueUFycmF5QnVmZmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzQXJyYXlCdWZmZXIodmFsdWUpIHx8IGlzU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUpO1xuICB9XG4gIGZ1bmN0aW9uIGlzT3JkaW5hcnlBcnJheSh2YWx1ZSkge1xuICAgIGlmICghQXJyYXlJc0FycmF5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgdmFsdWVbU3ltYm9sSXRlcmF0b3JdID09PSBOYXRpdmVBcnJheVByb3RvdHlwZVN5bWJvbEl0ZXJhdG9yICYmXG4gICAgICBBcnJheUl0ZXJhdG9yUHJvdG90eXBlLm5leHQgPT09IEFycmF5SXRlcmF0b3JQcm90b3R5cGVOZXh0XG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBpc09yZGluYXJ5TmF0aXZlVHlwZWRBcnJheSh2YWx1ZSkge1xuICAgIGlmICghaXNOYXRpdmVUeXBlZEFycmF5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgdmFsdWVbU3ltYm9sSXRlcmF0b3JdID09PSBOYXRpdmVUeXBlZEFycmF5UHJvdG90eXBlU3ltYm9sSXRlcmF0b3IgJiZcbiAgICAgIEFycmF5SXRlcmF0b3JQcm90b3R5cGUubmV4dCA9PT0gQXJyYXlJdGVyYXRvclByb3RvdHlwZU5leHRcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIGlzQ2Fub25pY2FsSW50ZWdlckluZGV4U3RyaW5nKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBudW1iZXIgPSArdmFsdWU7XG4gICAgaWYgKHZhbHVlICE9PSBudW1iZXIgKyBcIlwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghTnVtYmVySXNGaW5pdGUobnVtYmVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gbnVtYmVyID09PSBNYXRoVHJ1bmMobnVtYmVyKTtcbiAgfVxuXG4gIGNvbnN0IGJyYW5kID0gU3ltYm9sRm9yKFwiX19GbG9hdDE2QXJyYXlfX1wiKTtcbiAgZnVuY3Rpb24gaGFzRmxvYXQxNkFycmF5QnJhbmQodGFyZ2V0KSB7XG4gICAgaWYgKCFpc09iamVjdExpa2UodGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBwcm90b3R5cGUgPSBSZWZsZWN0R2V0UHJvdG90eXBlT2YodGFyZ2V0KTtcbiAgICBpZiAoIWlzT2JqZWN0TGlrZShwcm90b3R5cGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gcHJvdG90eXBlLmNvbnN0cnVjdG9yO1xuICAgIGlmIChjb25zdHJ1Y3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghaXNPYmplY3QoY29uc3RydWN0b3IpKSB7XG4gICAgICB0aHJvdyBOYXRpdmVUeXBlRXJyb3IoVEhFX0NPTlNUUlVDVE9SX1BST1BFUlRZX1ZBTFVFX0lTX05PVF9BTl9PQkpFQ1QpO1xuICAgIH1cbiAgICByZXR1cm4gUmVmbGVjdEhhcyhjb25zdHJ1Y3RvciwgYnJhbmQpO1xuICB9XG5cbiAgY29uc3QgSU5WRVJTRV9PRl9FUFNJTE9OID0gMSAvIEVQU0lMT047XG4gIGZ1bmN0aW9uIHJvdW5kVGllc1RvRXZlbihudW0pIHtcbiAgICByZXR1cm4gKG51bSArIElOVkVSU0VfT0ZfRVBTSUxPTikgLSBJTlZFUlNFX09GX0VQU0lMT047XG4gIH1cbiAgY29uc3QgRkxPQVQxNl9NSU5fVkFMVUUgPSA2LjEwMzUxNTYyNWUtMDU7XG4gIGNvbnN0IEZMT0FUMTZfTUFYX1ZBTFVFID0gNjU1MDQ7XG4gIGNvbnN0IEZMT0FUMTZfRVBTSUxPTiA9IDAuMDAwOTc2NTYyNTtcbiAgY29uc3QgRkxPQVQxNl9FUFNJTE9OX01VTFRJUExJRURfQllfRkxPQVQxNl9NSU5fVkFMVUUgPSBGTE9BVDE2X0VQU0lMT04gKiBGTE9BVDE2X01JTl9WQUxVRTtcbiAgY29uc3QgRkxPQVQxNl9FUFNJTE9OX0RFVklERURfQllfRVBTSUxPTiA9IEZMT0FUMTZfRVBTSUxPTiAqIElOVkVSU0VfT0ZfRVBTSUxPTjtcbiAgZnVuY3Rpb24gcm91bmRUb0Zsb2F0MTYobnVtKSB7XG4gICAgY29uc3QgbnVtYmVyID0gK251bTtcbiAgICBpZiAoIU51bWJlcklzRmluaXRlKG51bWJlcikgfHwgbnVtYmVyID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVtYmVyO1xuICAgIH1cbiAgICBjb25zdCBzaWduID0gbnVtYmVyID4gMCA/IDEgOiAtMTtcbiAgICBjb25zdCBhYnNvbHV0ZSA9IE1hdGhBYnMobnVtYmVyKTtcbiAgICBpZiAoYWJzb2x1dGUgPCBGTE9BVDE2X01JTl9WQUxVRSkge1xuICAgICAgcmV0dXJuIHNpZ24gKiByb3VuZFRpZXNUb0V2ZW4oYWJzb2x1dGUgLyBGTE9BVDE2X0VQU0lMT05fTVVMVElQTElFRF9CWV9GTE9BVDE2X01JTl9WQUxVRSkgKiBGTE9BVDE2X0VQU0lMT05fTVVMVElQTElFRF9CWV9GTE9BVDE2X01JTl9WQUxVRTtcbiAgICB9XG4gICAgY29uc3QgdGVtcCA9ICgxICsgRkxPQVQxNl9FUFNJTE9OX0RFVklERURfQllfRVBTSUxPTikgKiBhYnNvbHV0ZTtcbiAgICBjb25zdCByZXN1bHQgPSB0ZW1wIC0gKHRlbXAgLSBhYnNvbHV0ZSk7XG4gICAgaWYgKHJlc3VsdCA+IEZMT0FUMTZfTUFYX1ZBTFVFIHx8IE51bWJlcklzTmFOKHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiBzaWduICogSW5maW5pdHk7XG4gICAgfVxuICAgIHJldHVybiBzaWduICogcmVzdWx0O1xuICB9XG4gIGNvbnN0IGJ1ZmZlciA9IG5ldyBOYXRpdmVBcnJheUJ1ZmZlcig0KTtcbiAgY29uc3QgZmxvYXRWaWV3ID0gbmV3IE5hdGl2ZUZsb2F0MzJBcnJheShidWZmZXIpO1xuICBjb25zdCB1aW50MzJWaWV3ID0gbmV3IE5hdGl2ZVVpbnQzMkFycmF5KGJ1ZmZlcik7XG4gIGNvbnN0IGJhc2VUYWJsZSA9IG5ldyBOYXRpdmVVaW50MTZBcnJheSg1MTIpO1xuICBjb25zdCBzaGlmdFRhYmxlID0gbmV3IE5hdGl2ZVVpbnQ4QXJyYXkoNTEyKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICAgIGNvbnN0IGUgPSBpIC0gMTI3O1xuICAgIGlmIChlIDwgLTI0KSB7XG4gICAgICBiYXNlVGFibGVbaV0gICAgICAgICA9IDB4MDAwMDtcbiAgICAgIGJhc2VUYWJsZVtpIHwgMHgxMDBdID0gMHg4MDAwO1xuICAgICAgc2hpZnRUYWJsZVtpXSAgICAgICAgID0gMjQ7XG4gICAgICBzaGlmdFRhYmxlW2kgfCAweDEwMF0gPSAyNDtcbiAgICB9IGVsc2UgaWYgKGUgPCAtMTQpIHtcbiAgICAgIGJhc2VUYWJsZVtpXSAgICAgICAgID0gIDB4MDQwMCA+PiAoLWUgLSAxNCk7XG4gICAgICBiYXNlVGFibGVbaSB8IDB4MTAwXSA9ICgweDA0MDAgPj4gKC1lIC0gMTQpKSB8IDB4ODAwMDtcbiAgICAgIHNoaWZ0VGFibGVbaV0gICAgICAgICA9IC1lIC0gMTtcbiAgICAgIHNoaWZ0VGFibGVbaSB8IDB4MTAwXSA9IC1lIC0gMTtcbiAgICB9IGVsc2UgaWYgKGUgPD0gMTUpIHtcbiAgICAgIGJhc2VUYWJsZVtpXSAgICAgICAgID0gIChlICsgMTUpIDw8IDEwO1xuICAgICAgYmFzZVRhYmxlW2kgfCAweDEwMF0gPSAoKGUgKyAxNSkgPDwgMTApIHwgMHg4MDAwO1xuICAgICAgc2hpZnRUYWJsZVtpXSAgICAgICAgID0gMTM7XG4gICAgICBzaGlmdFRhYmxlW2kgfCAweDEwMF0gPSAxMztcbiAgICB9IGVsc2UgaWYgKGUgPCAxMjgpIHtcbiAgICAgIGJhc2VUYWJsZVtpXSAgICAgICAgID0gMHg3YzAwO1xuICAgICAgYmFzZVRhYmxlW2kgfCAweDEwMF0gPSAweGZjMDA7XG4gICAgICBzaGlmdFRhYmxlW2ldICAgICAgICAgPSAyNDtcbiAgICAgIHNoaWZ0VGFibGVbaSB8IDB4MTAwXSA9IDI0O1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlVGFibGVbaV0gICAgICAgICA9IDB4N2MwMDtcbiAgICAgIGJhc2VUYWJsZVtpIHwgMHgxMDBdID0gMHhmYzAwO1xuICAgICAgc2hpZnRUYWJsZVtpXSAgICAgICAgID0gMTM7XG4gICAgICBzaGlmdFRhYmxlW2kgfCAweDEwMF0gPSAxMztcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcm91bmRUb0Zsb2F0MTZCaXRzKG51bSkge1xuICAgIGZsb2F0Vmlld1swXSA9IHJvdW5kVG9GbG9hdDE2KG51bSk7XG4gICAgY29uc3QgZiA9IHVpbnQzMlZpZXdbMF07XG4gICAgY29uc3QgZSA9IChmID4+IDIzKSAmIDB4MWZmO1xuICAgIHJldHVybiBiYXNlVGFibGVbZV0gKyAoKGYgJiAweDAwN2ZmZmZmKSA+PiBzaGlmdFRhYmxlW2VdKTtcbiAgfVxuICBjb25zdCBtYW50aXNzYVRhYmxlID0gbmV3IE5hdGl2ZVVpbnQzMkFycmF5KDIwNDgpO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IDEwMjQ7ICsraSkge1xuICAgIGxldCBtID0gaSA8PCAxMztcbiAgICBsZXQgZSA9IDA7XG4gICAgd2hpbGUgKChtICYgMHgwMDgwMDAwMCkgPT09IDApIHtcbiAgICAgIG0gPDw9IDE7XG4gICAgICBlIC09IDB4MDA4MDAwMDA7XG4gICAgfVxuICAgIG0gJj0gfjB4MDA4MDAwMDA7XG4gICAgZSArPSAweDM4ODAwMDAwO1xuICAgIG1hbnRpc3NhVGFibGVbaV0gPSBtIHwgZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMTAyNDsgaSA8IDIwNDg7ICsraSkge1xuICAgIG1hbnRpc3NhVGFibGVbaV0gPSAweDM4MDAwMDAwICsgKChpIC0gMTAyNCkgPDwgMTMpO1xuICB9XG4gIGNvbnN0IGV4cG9uZW50VGFibGUgPSBuZXcgTmF0aXZlVWludDMyQXJyYXkoNjQpO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IDMxOyArK2kpIHtcbiAgICBleHBvbmVudFRhYmxlW2ldID0gaSA8PCAyMztcbiAgfVxuICBleHBvbmVudFRhYmxlWzMxXSA9IDB4NDc4MDAwMDA7XG4gIGV4cG9uZW50VGFibGVbMzJdID0gMHg4MDAwMDAwMDtcbiAgZm9yIChsZXQgaSA9IDMzOyBpIDwgNjM7ICsraSkge1xuICAgIGV4cG9uZW50VGFibGVbaV0gPSAweDgwMDAwMDAwICsgKChpIC0gMzIpIDw8IDIzKTtcbiAgfVxuICBleHBvbmVudFRhYmxlWzYzXSA9IDB4Yzc4MDAwMDA7XG4gIGNvbnN0IG9mZnNldFRhYmxlID0gbmV3IE5hdGl2ZVVpbnQxNkFycmF5KDY0KTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCA2NDsgKytpKSB7XG4gICAgaWYgKGkgIT09IDMyKSB7XG4gICAgICBvZmZzZXRUYWJsZVtpXSA9IDEwMjQ7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGNvbnZlcnRUb051bWJlcihmbG9hdDE2Yml0cykge1xuICAgIGNvbnN0IGkgPSBmbG9hdDE2Yml0cyA+PiAxMDtcbiAgICB1aW50MzJWaWV3WzBdID0gbWFudGlzc2FUYWJsZVtvZmZzZXRUYWJsZVtpXSArIChmbG9hdDE2Yml0cyAmIDB4M2ZmKV0gKyBleHBvbmVudFRhYmxlW2ldO1xuICAgIHJldHVybiBmbG9hdFZpZXdbMF07XG4gIH1cblxuICBmdW5jdGlvbiBUb0ludGVnZXJPckluZmluaXR5KHRhcmdldCkge1xuICAgIGNvbnN0IG51bWJlciA9ICt0YXJnZXQ7XG4gICAgaWYgKE51bWJlcklzTmFOKG51bWJlcikgfHwgbnVtYmVyID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGhUcnVuYyhudW1iZXIpO1xuICB9XG4gIGZ1bmN0aW9uIFRvTGVuZ3RoKHRhcmdldCkge1xuICAgIGNvbnN0IGxlbmd0aCA9IFRvSW50ZWdlck9ySW5maW5pdHkodGFyZ2V0KTtcbiAgICBpZiAobGVuZ3RoIDwgMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiBsZW5ndGggPCBNQVhfU0FGRV9JTlRFR0VSXG4gICAgICA/IGxlbmd0aFxuICAgICAgOiBNQVhfU0FGRV9JTlRFR0VSO1xuICB9XG4gIGZ1bmN0aW9uIFNwZWNpZXNDb25zdHJ1Y3Rvcih0YXJnZXQsIGRlZmF1bHRDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghaXNPYmplY3QodGFyZ2V0KSkge1xuICAgICAgdGhyb3cgTmF0aXZlVHlwZUVycm9yKFRISVNfSVNfTk9UX0FOX09CSkVDVCk7XG4gICAgfVxuICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gdGFyZ2V0LmNvbnN0cnVjdG9yO1xuICAgIGlmIChjb25zdHJ1Y3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdENvbnN0cnVjdG9yO1xuICAgIH1cbiAgICBpZiAoIWlzT2JqZWN0KGNvbnN0cnVjdG9yKSkge1xuICAgICAgdGhyb3cgTmF0aXZlVHlwZUVycm9yKFRIRV9DT05TVFJVQ1RPUl9QUk9QRVJUWV9WQUxVRV9JU19OT1RfQU5fT0JKRUNUKTtcbiAgICB9XG4gICAgY29uc3Qgc3BlY2llcyA9IGNvbnN0cnVjdG9yW1N5bWJvbFNwZWNpZXNdO1xuICAgIGlmIChzcGVjaWVzID09IG51bGwpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0Q29uc3RydWN0b3I7XG4gICAgfVxuICAgIHJldHVybiBzcGVjaWVzO1xuICB9XG4gIGZ1bmN0aW9uIElzRGV0YWNoZWRCdWZmZXIoYnVmZmVyKSB7XG4gICAgaWYgKGlzU2hhcmVkQXJyYXlCdWZmZXIoYnVmZmVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgQXJyYXlCdWZmZXJQcm90b3R5cGVTbGljZShidWZmZXIsIDAsIDApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gZGVmYXVsdENvbXBhcmUoeCwgeSkge1xuICAgIGNvbnN0IGlzWE5hTiA9IE51bWJlcklzTmFOKHgpO1xuICAgIGNvbnN0IGlzWU5hTiA9IE51bWJlcklzTmFOKHkpO1xuICAgIGlmIChpc1hOYU4gJiYgaXNZTmFOKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKGlzWE5hTikge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGlmIChpc1lOYU4pIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaWYgKHggPCB5KSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmICh4ID4geSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGlmICh4ID09PSAwICYmIHkgPT09IDApIHtcbiAgICAgIGNvbnN0IGlzWFBsdXNaZXJvID0gT2JqZWN0SXMoeCwgMCk7XG4gICAgICBjb25zdCBpc1lQbHVzWmVybyA9IE9iamVjdElzKHksIDApO1xuICAgICAgaWYgKCFpc1hQbHVzWmVybyAmJiBpc1lQbHVzWmVybykge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBpZiAoaXNYUGx1c1plcm8gJiYgIWlzWVBsdXNaZXJvKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGNvbnN0IEJZVEVTX1BFUl9FTEVNRU5UID0gMjtcbiAgY29uc3QgZmxvYXQxNmJpdHNBcnJheXMgPSBuZXcgTmF0aXZlV2Vha01hcCgpO1xuICBmdW5jdGlvbiBpc0Zsb2F0MTZBcnJheSh0YXJnZXQpIHtcbiAgICByZXR1cm4gV2Vha01hcFByb3RvdHlwZUhhcyhmbG9hdDE2Yml0c0FycmF5cywgdGFyZ2V0KSB8fFxuICAgICAgKCFBcnJheUJ1ZmZlcklzVmlldyh0YXJnZXQpICYmIGhhc0Zsb2F0MTZBcnJheUJyYW5kKHRhcmdldCkpO1xuICB9XG4gIGZ1bmN0aW9uIGFzc2VydEZsb2F0MTZBcnJheSh0YXJnZXQpIHtcbiAgICBpZiAoIWlzRmxvYXQxNkFycmF5KHRhcmdldCkpIHtcbiAgICAgIHRocm93IE5hdGl2ZVR5cGVFcnJvcihUSElTX0lTX05PVF9BX0ZMT0FUMTZBUlJBWV9PQkpFQ1QpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBhc3NlcnRTcGVjaWVzVHlwZWRBcnJheSh0YXJnZXQsIGNvdW50KSB7XG4gICAgY29uc3QgaXNUYXJnZXRGbG9hdDE2QXJyYXkgPSBpc0Zsb2F0MTZBcnJheSh0YXJnZXQpO1xuICAgIGNvbnN0IGlzVGFyZ2V0VHlwZWRBcnJheSA9IGlzTmF0aXZlVHlwZWRBcnJheSh0YXJnZXQpO1xuICAgIGlmICghaXNUYXJnZXRGbG9hdDE2QXJyYXkgJiYgIWlzVGFyZ2V0VHlwZWRBcnJheSkge1xuICAgICAgdGhyb3cgTmF0aXZlVHlwZUVycm9yKFNQRUNJRVNfQ09OU1RSVUNUT1JfRElETlRfUkVUVVJOX1RZUEVEQVJSQVlfT0JKRUNUKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb3VudCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgbGV0IGxlbmd0aDtcbiAgICAgIGlmIChpc1RhcmdldEZsb2F0MTZBcnJheSkge1xuICAgICAgICBjb25zdCBmbG9hdDE2Yml0c0FycmF5ID0gZ2V0RmxvYXQxNkJpdHNBcnJheSh0YXJnZXQpO1xuICAgICAgICBsZW5ndGggPSBUeXBlZEFycmF5UHJvdG90eXBlR2V0TGVuZ3RoKGZsb2F0MTZiaXRzQXJyYXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVuZ3RoID0gVHlwZWRBcnJheVByb3RvdHlwZUdldExlbmd0aCh0YXJnZXQpO1xuICAgICAgfVxuICAgICAgaWYgKGxlbmd0aCA8IGNvdW50KSB7XG4gICAgICAgIHRocm93IE5hdGl2ZVR5cGVFcnJvcihcbiAgICAgICAgICBERVJJVkVEX0NPTlNUUlVDVE9SX0NSRUFURURfVFlQRURBUlJBWV9PQkpFQ1RfV0hJQ0hfV0FTX1RPT19TTUFMTF9MRU5HVEhcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzTmF0aXZlQmlnSW50VHlwZWRBcnJheSh0YXJnZXQpKSB7XG4gICAgICB0aHJvdyBOYXRpdmVUeXBlRXJyb3IoQ0FOTk9UX01JWF9CSUdJTlRfQU5EX09USEVSX1RZUEVTKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RmxvYXQxNkJpdHNBcnJheShmbG9hdDE2KSB7XG4gICAgY29uc3QgZmxvYXQxNmJpdHNBcnJheSA9IFdlYWtNYXBQcm90b3R5cGVHZXQoZmxvYXQxNmJpdHNBcnJheXMsIGZsb2F0MTYpO1xuICAgIGlmIChmbG9hdDE2Yml0c0FycmF5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IFR5cGVkQXJyYXlQcm90b3R5cGVHZXRCdWZmZXIoZmxvYXQxNmJpdHNBcnJheSk7XG4gICAgICBpZiAoSXNEZXRhY2hlZEJ1ZmZlcihidWZmZXIpKSB7XG4gICAgICAgIHRocm93IE5hdGl2ZVR5cGVFcnJvcihBVFRFTVBUSU5HX1RPX0FDQ0VTU19ERVRBQ0hFRF9BUlJBWUJVRkZFUik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmxvYXQxNmJpdHNBcnJheTtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVyID0gIChmbG9hdDE2KS5idWZmZXI7XG4gICAgaWYgKElzRGV0YWNoZWRCdWZmZXIoYnVmZmVyKSkge1xuICAgICAgdGhyb3cgTmF0aXZlVHlwZUVycm9yKEFUVEVNUFRJTkdfVE9fQUNDRVNTX0RFVEFDSEVEX0FSUkFZQlVGRkVSKTtcbiAgICB9XG4gICAgY29uc3QgY2xvbmVkID0gUmVmbGVjdENvbnN0cnVjdChGbG9hdDE2QXJyYXksIFtcbiAgICAgIGJ1ZmZlcixcbiAgICAgICAoZmxvYXQxNikuYnl0ZU9mZnNldCxcbiAgICAgICAoZmxvYXQxNikubGVuZ3RoLFxuICAgIF0sIGZsb2F0MTYuY29uc3RydWN0b3IpO1xuICAgIHJldHVybiBXZWFrTWFwUHJvdG90eXBlR2V0KGZsb2F0MTZiaXRzQXJyYXlzLCBjbG9uZWQpO1xuICB9XG4gIGZ1bmN0aW9uIGNvcHlUb0FycmF5KGZsb2F0MTZiaXRzQXJyYXkpIHtcbiAgICBjb25zdCBsZW5ndGggPSBUeXBlZEFycmF5UHJvdG90eXBlR2V0TGVuZ3RoKGZsb2F0MTZiaXRzQXJyYXkpO1xuICAgIGNvbnN0IGFycmF5ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgYXJyYXlbaV0gPSBjb252ZXJ0VG9OdW1iZXIoZmxvYXQxNmJpdHNBcnJheVtpXSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuICBjb25zdCBUeXBlZEFycmF5UHJvdG90eXBlR2V0dGVycyA9IG5ldyBOYXRpdmVXZWFrU2V0KCk7XG4gIGZvciAoY29uc3Qga2V5IG9mIFJlZmxlY3RPd25LZXlzKFR5cGVkQXJyYXlQcm90b3R5cGUpKSB7XG4gICAgaWYgKGtleSA9PT0gU3ltYm9sVG9TdHJpbmdUYWcpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBkZXNjcmlwdG9yID0gUmVmbGVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcihUeXBlZEFycmF5UHJvdG90eXBlLCBrZXkpO1xuICAgIGlmIChPYmplY3RIYXNPd24oZGVzY3JpcHRvciwgXCJnZXRcIikgJiYgdHlwZW9mIGRlc2NyaXB0b3IuZ2V0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIFdlYWtTZXRQcm90b3R5cGVBZGQoVHlwZWRBcnJheVByb3RvdHlwZUdldHRlcnMsIGRlc2NyaXB0b3IuZ2V0KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgaGFuZGxlciA9IE9iamVjdEZyZWV6ZSggKHtcbiAgICBnZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSB7XG4gICAgICBpZiAoaXNDYW5vbmljYWxJbnRlZ2VySW5kZXhTdHJpbmcoa2V5KSAmJiBPYmplY3RIYXNPd24odGFyZ2V0LCBrZXkpKSB7XG4gICAgICAgIHJldHVybiBjb252ZXJ0VG9OdW1iZXIoUmVmbGVjdEdldCh0YXJnZXQsIGtleSkpO1xuICAgICAgfVxuICAgICAgaWYgKFdlYWtTZXRQcm90b3R5cGVIYXMoVHlwZWRBcnJheVByb3RvdHlwZUdldHRlcnMsIE9iamVjdFByb3RvdHlwZV9fbG9va3VwR2V0dGVyX18odGFyZ2V0LCBrZXkpKSkge1xuICAgICAgICByZXR1cm4gUmVmbGVjdEdldCh0YXJnZXQsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVmbGVjdEdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpO1xuICAgIH0sXG4gICAgc2V0KHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICAgIGlmIChpc0Nhbm9uaWNhbEludGVnZXJJbmRleFN0cmluZyhrZXkpICYmIE9iamVjdEhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3RTZXQodGFyZ2V0LCBrZXksIHJvdW5kVG9GbG9hdDE2Qml0cyh2YWx1ZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFJlZmxlY3RTZXQodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcik7XG4gICAgfSxcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIHtcbiAgICAgIGlmIChpc0Nhbm9uaWNhbEludGVnZXJJbmRleFN0cmluZyhrZXkpICYmIE9iamVjdEhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IFJlZmxlY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xuICAgICAgICBkZXNjcmlwdG9yLnZhbHVlID0gY29udmVydFRvTnVtYmVyKGRlc2NyaXB0b3IudmFsdWUpO1xuICAgICAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWZsZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcbiAgICB9LFxuICAgIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGlzQ2Fub25pY2FsSW50ZWdlckluZGV4U3RyaW5nKGtleSkgJiZcbiAgICAgICAgT2JqZWN0SGFzT3duKHRhcmdldCwga2V5KSAmJlxuICAgICAgICBPYmplY3RIYXNPd24oZGVzY3JpcHRvciwgXCJ2YWx1ZVwiKVxuICAgICAgKSB7XG4gICAgICAgIGRlc2NyaXB0b3IudmFsdWUgPSByb3VuZFRvRmxvYXQxNkJpdHMoZGVzY3JpcHRvci52YWx1ZSk7XG4gICAgICAgIHJldHVybiBSZWZsZWN0RGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFJlZmxlY3REZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgfSxcbiAgfSkpO1xuICBjbGFzcyBGbG9hdDE2QXJyYXkge1xuICAgIGNvbnN0cnVjdG9yKGlucHV0LCBfYnl0ZU9mZnNldCwgX2xlbmd0aCkge1xuICAgICAgbGV0IGZsb2F0MTZiaXRzQXJyYXk7XG4gICAgICBpZiAoaXNGbG9hdDE2QXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIGZsb2F0MTZiaXRzQXJyYXkgPSBSZWZsZWN0Q29uc3RydWN0KE5hdGl2ZVVpbnQxNkFycmF5LCBbZ2V0RmxvYXQxNkJpdHNBcnJheShpbnB1dCldLCBuZXcudGFyZ2V0KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoaW5wdXQpICYmICFpc0FueUFycmF5QnVmZmVyKGlucHV0KSkge1xuICAgICAgICBsZXQgbGlzdDtcbiAgICAgICAgbGV0IGxlbmd0aDtcbiAgICAgICAgaWYgKGlzTmF0aXZlVHlwZWRBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICBsaXN0ID0gaW5wdXQ7XG4gICAgICAgICAgbGVuZ3RoID0gVHlwZWRBcnJheVByb3RvdHlwZUdldExlbmd0aChpbnB1dCk7XG4gICAgICAgICAgY29uc3QgYnVmZmVyID0gVHlwZWRBcnJheVByb3RvdHlwZUdldEJ1ZmZlcihpbnB1dCk7XG4gICAgICAgICAgaWYgKElzRGV0YWNoZWRCdWZmZXIoYnVmZmVyKSkge1xuICAgICAgICAgICAgdGhyb3cgTmF0aXZlVHlwZUVycm9yKEFUVEVNUFRJTkdfVE9fQUNDRVNTX0RFVEFDSEVEX0FSUkFZQlVGRkVSKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzTmF0aXZlQmlnSW50VHlwZWRBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIHRocm93IE5hdGl2ZVR5cGVFcnJvcihDQU5OT1RfTUlYX0JJR0lOVF9BTkRfT1RIRVJfVFlQRVMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBkYXRhID0gbmV3IE5hdGl2ZUFycmF5QnVmZmVyKFxuICAgICAgICAgICAgbGVuZ3RoICogQllURVNfUEVSX0VMRU1FTlRcbiAgICAgICAgICApO1xuICAgICAgICAgIGZsb2F0MTZiaXRzQXJyYXkgPSBSZWZsZWN0Q29uc3RydWN0KE5hdGl2ZVVpbnQxNkFycmF5LCBbZGF0YV0sIG5ldy50YXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gaW5wdXRbU3ltYm9sSXRlcmF0b3JdO1xuICAgICAgICAgIGlmIChpdGVyYXRvciAhPSBudWxsICYmIHR5cGVvZiBpdGVyYXRvciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBOYXRpdmVUeXBlRXJyb3IoSVRFUkFUT1JfUFJPUEVSVFlfSVNfTk9UX0NBTExBQkxFKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChpc09yZGluYXJ5QXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICAgIGxpc3QgPSBpbnB1dDtcbiAgICAgICAgICAgICAgbGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbGlzdCA9IFsuLi4gIChpbnB1dCldO1xuICAgICAgICAgICAgICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGlzdCA9ICAoaW5wdXQpO1xuICAgICAgICAgICAgbGVuZ3RoID0gVG9MZW5ndGgobGlzdC5sZW5ndGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbG9hdDE2Yml0c0FycmF5ID0gUmVmbGVjdENvbnN0cnVjdChOYXRpdmVVaW50MTZBcnJheSwgW2xlbmd0aF0sIG5ldy50YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBmbG9hdDE2Yml0c0FycmF5W2ldID0gcm91bmRUb0Zsb2F0MTZCaXRzKGxpc3RbaV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbG9hdDE2Yml0c0FycmF5ID0gUmVmbGVjdENvbnN0cnVjdChOYXRpdmVVaW50MTZBcnJheSwgYXJndW1lbnRzLCBuZXcudGFyZ2V0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByb3h5ID0gIChuZXcgTmF0aXZlUHJveHkoZmxvYXQxNmJpdHNBcnJheSwgaGFuZGxlcikpO1xuICAgICAgV2Vha01hcFByb3RvdHlwZVNldChmbG9hdDE2Yml0c0FycmF5cywgcHJveHksIGZsb2F0MTZiaXRzQXJyYXkpO1xuICAgICAgcmV0dXJuIHByb3h5O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShzcmMsIC4uLm9wdHMpIHtcbiAgICAgIGNvbnN0IENvbnN0cnVjdG9yID0gdGhpcztcbiAgICAgIGlmICghUmVmbGVjdEhhcyhDb25zdHJ1Y3RvciwgYnJhbmQpKSB7XG4gICAgICAgIHRocm93IE5hdGl2ZVR5cGVFcnJvcihcbiAgICAgICAgICBUSElTX0NPTlNUUlVDVE9SX0lTX05PVF9BX1NVQkNMQVNTX09GX0ZMT0FUMTZBUlJBWVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKENvbnN0cnVjdG9yID09PSBGbG9hdDE2QXJyYXkpIHtcbiAgICAgICAgaWYgKGlzRmxvYXQxNkFycmF5KHNyYykgJiYgb3B0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBjb25zdCBmbG9hdDE2Yml0c0FycmF5ID0gZ2V0RmxvYXQxNkJpdHNBcnJheShzcmMpO1xuICAgICAgICAgIGNvbnN0IHVpbnQxNiA9IG5ldyBOYXRpdmVVaW50MTZBcnJheShcbiAgICAgICAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGVHZXRCdWZmZXIoZmxvYXQxNmJpdHNBcnJheSksXG4gICAgICAgICAgICBUeXBlZEFycmF5UHJvdG90eXBlR2V0Qnl0ZU9mZnNldChmbG9hdDE2Yml0c0FycmF5KSxcbiAgICAgICAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGVHZXRMZW5ndGgoZmxvYXQxNmJpdHNBcnJheSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBuZXcgRmxvYXQxNkFycmF5KFxuICAgICAgICAgICAgVHlwZWRBcnJheVByb3RvdHlwZUdldEJ1ZmZlcihUeXBlZEFycmF5UHJvdG90eXBlU2xpY2UodWludDE2KSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBuZXcgRmxvYXQxNkFycmF5KFxuICAgICAgICAgICAgVHlwZWRBcnJheVByb3RvdHlwZUdldEJ1ZmZlcihcbiAgICAgICAgICAgICAgVWludDE2QXJyYXlGcm9tKHNyYywgcm91bmRUb0Zsb2F0MTZCaXRzKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWFwRnVuYyA9IG9wdHNbMF07XG4gICAgICAgIGNvbnN0IHRoaXNBcmcgPSBvcHRzWzFdO1xuICAgICAgICByZXR1cm4gbmV3IEZsb2F0MTZBcnJheShcbiAgICAgICAgICBUeXBlZEFycmF5UHJvdG90eXBlR2V0QnVmZmVyKFxuICAgICAgICAgICAgVWludDE2QXJyYXlGcm9tKHNyYywgZnVuY3Rpb24gKHZhbCwgLi4uYXJncykge1xuICAgICAgICAgICAgICByZXR1cm4gcm91bmRUb0Zsb2F0MTZCaXRzKFxuICAgICAgICAgICAgICAgIFJlZmxlY3RBcHBseShtYXBGdW5jLCB0aGlzLCBbdmFsLCAuLi5zYWZlSWZOZWVkZWQoYXJncyldKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSwgdGhpc0FyZylcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBsZXQgbGlzdDtcbiAgICAgIGxldCBsZW5ndGg7XG4gICAgICBjb25zdCBpdGVyYXRvciA9IHNyY1tTeW1ib2xJdGVyYXRvcl07XG4gICAgICBpZiAoaXRlcmF0b3IgIT0gbnVsbCAmJiB0eXBlb2YgaXRlcmF0b3IgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBOYXRpdmVUeXBlRXJyb3IoSVRFUkFUT1JfUFJPUEVSVFlfSVNfTk9UX0NBTExBQkxFKTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVyYXRvciAhPSBudWxsKSB7XG4gICAgICAgIGlmIChpc09yZGluYXJ5QXJyYXkoc3JjKSkge1xuICAgICAgICAgIGxpc3QgPSBzcmM7XG4gICAgICAgICAgbGVuZ3RoID0gc3JjLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIGlmIChpc09yZGluYXJ5TmF0aXZlVHlwZWRBcnJheShzcmMpKSB7XG4gICAgICAgICAgbGlzdCA9IHNyYztcbiAgICAgICAgICBsZW5ndGggPSBUeXBlZEFycmF5UHJvdG90eXBlR2V0TGVuZ3RoKHNyYyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGlzdCA9IFsuLi5zcmNdO1xuICAgICAgICAgIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc3JjID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBOYXRpdmVUeXBlRXJyb3IoXG4gICAgICAgICAgICBDQU5OT1RfQ09OVkVSVF9VTkRFRklORURfT1JfTlVMTF9UT19PQkpFQ1RcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGxpc3QgPSBOYXRpdmVPYmplY3Qoc3JjKTtcbiAgICAgICAgbGVuZ3RoID0gVG9MZW5ndGgobGlzdC5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgY29uc3QgYXJyYXkgPSBuZXcgQ29uc3RydWN0b3IobGVuZ3RoKTtcbiAgICAgIGlmIChvcHRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgYXJyYXlbaV0gPSAgKGxpc3RbaV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBtYXBGdW5jID0gb3B0c1swXTtcbiAgICAgICAgY29uc3QgdGhpc0FyZyA9IG9wdHNbMV07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBhcnJheVtpXSA9IFJlZmxlY3RBcHBseShtYXBGdW5jLCB0aGlzQXJnLCBbbGlzdFtpXSwgaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuICAgIHN0YXRpYyBvZiguLi5pdGVtcykge1xuICAgICAgY29uc3QgQ29uc3RydWN0b3IgPSB0aGlzO1xuICAgICAgaWYgKCFSZWZsZWN0SGFzKENvbnN0cnVjdG9yLCBicmFuZCkpIHtcbiAgICAgICAgdGhyb3cgTmF0aXZlVHlwZUVycm9yKFxuICAgICAgICAgIFRISVNfQ09OU1RSVUNUT1JfSVNfTk9UX0FfU1VCQ0xBU1NfT0ZfRkxPQVQxNkFSUkFZXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBsZW5ndGggPSBpdGVtcy5sZW5ndGg7XG4gICAgICBpZiAoQ29uc3RydWN0b3IgPT09IEZsb2F0MTZBcnJheSkge1xuICAgICAgICBjb25zdCBwcm94eSA9IG5ldyBGbG9hdDE2QXJyYXkobGVuZ3RoKTtcbiAgICAgICAgY29uc3QgZmxvYXQxNmJpdHNBcnJheSA9IGdldEZsb2F0MTZCaXRzQXJyYXkocHJveHkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgZmxvYXQxNmJpdHNBcnJheVtpXSA9IHJvdW5kVG9GbG9hdDE2Qml0cyhpdGVtc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3h5O1xuICAgICAgfVxuICAgICAgY29uc3QgYXJyYXkgPSBuZXcgQ29uc3RydWN0b3IobGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYXJyYXlbaV0gPSBpdGVtc1tpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG4gICAga2V5cygpIHtcbiAgICAgIGFzc2VydEZsb2F0MTZBcnJheSh0aGlzKTtcbiAgICAgIGNvbnN0IGZsb2F0MTZiaXRzQXJyYXkgPSBnZXRGbG9hdDE2Qml0c0FycmF5KHRoaXMpO1xuICAgICAgcmV0dXJuIFR5cGVkQXJyYXlQcm90b3R5cGVLZXlzKGZsb2F0MTZiaXRzQXJyYXkpO1xuICAgIH1cbiAgICB2YWx1ZXMoKSB7XG4gICAgICBhc3NlcnRGbG9hdDE2QXJyYXkodGhpcyk7XG4gICAgICBjb25zdCBmbG9hdDE2Yml0c0FycmF5ID0gZ2V0RmxvYXQxNkJpdHNBcnJheSh0aGlzKTtcbiAgICAgIHJldHVybiB3cmFwKChmdW5jdGlvbiogKCkge1xuICAgICAgICBmb3IgKGNvbnN0IHZhbCBvZiBUeXBlZEFycmF5UHJvdG90eXBlVmFsdWVzKGZsb2F0MTZiaXRzQXJyYXkpKSB7XG4gICAgICAgICAgeWllbGQgY29udmVydFRvTnVtYmVyKHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0pKCkpO1xuICAgIH1cbiAgICBlbnRyaWVzKCkge1xuICAgICAgYXNzZXJ0RmxvYXQxNkFycmF5KHRoaXMpO1xuICAgICAgY29uc3QgZmxvYXQxNmJpdHNBcnJheSA9IGdldEZsb2F0MTZCaXRzQXJyYXkodGhpcyk7XG4gICAgICByZXR1cm4gd3JhcCgoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgZm9yIChjb25zdCBbaSwgdmFsXSBvZiBUeXBlZEFycmF5UHJvdG90eXBlRW50cmllcyhmbG9hdDE2Yml0c0FycmF5KSkge1xuICAgICAgICAgIHlpZWxkICAoW2ksIGNvbnZlcnRUb051bWJlcih2YWwpXSk7XG4gICAgICAgIH1cbiAgICAgIH0pKCkpO1xuICAgIH1cbiAgICBhdChpbmRleCkge1xuICAgICAgYXNzZXJ0RmxvYXQxNkFycmF5KHRoaXMpO1xuICAgICAgY29uc3QgZmxvYXQxNmJpdHNBcnJheSA9IGdldEZsb2F0MTZCaXRzQXJyYXkodGhpcyk7XG4gICAgICBjb25zdCBsZW5ndGggPSBUeXBlZEFycmF5UHJvdG90eXBlR2V0TGVuZ3RoKGZsb2F0MTZiaXRzQXJyYXkpO1xuICAgICAgY29uc3QgcmVsYXRpdmVJbmRleCA9IFRvSW50ZWdlck9ySW5maW5pdHkoaW5kZXgpO1xuICAgICAgY29uc3QgayA9IHJlbGF0aXZlSW5kZXggPj0gMCA/IHJlbGF0aXZlSW5kZXggOiBsZW5ndGggKyByZWxhdGl2ZUluZGV4O1xuICAgICAgaWYgKGsgPCAwIHx8IGsgPj0gbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb252ZXJ0VG9OdW1iZXIoZmxvYXQxNmJpdHNBcnJheVtrXSk7XG4gICAgfVxuICAgIHdpdGgoaW5kZXgsIHZhbHVlKSB7XG4gICAgICBhc3NlcnRGbG9hdDE2QXJyYXkodGhpcyk7XG4gICAgICBjb25zdCBmbG9hdDE2Yml0c0FycmF5ID0gZ2V0RmxvYXQxNkJpdHNBcnJheSh0aGlzKTtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IFR5cGVkQXJyYXlQcm90b3R5cGVHZXRMZW5ndGgoZmxvYXQxNmJpdHNBcnJheSk7XG4gICAgICBjb25zdCByZWxhdGl2ZUluZGV4ID0gVG9JbnRlZ2VyT3JJbmZpbml0eShpbmRleCk7XG4gICAgICBjb25zdCBrID0gcmVsYXRpdmVJbmRleCA+PSAwID8gcmVsYXRpdmVJbmRleCA6IGxlbmd0aCArIHJlbGF0aXZlSW5kZXg7XG4gICAgICBjb25zdCBudW1iZXIgPSArdmFsdWU7XG4gICAgICBpZiAoayA8IDAgfHwgayA+PSBsZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgTmF0aXZlUmFuZ2VFcnJvcihPRkZTRVRfSVNfT1VUX09GX0JPVU5EUyk7XG4gICAgICB9XG4gICAgICBjb25zdCB1aW50MTYgPSBuZXcgTmF0aXZlVWludDE2QXJyYXkoXG4gICAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGVHZXRCdWZmZXIoZmxvYXQxNmJpdHNBcnJheSksXG4gICAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGVHZXRCeXRlT2Zmc2V0KGZsb2F0MTZiaXRzQXJyYXkpLFxuICAgICAgICBUeXBlZEFycmF5UHJvdG90eXBlR2V0TGVuZ3RoKGZsb2F0MTZiaXRzQXJyYXkpXG4gICAgICApO1xuICAgICAgY29uc3QgY2xvbmVkID0gbmV3IEZsb2F0MTZBcnJheShcbiAgICAgICAgVHlwZWRBcnJheVByb3RvdHlwZUdldEJ1ZmZlcihcbiAgICAgICAgICBUeXBlZEFycmF5UHJvdG90eXBlU2xpY2UodWludDE2KVxuICAgICAgICApXG4gICAgICApO1xuICAgICAgY29uc3QgYXJyYXkgPSBnZXRGbG9hdDE2Qml0c0FycmF5KGNsb25lZCk7XG4gICAgICBhcnJheVtrXSA9IHJvdW5kVG9GbG9hdDE2Qml0cyhudW1iZXIpO1xuICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICB9XG4gICAgbWFwKGNhbGxiYWNrLCAuLi5vcHRzKSB7XG4gICAgICBhc3NlcnRGbG9hdDE2QXJyYXkodGhpcyk7XG4gICAgICBjb25zdCBmbG9hdDE2Yml0c0FycmF5ID0gZ2V0RmxvYXQxNkJpdHNBcnJheSh0aGlzKTtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IFR5cGVkQXJyYXlQcm90b3R5cGVHZXRMZW5ndGgoZmxvYXQxNmJpdHNBcnJheSk7XG4gICAgICBjb25zdCB0aGlzQXJnID0gb3B0c1swXTtcbiAgICAgIGNvbnN0IENvbnN0cnVjdG9yID0gU3BlY2llc0NvbnN0cnVjdG9yKGZsb2F0MTZiaXRzQXJyYXksIEZsb2F0MTZBcnJheSk7XG4gICAgICBpZiAoQ29uc3RydWN0b3IgPT09IEZsb2F0MTZBcnJheSkge1xuICAgICAgICBjb25zdCBwcm94eSA9IG5ldyBGbG9hdDE2QXJyYXkobGVuZ3RoKTtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBnZXRGbG9hdDE2Qml0c0FycmF5KHByb3h5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNvbnN0IHZhbCA9IGNvbnZlcnRUb051bWJlcihmbG9hdDE2Yml0c0FycmF5W2ldKTtcbiAgICAgICAgICBhcnJheVtpXSA9IHJvdW5kVG9GbG9hdDE2Qml0cyhcbiAgICAgICAgICAgIFJlZmxlY3RBcHBseShjYWxsYmFjaywgdGhpc0FyZywgW3ZhbCwgaSwgdGhpc10pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJveHk7XG4gICAgICB9XG4gICAgICBjb25zdCBhcnJheSA9IG5ldyBDb25zdHJ1Y3RvcihsZW5ndGgpO1xuICAgICAgYXNzZXJ0U3BlY2llc1R5cGVkQXJyYXkoYXJyYXksIGxlbmd0aCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IGNvbnZlcnRUb051bWJlcihmbG9hdDE2Yml0c0FycmF5W2ldKTtcbiAgICAgICAgYXJyYXlbaV0gPSBSZWZsZWN0QXBwbHkoY2FsbGJhY2ssIHRoaXNBcmcsIFt2YWwsIGksIHRoaXNdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAgKGFycmF5KTtcbiAgICB9XG4gICAgZmlsdGVyKGNhbGxiYWNrLCAuLi5vcHRzKSB7XG4gICAgICBhc3NlcnRGbG9hdDE2QXJyYXkodGhpcyk7XG4gICAgICBjb25zdCBmbG9hdDE2Yml0c0FycmF5ID0gZ2V0RmxvYXQxNkJpdHNBcnJheSh0aGlzKTtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IFR5cGVkQXJyYXlQcm90b3R5cGVHZXRMZW5ndGgoZmxvYXQxNmJpdHNBcnJheSk7XG4gICAgICBjb25zdCB0aGlzQXJnID0gb3B0c1swXTtcbiAgICAgIGNvbnN0IGtlcHQgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgdmFsID0gY29udmVydFRvTnVtYmVyKGZsb2F0MTZiaXRzQXJyYXlbaV0pO1xuICAgICAgICBpZiAoUmVmbGVjdEFwcGx5KGNhbGxiYWNrLCB0aGlzQXJnLCBbdmFsLCBpLCB0aGlzXSkpIHtcbiAgICAgICAgICBBcnJheVByb3RvdHlwZVB1c2goa2VwdCwgdmFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgQ29uc3RydWN0b3IgPSBTcGVjaWVzQ29uc3RydWN0b3IoZmxvYXQxNmJpdHNBcnJheSwgRmxvYXQxNkFycmF5KTtcbiAgICAgIGNvbnN0IGFycmF5ID0gbmV3IENvbnN0cnVjdG9yKGtlcHQpO1xuICAgICAgYXNzZXJ0U3BlY2llc1R5cGVkQXJyYXkoYXJyYXkpO1xuICAgICAgcmV0dXJuICAoYXJyYXkpO1xuICAgIH1cbiAgICByZWR1Y2UoY2FsbGJhY2ssIC4uLm9wdHMpIHtcbiAgICAgIGFzc2VydEZsb2F0MTZBcnJheSh0aGlzKTtcbiAgICAgIGNvbnN0IGZsb2F0MTZiaXRzQXJyYXkgPSBnZXRGbG9hdDE2Qml0c0FycmF5KHRoaXMpO1xuICAgICAgY29uc3QgbGVuZ3RoID0gVHlwZWRBcnJheVByb3RvdHlwZUdldExlbmd0aChmbG9hdDE2Yml0c0FycmF5KTtcbiAgICAgIGlmIChsZW5ndGggPT09IDAgJiYgb3B0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgTmF0aXZlVHlwZUVycm9yKFJFRFVDRV9PRl9FTVBUWV9BUlJBWV9XSVRIX05PX0lOSVRJQUxfVkFMVUUpO1xuICAgICAgfVxuICAgICAgbGV0IGFjY3VtdWxhdG9yLCBzdGFydDtcbiAgICAgIGlmIChvcHRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBhY2N1bXVsYXRvciA9IGNvbnZlcnRUb051bWJlcihmbG9hdDE2Yml0c0FycmF5WzBdKTtcbiAgICAgICAgc3RhcnQgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWNjdW11bGF0b3IgPSBvcHRzWzBdO1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICBhY2N1bXVsYXRvciA9IGNhbGxiYWNrKFxuICAgICAgICAgIGFjY3VtdWxhdG9yLFxuICAgICAgICAgIGNvbnZlcnRUb051bWJlcihmbG9hdDE2Yml0c0FycmF5W2ldKSxcbiAgICAgICAgICBpLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG4gICAgcmVkdWNlUmlnaHQoY2FsbGJhY2ssIC4uLm9wdHMpIHtcbiAgICAgIGFzc2VydEZsb2F0MTZBcnJheSh0aGlzKTtcbiAgICAgIGNvbnN0IGZsb2F0MTZiaXRzQXJyYXkgPSBnZXRGbG9hdDE2Qml0c0FycmF5KHRoaXMpO1xuICAgICAgY29uc3QgbGVuZ3RoID0gVHlwZWRBcnJheVByb3RvdHlwZUdldExlbmd0aChmbG9hdDE2Yml0c0FycmF5KTtcbiAgICAgIGlmIChsZW5ndGggPT09IDAgJiYgb3B0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgTmF0aXZlVHlwZUVycm9yKFJFRFVDRV9PRl9FTVBUWV9BUlJBWV9XSVRIX05PX0lOSVRJQUxfVkFMVUUpO1xuICAgICAgfVxuICAgICAgbGV0IGFjY3VtdWxhdG9yLCBzdGFydDtcbiAgICAgIGlmIChvcHRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBhY2N1bXVsYXRvciA9IGNvbnZlcnRUb051bWJlcihmbG9hdDE2Yml0c0FycmF5W2xlbmd0aCAtIDFdKTtcbiAgICAgICAgc3RhcnQgPSBsZW5ndGggLSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWNjdW11bGF0b3IgPSBvcHRzWzBdO1xuICAgICAgICBzdGFydCA9IGxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGFjY3VtdWxhdG9yID0gY2FsbGJhY2soXG4gICAgICAgICAgYWNjdW11bGF0b3IsXG4gICAgICAgICAgY29udmVydFRvTnVtYmVyKGZsb2F0MTZiaXRzQXJyYXlbaV0pLFxuICAgICAgICAgIGksXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cbiAgICBmb3JFYWNoKGNhbGxiYWNrLCAuLi5vcHRzKSB7XG4gICAgICBhc3NlcnRGbG9hdDE2QXJyYXkodGhpcyk7XG4gICAgICBjb25zdCBmbG9hdDE2Yml0c0FycmF5ID0gZ2V0RmxvYXQxNkJpdHNBcnJheSh0aGlzKTtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IFR5cGVkQXJyYXlQcm90b3R5cGVHZXRMZW5ndGgoZmxvYXQxNmJpdHNBcnJheSk7XG4gICAgICBjb25zdCB0aGlzQXJnID0gb3B0c1swXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgUmVmbGVjdEFwcGx5KGNhbGxiYWNrLCB0aGlzQXJnLCBbXG4gICAgICAgICAgY29udmVydFRvTnVtYmVyKGZsb2F0MTZiaXRzQXJyYXlbaV0pLFxuICAgICAgICAgIGksXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZpbmQoY2FsbGJhY2ssIC4uLm9wdHMpIHtcbiAgICAgIGFzc2VydEZsb2F0MTZBcnJheSh0aGlzKTtcbiAgICAgIGNvbnN0IGZsb2F0MTZiaXRzQXJyYXkgPSBnZXRGbG9hdDE2Qml0c0FycmF5KHRoaXMpO1xuICAgICAgY29uc3QgbGVuZ3RoID0gVHlwZWRBcnJheVByb3RvdHlwZUdldExlbmd0aChmbG9hdDE2Yml0c0FycmF5KTtcbiAgICAgIGNvbnN0IHRoaXNBcmcgPSBvcHRzWzBdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGNvbnZlcnRUb051bWJlcihmbG9hdDE2Yml0c0FycmF5W2ldKTtcbiAgICAgICAgaWYgKFJlZmxlY3RBcHBseShjYWxsYmFjaywgdGhpc0FyZywgW3ZhbHVlLCBpLCB0aGlzXSkpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZmluZEluZGV4KGNhbGxiYWNrLCAuLi5vcHRzKSB7XG4gICAgICBhc3NlcnRGbG9hdDE2QXJyYXkodGhpcyk7XG4gICAgICBjb25zdCBmbG9hdDE2Yml0c0FycmF5ID0gZ2V0RmxvYXQxNkJpdHNBcnJheSh0aGlzKTtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IFR5cGVkQXJyYXlQcm90b3R5cGVHZXRMZW5ndGgoZmxvYXQxNmJpdHNBcnJheSk7XG4gICAgICBjb25zdCB0aGlzQXJnID0gb3B0c1swXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBjb252ZXJ0VG9OdW1iZXIoZmxvYXQxNmJpdHNBcnJheVtpXSk7XG4gICAgICAgIGlmIChSZWZsZWN0QXBwbHkoY2FsbGJhY2ssIHRoaXNBcmcsIFt2YWx1ZSwgaSwgdGhpc10pKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgZmluZExhc3QoY2FsbGJhY2ssIC4uLm9wdHMpIHtcbiAgICAgIGFzc2VydEZsb2F0MTZBcnJheSh0aGlzKTtcbiAgICAgIGNvbnN0IGZsb2F0MTZiaXRzQXJyYXkgPSBnZXRGbG9hdDE2Qml0c0FycmF5KHRoaXMpO1xuICAgICAgY29uc3QgbGVuZ3RoID0gVHlwZWRBcnJheVByb3RvdHlwZUdldExlbmd0aChmbG9hdDE2Yml0c0FycmF5KTtcbiAgICAgIGNvbnN0IHRoaXNBcmcgPSBvcHRzWzBdO1xuICAgICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gY29udmVydFRvTnVtYmVyKGZsb2F0MTZiaXRzQXJyYXlbaV0pO1xuICAgICAgICBpZiAoUmVmbGVjdEFwcGx5KGNhbGxiYWNrLCB0aGlzQXJnLCBbdmFsdWUsIGksIHRoaXNdKSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmaW5kTGFzdEluZGV4KGNhbGxiYWNrLCAuLi5vcHRzKSB7XG4gICAgICBhc3NlcnRGbG9hdDE2QXJyYXkodGhpcyk7XG4gICAgICBjb25zdCBmbG9hdDE2Yml0c0FycmF5ID0gZ2V0RmxvYXQxNkJpdHNBcnJheSh0aGlzKTtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IFR5cGVkQXJyYXlQcm90b3R5cGVHZXRMZW5ndGgoZmxvYXQxNmJpdHNBcnJheSk7XG4gICAgICBjb25zdCB0aGlzQXJnID0gb3B0c1swXTtcbiAgICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGNvbnZlcnRUb051bWJlcihmbG9hdDE2Yml0c0FycmF5W2ldKTtcbiAgICAgICAgaWYgKFJlZmxlY3RBcHBseShjYWxsYmFjaywgdGhpc0FyZywgW3ZhbHVlLCBpLCB0aGlzXSkpIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBldmVyeShjYWxsYmFjaywgLi4ub3B0cykge1xuICAgICAgYXNzZXJ0RmxvYXQxNkFycmF5KHRoaXMpO1xuICAgICAgY29uc3QgZmxvYXQxNmJpdHNBcnJheSA9IGdldEZsb2F0MTZCaXRzQXJyYXkodGhpcyk7XG4gICAgICBjb25zdCBsZW5ndGggPSBUeXBlZEFycmF5UHJvdG90eXBlR2V0TGVuZ3RoKGZsb2F0MTZiaXRzQXJyYXkpO1xuICAgICAgY29uc3QgdGhpc0FyZyA9IG9wdHNbMF07XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhUmVmbGVjdEFwcGx5KGNhbGxiYWNrLCB0aGlzQXJnLCBbXG4gICAgICAgICAgICBjb252ZXJ0VG9OdW1iZXIoZmxvYXQxNmJpdHNBcnJheVtpXSksXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICBdKVxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzb21lKGNhbGxiYWNrLCAuLi5vcHRzKSB7XG4gICAgICBhc3NlcnRGbG9hdDE2QXJyYXkodGhpcyk7XG4gICAgICBjb25zdCBmbG9hdDE2Yml0c0FycmF5ID0gZ2V0RmxvYXQxNkJpdHNBcnJheSh0aGlzKTtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IFR5cGVkQXJyYXlQcm90b3R5cGVHZXRMZW5ndGgoZmxvYXQxNmJpdHNBcnJheSk7XG4gICAgICBjb25zdCB0aGlzQXJnID0gb3B0c1swXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIFJlZmxlY3RBcHBseShjYWxsYmFjaywgdGhpc0FyZywgW1xuICAgICAgICAgICAgY29udmVydFRvTnVtYmVyKGZsb2F0MTZiaXRzQXJyYXlbaV0pLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgXSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2V0KGlucHV0LCAuLi5vcHRzKSB7XG4gICAgICBhc3NlcnRGbG9hdDE2QXJyYXkodGhpcyk7XG4gICAgICBjb25zdCBmbG9hdDE2Yml0c0FycmF5ID0gZ2V0RmxvYXQxNkJpdHNBcnJheSh0aGlzKTtcbiAgICAgIGNvbnN0IHRhcmdldE9mZnNldCA9IFRvSW50ZWdlck9ySW5maW5pdHkob3B0c1swXSk7XG4gICAgICBpZiAodGFyZ2V0T2Zmc2V0IDwgMCkge1xuICAgICAgICB0aHJvdyBOYXRpdmVSYW5nZUVycm9yKE9GRlNFVF9JU19PVVRfT0ZfQk9VTkRTKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IE5hdGl2ZVR5cGVFcnJvcihcbiAgICAgICAgICBDQU5OT1RfQ09OVkVSVF9VTkRFRklORURfT1JfTlVMTF9UT19PQkpFQ1RcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc05hdGl2ZUJpZ0ludFR5cGVkQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIHRocm93IE5hdGl2ZVR5cGVFcnJvcihcbiAgICAgICAgICBDQU5OT1RfTUlYX0JJR0lOVF9BTkRfT1RIRVJfVFlQRVNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0Zsb2F0MTZBcnJheShpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIFR5cGVkQXJyYXlQcm90b3R5cGVTZXQoXG4gICAgICAgICAgZ2V0RmxvYXQxNkJpdHNBcnJheSh0aGlzKSxcbiAgICAgICAgICBnZXRGbG9hdDE2Qml0c0FycmF5KGlucHV0KSxcbiAgICAgICAgICB0YXJnZXRPZmZzZXRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc05hdGl2ZVR5cGVkQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IFR5cGVkQXJyYXlQcm90b3R5cGVHZXRCdWZmZXIoaW5wdXQpO1xuICAgICAgICBpZiAoSXNEZXRhY2hlZEJ1ZmZlcihidWZmZXIpKSB7XG4gICAgICAgICAgdGhyb3cgTmF0aXZlVHlwZUVycm9yKEFUVEVNUFRJTkdfVE9fQUNDRVNTX0RFVEFDSEVEX0FSUkFZQlVGRkVSKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgdGFyZ2V0TGVuZ3RoID0gVHlwZWRBcnJheVByb3RvdHlwZUdldExlbmd0aChmbG9hdDE2Yml0c0FycmF5KTtcbiAgICAgIGNvbnN0IHNyYyA9IE5hdGl2ZU9iamVjdChpbnB1dCk7XG4gICAgICBjb25zdCBzcmNMZW5ndGggPSBUb0xlbmd0aChzcmMubGVuZ3RoKTtcbiAgICAgIGlmICh0YXJnZXRPZmZzZXQgPT09IEluZmluaXR5IHx8IHNyY0xlbmd0aCArIHRhcmdldE9mZnNldCA+IHRhcmdldExlbmd0aCkge1xuICAgICAgICB0aHJvdyBOYXRpdmVSYW5nZUVycm9yKE9GRlNFVF9JU19PVVRfT0ZfQk9VTkRTKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3JjTGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZmxvYXQxNmJpdHNBcnJheVtpICsgdGFyZ2V0T2Zmc2V0XSA9IHJvdW5kVG9GbG9hdDE2Qml0cyhzcmNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXZlcnNlKCkge1xuICAgICAgYXNzZXJ0RmxvYXQxNkFycmF5KHRoaXMpO1xuICAgICAgY29uc3QgZmxvYXQxNmJpdHNBcnJheSA9IGdldEZsb2F0MTZCaXRzQXJyYXkodGhpcyk7XG4gICAgICBUeXBlZEFycmF5UHJvdG90eXBlUmV2ZXJzZShmbG9hdDE2Yml0c0FycmF5KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0b1JldmVyc2VkKCkge1xuICAgICAgYXNzZXJ0RmxvYXQxNkFycmF5KHRoaXMpO1xuICAgICAgY29uc3QgZmxvYXQxNmJpdHNBcnJheSA9IGdldEZsb2F0MTZCaXRzQXJyYXkodGhpcyk7XG4gICAgICBjb25zdCB1aW50MTYgPSBuZXcgTmF0aXZlVWludDE2QXJyYXkoXG4gICAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGVHZXRCdWZmZXIoZmxvYXQxNmJpdHNBcnJheSksXG4gICAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGVHZXRCeXRlT2Zmc2V0KGZsb2F0MTZiaXRzQXJyYXkpLFxuICAgICAgICBUeXBlZEFycmF5UHJvdG90eXBlR2V0TGVuZ3RoKGZsb2F0MTZiaXRzQXJyYXkpXG4gICAgICApO1xuICAgICAgY29uc3QgY2xvbmVkID0gbmV3IEZsb2F0MTZBcnJheShcbiAgICAgICAgVHlwZWRBcnJheVByb3RvdHlwZUdldEJ1ZmZlcihcbiAgICAgICAgICBUeXBlZEFycmF5UHJvdG90eXBlU2xpY2UodWludDE2KVxuICAgICAgICApXG4gICAgICApO1xuICAgICAgY29uc3QgY2xvbmVkRmxvYXQxNmJpdHNBcnJheSA9IGdldEZsb2F0MTZCaXRzQXJyYXkoY2xvbmVkKTtcbiAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGVSZXZlcnNlKGNsb25lZEZsb2F0MTZiaXRzQXJyYXkpO1xuICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICB9XG4gICAgZmlsbCh2YWx1ZSwgLi4ub3B0cykge1xuICAgICAgYXNzZXJ0RmxvYXQxNkFycmF5KHRoaXMpO1xuICAgICAgY29uc3QgZmxvYXQxNmJpdHNBcnJheSA9IGdldEZsb2F0MTZCaXRzQXJyYXkodGhpcyk7XG4gICAgICBUeXBlZEFycmF5UHJvdG90eXBlRmlsbChcbiAgICAgICAgZmxvYXQxNmJpdHNBcnJheSxcbiAgICAgICAgcm91bmRUb0Zsb2F0MTZCaXRzKHZhbHVlKSxcbiAgICAgICAgLi4uc2FmZUlmTmVlZGVkKG9wdHMpXG4gICAgICApO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCwgLi4ub3B0cykge1xuICAgICAgYXNzZXJ0RmxvYXQxNkFycmF5KHRoaXMpO1xuICAgICAgY29uc3QgZmxvYXQxNmJpdHNBcnJheSA9IGdldEZsb2F0MTZCaXRzQXJyYXkodGhpcyk7XG4gICAgICBUeXBlZEFycmF5UHJvdG90eXBlQ29weVdpdGhpbihmbG9hdDE2Yml0c0FycmF5LCB0YXJnZXQsIHN0YXJ0LCAuLi5zYWZlSWZOZWVkZWQob3B0cykpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNvcnQoY29tcGFyZUZuKSB7XG4gICAgICBhc3NlcnRGbG9hdDE2QXJyYXkodGhpcyk7XG4gICAgICBjb25zdCBmbG9hdDE2Yml0c0FycmF5ID0gZ2V0RmxvYXQxNkJpdHNBcnJheSh0aGlzKTtcbiAgICAgIGNvbnN0IHNvcnRDb21wYXJlID0gY29tcGFyZUZuICE9PSB1bmRlZmluZWQgPyBjb21wYXJlRm4gOiBkZWZhdWx0Q29tcGFyZTtcbiAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGVTb3J0KGZsb2F0MTZiaXRzQXJyYXksICh4LCB5KSA9PiB7XG4gICAgICAgIHJldHVybiBzb3J0Q29tcGFyZShjb252ZXJ0VG9OdW1iZXIoeCksIGNvbnZlcnRUb051bWJlcih5KSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0b1NvcnRlZChjb21wYXJlRm4pIHtcbiAgICAgIGFzc2VydEZsb2F0MTZBcnJheSh0aGlzKTtcbiAgICAgIGNvbnN0IGZsb2F0MTZiaXRzQXJyYXkgPSBnZXRGbG9hdDE2Qml0c0FycmF5KHRoaXMpO1xuICAgICAgaWYgKGNvbXBhcmVGbiAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBjb21wYXJlRm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgTmF0aXZlVHlwZUVycm9yKFRIRV9DT01QQVJJU09OX0ZVTkNUSU9OX01VU1RfQkVfRUlUSEVSX0FfRlVOQ1RJT05fT1JfVU5ERUZJTkVEKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNvcnRDb21wYXJlID0gY29tcGFyZUZuICE9PSB1bmRlZmluZWQgPyBjb21wYXJlRm4gOiBkZWZhdWx0Q29tcGFyZTtcbiAgICAgIGNvbnN0IHVpbnQxNiA9IG5ldyBOYXRpdmVVaW50MTZBcnJheShcbiAgICAgICAgVHlwZWRBcnJheVByb3RvdHlwZUdldEJ1ZmZlcihmbG9hdDE2Yml0c0FycmF5KSxcbiAgICAgICAgVHlwZWRBcnJheVByb3RvdHlwZUdldEJ5dGVPZmZzZXQoZmxvYXQxNmJpdHNBcnJheSksXG4gICAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGVHZXRMZW5ndGgoZmxvYXQxNmJpdHNBcnJheSlcbiAgICAgICk7XG4gICAgICBjb25zdCBjbG9uZWQgPSBuZXcgRmxvYXQxNkFycmF5KFxuICAgICAgICBUeXBlZEFycmF5UHJvdG90eXBlR2V0QnVmZmVyKFxuICAgICAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGVTbGljZSh1aW50MTYpXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBjb25zdCBjbG9uZWRGbG9hdDE2Yml0c0FycmF5ID0gZ2V0RmxvYXQxNkJpdHNBcnJheShjbG9uZWQpO1xuICAgICAgVHlwZWRBcnJheVByb3RvdHlwZVNvcnQoY2xvbmVkRmxvYXQxNmJpdHNBcnJheSwgKHgsIHkpID0+IHtcbiAgICAgICAgcmV0dXJuIHNvcnRDb21wYXJlKGNvbnZlcnRUb051bWJlcih4KSwgY29udmVydFRvTnVtYmVyKHkpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICB9XG4gICAgc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgICAgYXNzZXJ0RmxvYXQxNkFycmF5KHRoaXMpO1xuICAgICAgY29uc3QgZmxvYXQxNmJpdHNBcnJheSA9IGdldEZsb2F0MTZCaXRzQXJyYXkodGhpcyk7XG4gICAgICBjb25zdCBDb25zdHJ1Y3RvciA9IFNwZWNpZXNDb25zdHJ1Y3RvcihmbG9hdDE2Yml0c0FycmF5LCBGbG9hdDE2QXJyYXkpO1xuICAgICAgaWYgKENvbnN0cnVjdG9yID09PSBGbG9hdDE2QXJyYXkpIHtcbiAgICAgICAgY29uc3QgdWludDE2ID0gbmV3IE5hdGl2ZVVpbnQxNkFycmF5KFxuICAgICAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGVHZXRCdWZmZXIoZmxvYXQxNmJpdHNBcnJheSksXG4gICAgICAgICAgVHlwZWRBcnJheVByb3RvdHlwZUdldEJ5dGVPZmZzZXQoZmxvYXQxNmJpdHNBcnJheSksXG4gICAgICAgICAgVHlwZWRBcnJheVByb3RvdHlwZUdldExlbmd0aChmbG9hdDE2Yml0c0FycmF5KVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbmV3IEZsb2F0MTZBcnJheShcbiAgICAgICAgICBUeXBlZEFycmF5UHJvdG90eXBlR2V0QnVmZmVyKFxuICAgICAgICAgICAgVHlwZWRBcnJheVByb3RvdHlwZVNsaWNlKHVpbnQxNiwgc3RhcnQsIGVuZClcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBsZW5ndGggPSBUeXBlZEFycmF5UHJvdG90eXBlR2V0TGVuZ3RoKGZsb2F0MTZiaXRzQXJyYXkpO1xuICAgICAgY29uc3QgcmVsYXRpdmVTdGFydCA9IFRvSW50ZWdlck9ySW5maW5pdHkoc3RhcnQpO1xuICAgICAgY29uc3QgcmVsYXRpdmVFbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IFRvSW50ZWdlck9ySW5maW5pdHkoZW5kKTtcbiAgICAgIGxldCBrO1xuICAgICAgaWYgKHJlbGF0aXZlU3RhcnQgPT09IC1JbmZpbml0eSkge1xuICAgICAgICBrID0gMDtcbiAgICAgIH0gZWxzZSBpZiAocmVsYXRpdmVTdGFydCA8IDApIHtcbiAgICAgICAgayA9IGxlbmd0aCArIHJlbGF0aXZlU3RhcnQgPiAwID8gbGVuZ3RoICsgcmVsYXRpdmVTdGFydCA6IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrID0gbGVuZ3RoIDwgcmVsYXRpdmVTdGFydCA/IGxlbmd0aCA6IHJlbGF0aXZlU3RhcnQ7XG4gICAgICB9XG4gICAgICBsZXQgZmluYWw7XG4gICAgICBpZiAocmVsYXRpdmVFbmQgPT09IC1JbmZpbml0eSkge1xuICAgICAgICBmaW5hbCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHJlbGF0aXZlRW5kIDwgMCkge1xuICAgICAgICBmaW5hbCA9IGxlbmd0aCArIHJlbGF0aXZlRW5kID4gMCA/IGxlbmd0aCArIHJlbGF0aXZlRW5kIDogMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbmFsID0gbGVuZ3RoIDwgcmVsYXRpdmVFbmQgPyBsZW5ndGggOiByZWxhdGl2ZUVuZDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvdW50ID0gZmluYWwgLSBrID4gMCA/IGZpbmFsIC0gayA6IDA7XG4gICAgICBjb25zdCBhcnJheSA9IG5ldyBDb25zdHJ1Y3Rvcihjb3VudCk7XG4gICAgICBhc3NlcnRTcGVjaWVzVHlwZWRBcnJheShhcnJheSwgY291bnQpO1xuICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJ1ZmZlciA9IFR5cGVkQXJyYXlQcm90b3R5cGVHZXRCdWZmZXIoZmxvYXQxNmJpdHNBcnJheSk7XG4gICAgICBpZiAoSXNEZXRhY2hlZEJ1ZmZlcihidWZmZXIpKSB7XG4gICAgICAgIHRocm93IE5hdGl2ZVR5cGVFcnJvcihBVFRFTVBUSU5HX1RPX0FDQ0VTU19ERVRBQ0hFRF9BUlJBWUJVRkZFUik7XG4gICAgICB9XG4gICAgICBsZXQgbiA9IDA7XG4gICAgICB3aGlsZSAoayA8IGZpbmFsKSB7XG4gICAgICAgIGFycmF5W25dID0gY29udmVydFRvTnVtYmVyKGZsb2F0MTZiaXRzQXJyYXlba10pO1xuICAgICAgICArK2s7XG4gICAgICAgICsrbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiAgKGFycmF5KTtcbiAgICB9XG4gICAgc3ViYXJyYXkoYmVnaW4sIGVuZCkge1xuICAgICAgYXNzZXJ0RmxvYXQxNkFycmF5KHRoaXMpO1xuICAgICAgY29uc3QgZmxvYXQxNmJpdHNBcnJheSA9IGdldEZsb2F0MTZCaXRzQXJyYXkodGhpcyk7XG4gICAgICBjb25zdCBDb25zdHJ1Y3RvciA9IFNwZWNpZXNDb25zdHJ1Y3RvcihmbG9hdDE2Yml0c0FycmF5LCBGbG9hdDE2QXJyYXkpO1xuICAgICAgY29uc3QgdWludDE2ID0gbmV3IE5hdGl2ZVVpbnQxNkFycmF5KFxuICAgICAgICBUeXBlZEFycmF5UHJvdG90eXBlR2V0QnVmZmVyKGZsb2F0MTZiaXRzQXJyYXkpLFxuICAgICAgICBUeXBlZEFycmF5UHJvdG90eXBlR2V0Qnl0ZU9mZnNldChmbG9hdDE2Yml0c0FycmF5KSxcbiAgICAgICAgVHlwZWRBcnJheVByb3RvdHlwZUdldExlbmd0aChmbG9hdDE2Yml0c0FycmF5KVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHVpbnQxNlN1YmFycmF5ID0gVHlwZWRBcnJheVByb3RvdHlwZVN1YmFycmF5KHVpbnQxNiwgYmVnaW4sIGVuZCk7XG4gICAgICBjb25zdCBhcnJheSA9IG5ldyBDb25zdHJ1Y3RvcihcbiAgICAgICAgVHlwZWRBcnJheVByb3RvdHlwZUdldEJ1ZmZlcih1aW50MTZTdWJhcnJheSksXG4gICAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGVHZXRCeXRlT2Zmc2V0KHVpbnQxNlN1YmFycmF5KSxcbiAgICAgICAgVHlwZWRBcnJheVByb3RvdHlwZUdldExlbmd0aCh1aW50MTZTdWJhcnJheSlcbiAgICAgICk7XG4gICAgICBhc3NlcnRTcGVjaWVzVHlwZWRBcnJheShhcnJheSk7XG4gICAgICByZXR1cm4gIChhcnJheSk7XG4gICAgfVxuICAgIGluZGV4T2YoZWxlbWVudCwgLi4ub3B0cykge1xuICAgICAgYXNzZXJ0RmxvYXQxNkFycmF5KHRoaXMpO1xuICAgICAgY29uc3QgZmxvYXQxNmJpdHNBcnJheSA9IGdldEZsb2F0MTZCaXRzQXJyYXkodGhpcyk7XG4gICAgICBjb25zdCBsZW5ndGggPSBUeXBlZEFycmF5UHJvdG90eXBlR2V0TGVuZ3RoKGZsb2F0MTZiaXRzQXJyYXkpO1xuICAgICAgbGV0IGZyb20gPSBUb0ludGVnZXJPckluZmluaXR5KG9wdHNbMF0pO1xuICAgICAgaWYgKGZyb20gPT09IEluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChmcm9tIDwgMCkge1xuICAgICAgICBmcm9tICs9IGxlbmd0aDtcbiAgICAgICAgaWYgKGZyb20gPCAwKSB7XG4gICAgICAgICAgZnJvbSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIE9iamVjdEhhc093bihmbG9hdDE2Yml0c0FycmF5LCBpKSAmJlxuICAgICAgICAgIGNvbnZlcnRUb051bWJlcihmbG9hdDE2Yml0c0FycmF5W2ldKSA9PT0gZWxlbWVudFxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBsYXN0SW5kZXhPZihlbGVtZW50LCAuLi5vcHRzKSB7XG4gICAgICBhc3NlcnRGbG9hdDE2QXJyYXkodGhpcyk7XG4gICAgICBjb25zdCBmbG9hdDE2Yml0c0FycmF5ID0gZ2V0RmxvYXQxNkJpdHNBcnJheSh0aGlzKTtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IFR5cGVkQXJyYXlQcm90b3R5cGVHZXRMZW5ndGgoZmxvYXQxNmJpdHNBcnJheSk7XG4gICAgICBsZXQgZnJvbSA9IG9wdHMubGVuZ3RoID49IDEgPyBUb0ludGVnZXJPckluZmluaXR5KG9wdHNbMF0pIDogbGVuZ3RoIC0gMTtcbiAgICAgIGlmIChmcm9tID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgaWYgKGZyb20gPj0gMCkge1xuICAgICAgICBmcm9tID0gZnJvbSA8IGxlbmd0aCAtIDEgPyBmcm9tIDogbGVuZ3RoIC0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyb20gKz0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBPYmplY3RIYXNPd24oZmxvYXQxNmJpdHNBcnJheSwgaSkgJiZcbiAgICAgICAgICBjb252ZXJ0VG9OdW1iZXIoZmxvYXQxNmJpdHNBcnJheVtpXSkgPT09IGVsZW1lbnRcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaW5jbHVkZXMoZWxlbWVudCwgLi4ub3B0cykge1xuICAgICAgYXNzZXJ0RmxvYXQxNkFycmF5KHRoaXMpO1xuICAgICAgY29uc3QgZmxvYXQxNmJpdHNBcnJheSA9IGdldEZsb2F0MTZCaXRzQXJyYXkodGhpcyk7XG4gICAgICBjb25zdCBsZW5ndGggPSBUeXBlZEFycmF5UHJvdG90eXBlR2V0TGVuZ3RoKGZsb2F0MTZiaXRzQXJyYXkpO1xuICAgICAgbGV0IGZyb20gPSBUb0ludGVnZXJPckluZmluaXR5KG9wdHNbMF0pO1xuICAgICAgaWYgKGZyb20gPT09IEluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChmcm9tIDwgMCkge1xuICAgICAgICBmcm9tICs9IGxlbmd0aDtcbiAgICAgICAgaWYgKGZyb20gPCAwKSB7XG4gICAgICAgICAgZnJvbSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzTmFOID0gTnVtYmVySXNOYU4oZWxlbWVudCk7XG4gICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gY29udmVydFRvTnVtYmVyKGZsb2F0MTZiaXRzQXJyYXlbaV0pO1xuICAgICAgICBpZiAoaXNOYU4gJiYgTnVtYmVySXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09PSBlbGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgam9pbihzZXBhcmF0b3IpIHtcbiAgICAgIGFzc2VydEZsb2F0MTZBcnJheSh0aGlzKTtcbiAgICAgIGNvbnN0IGZsb2F0MTZiaXRzQXJyYXkgPSBnZXRGbG9hdDE2Qml0c0FycmF5KHRoaXMpO1xuICAgICAgY29uc3QgYXJyYXkgPSBjb3B5VG9BcnJheShmbG9hdDE2Yml0c0FycmF5KTtcbiAgICAgIHJldHVybiBBcnJheVByb3RvdHlwZUpvaW4oYXJyYXksIHNlcGFyYXRvcik7XG4gICAgfVxuICAgIHRvTG9jYWxlU3RyaW5nKC4uLm9wdHMpIHtcbiAgICAgIGFzc2VydEZsb2F0MTZBcnJheSh0aGlzKTtcbiAgICAgIGNvbnN0IGZsb2F0MTZiaXRzQXJyYXkgPSBnZXRGbG9hdDE2Qml0c0FycmF5KHRoaXMpO1xuICAgICAgY29uc3QgYXJyYXkgPSBjb3B5VG9BcnJheShmbG9hdDE2Yml0c0FycmF5KTtcbiAgICAgIHJldHVybiBBcnJheVByb3RvdHlwZVRvTG9jYWxlU3RyaW5nKGFycmF5LCAuLi5zYWZlSWZOZWVkZWQob3B0cykpO1xuICAgIH1cbiAgICBnZXQgW1N5bWJvbFRvU3RyaW5nVGFnXSgpIHtcbiAgICAgIGlmIChpc0Zsb2F0MTZBcnJheSh0aGlzKSkge1xuICAgICAgICByZXR1cm4gIChcIkZsb2F0MTZBcnJheVwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgT2JqZWN0RGVmaW5lUHJvcGVydHkoRmxvYXQxNkFycmF5LCBcIkJZVEVTX1BFUl9FTEVNRU5UXCIsIHtcbiAgICB2YWx1ZTogQllURVNfUEVSX0VMRU1FTlQsXG4gIH0pO1xuICBPYmplY3REZWZpbmVQcm9wZXJ0eShGbG9hdDE2QXJyYXksIGJyYW5kLCB7fSk7XG4gIFJlZmxlY3RTZXRQcm90b3R5cGVPZihGbG9hdDE2QXJyYXksIFR5cGVkQXJyYXkpO1xuICBjb25zdCBGbG9hdDE2QXJyYXlQcm90b3R5cGUgPSBGbG9hdDE2QXJyYXkucHJvdG90eXBlO1xuICBPYmplY3REZWZpbmVQcm9wZXJ0eShGbG9hdDE2QXJyYXlQcm90b3R5cGUsIFwiQllURVNfUEVSX0VMRU1FTlRcIiwge1xuICAgIHZhbHVlOiBCWVRFU19QRVJfRUxFTUVOVCxcbiAgfSk7XG4gIE9iamVjdERlZmluZVByb3BlcnR5KEZsb2F0MTZBcnJheVByb3RvdHlwZSwgU3ltYm9sSXRlcmF0b3IsIHtcbiAgICB2YWx1ZTogRmxvYXQxNkFycmF5UHJvdG90eXBlLnZhbHVlcyxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gIH0pO1xuICBSZWZsZWN0U2V0UHJvdG90eXBlT2YoRmxvYXQxNkFycmF5UHJvdG90eXBlLCBUeXBlZEFycmF5UHJvdG90eXBlKTtcblxuICBmdW5jdGlvbiBpc1R5cGVkQXJyYXkodGFyZ2V0KSB7XG4gICAgcmV0dXJuIGlzTmF0aXZlVHlwZWRBcnJheSh0YXJnZXQpIHx8IGlzRmxvYXQxNkFycmF5KHRhcmdldCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRGbG9hdDE2KGRhdGFWaWV3LCBieXRlT2Zmc2V0LCAuLi5vcHRzKSB7XG4gICAgcmV0dXJuIGNvbnZlcnRUb051bWJlcihcbiAgICAgIERhdGFWaWV3UHJvdG90eXBlR2V0VWludDE2KGRhdGFWaWV3LCBieXRlT2Zmc2V0LCAuLi5zYWZlSWZOZWVkZWQob3B0cykpXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBzZXRGbG9hdDE2KGRhdGFWaWV3LCBieXRlT2Zmc2V0LCB2YWx1ZSwgLi4ub3B0cykge1xuICAgIHJldHVybiBEYXRhVmlld1Byb3RvdHlwZVNldFVpbnQxNihcbiAgICAgIGRhdGFWaWV3LFxuICAgICAgYnl0ZU9mZnNldCxcbiAgICAgIHJvdW5kVG9GbG9hdDE2Qml0cyh2YWx1ZSksXG4gICAgICAuLi5zYWZlSWZOZWVkZWQob3B0cylcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gZjE2cm91bmQoeCkge1xuICAgIHJldHVybiByb3VuZFRvRmxvYXQxNih4KTtcbiAgfVxuXG4gIGV4cG9ydHMuRmxvYXQxNkFycmF5ID0gRmxvYXQxNkFycmF5O1xuICBleHBvcnRzLmYxNnJvdW5kID0gZjE2cm91bmQ7XG4gIGV4cG9ydHMuZ2V0RmxvYXQxNiA9IGdldEZsb2F0MTY7XG4gIGV4cG9ydHMuaGZyb3VuZCA9IGYxNnJvdW5kO1xuICBleHBvcnRzLmlzRmxvYXQxNkFycmF5ID0gaXNGbG9hdDE2QXJyYXk7XG4gIGV4cG9ydHMuaXNUeXBlZEFycmF5ID0gaXNUeXBlZEFycmF5O1xuICBleHBvcnRzLnNldEZsb2F0MTYgPSBzZXRGbG9hdDE2O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KSh7fSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@petamoriken/float16/browser/float16.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/compression/basedecoder.js":
/*!*********************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/compression/basedecoder.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return BaseDecoder; });\n/* harmony import */ var _predictor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../predictor.js */ \"./node_modules/geotiff/dist-module/predictor.js\");\n\n\nclass BaseDecoder {\n  async decode(fileDirectory, buffer) {\n    const decoded = await this.decodeBlock(buffer);\n    const predictor = fileDirectory.Predictor || 1;\n    if (predictor !== 1) {\n      const isTiled = !fileDirectory.StripOffsets;\n      const tileWidth = isTiled ? fileDirectory.TileWidth : fileDirectory.ImageWidth;\n      const tileHeight = isTiled ? fileDirectory.TileLength : (\n        fileDirectory.RowsPerStrip || fileDirectory.ImageLength\n      );\n      return Object(_predictor_js__WEBPACK_IMPORTED_MODULE_0__[\"applyPredictor\"])(\n        decoded, predictor, tileWidth, tileHeight, fileDirectory.BitsPerSample,\n        fileDirectory.PlanarConfiguration,\n      );\n    }\n    return decoded;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9jb21wcmVzc2lvbi9iYXNlZGVjb2Rlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL2NvbXByZXNzaW9uL2Jhc2VkZWNvZGVyLmpzP2IzZjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXBwbHlQcmVkaWN0b3IgfSBmcm9tICcuLi9wcmVkaWN0b3IuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlRGVjb2RlciB7XG4gIGFzeW5jIGRlY29kZShmaWxlRGlyZWN0b3J5LCBidWZmZXIpIHtcbiAgICBjb25zdCBkZWNvZGVkID0gYXdhaXQgdGhpcy5kZWNvZGVCbG9jayhidWZmZXIpO1xuICAgIGNvbnN0IHByZWRpY3RvciA9IGZpbGVEaXJlY3RvcnkuUHJlZGljdG9yIHx8IDE7XG4gICAgaWYgKHByZWRpY3RvciAhPT0gMSkge1xuICAgICAgY29uc3QgaXNUaWxlZCA9ICFmaWxlRGlyZWN0b3J5LlN0cmlwT2Zmc2V0cztcbiAgICAgIGNvbnN0IHRpbGVXaWR0aCA9IGlzVGlsZWQgPyBmaWxlRGlyZWN0b3J5LlRpbGVXaWR0aCA6IGZpbGVEaXJlY3RvcnkuSW1hZ2VXaWR0aDtcbiAgICAgIGNvbnN0IHRpbGVIZWlnaHQgPSBpc1RpbGVkID8gZmlsZURpcmVjdG9yeS5UaWxlTGVuZ3RoIDogKFxuICAgICAgICBmaWxlRGlyZWN0b3J5LlJvd3NQZXJTdHJpcCB8fCBmaWxlRGlyZWN0b3J5LkltYWdlTGVuZ3RoXG4gICAgICApO1xuICAgICAgcmV0dXJuIGFwcGx5UHJlZGljdG9yKFxuICAgICAgICBkZWNvZGVkLCBwcmVkaWN0b3IsIHRpbGVXaWR0aCwgdGlsZUhlaWdodCwgZmlsZURpcmVjdG9yeS5CaXRzUGVyU2FtcGxlLFxuICAgICAgICBmaWxlRGlyZWN0b3J5LlBsYW5hckNvbmZpZ3VyYXRpb24sXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZGVjb2RlZDtcbiAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/compression/basedecoder.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/compression/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/compression/index.js ***!
  \***************************************************************/
/*! exports provided: addDecoder, getDecoder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addDecoder\", function() { return addDecoder; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getDecoder\", function() { return getDecoder; });\nconst registry = new Map();\n\nfunction addDecoder(cases, importFn) {\n  if (!Array.isArray(cases)) {\n    cases = [cases]; // eslint-disable-line no-param-reassign\n  }\n  cases.forEach((c) => registry.set(c, importFn));\n}\n\nasync function getDecoder(fileDirectory) {\n  const importFn = registry.get(fileDirectory.Compression);\n  if (!importFn) {\n    throw new Error(`Unknown compression method identifier: ${fileDirectory.Compression}`);\n  }\n  const Decoder = await importFn();\n  return new Decoder(fileDirectory);\n}\n\n// Add default decoders to registry (end-user may override with other implementations)\naddDecoder([undefined, 1], () => __webpack_require__.e(/*! import() */ 19).then(__webpack_require__.bind(null, /*! ./raw.js */ \"./node_modules/geotiff/dist-module/compression/raw.js\")).then((m) => m.default));\naddDecoder(5, () => __webpack_require__.e(/*! import() */ 17).then(__webpack_require__.bind(null, /*! ./lzw.js */ \"./node_modules/geotiff/dist-module/compression/lzw.js\")).then((m) => m.default));\naddDecoder(6, () => {\n  throw new Error('old style JPEG compression is not supported.');\n});\naddDecoder(7, () => __webpack_require__.e(/*! import() */ 16).then(__webpack_require__.bind(null, /*! ./jpeg.js */ \"./node_modules/geotiff/dist-module/compression/jpeg.js\")).then((m) => m.default));\naddDecoder([8, 32946], () => Promise.all(/*! import() */[__webpack_require__.e(1), __webpack_require__.e(15)]).then(__webpack_require__.bind(null, /*! ./deflate.js */ \"./node_modules/geotiff/dist-module/compression/deflate.js\")).then((m) => m.default));\naddDecoder(32773, () => __webpack_require__.e(/*! import() */ 18).then(__webpack_require__.bind(null, /*! ./packbits.js */ \"./node_modules/geotiff/dist-module/compression/packbits.js\")).then((m) => m.default));\naddDecoder(34887, () => Promise.all(/*! import() */[__webpack_require__.e(1), __webpack_require__.e(12)]).then(__webpack_require__.bind(null, /*! ./lerc.js */ \"./node_modules/geotiff/dist-module/compression/lerc.js\"))\n  .then(async (m) => {\n    await m.zstd.init();\n    return m;\n  })\n  .then((m) => m.default),\n);\naddDecoder(50001, () => __webpack_require__.e(/*! import() */ 20).then(__webpack_require__.bind(null, /*! ./webimage.js */ \"./node_modules/geotiff/dist-module/compression/webimage.js\")).then((m) => m.default));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9jb21wcmVzc2lvbi9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL2NvbXByZXNzaW9uL2luZGV4LmpzPzUzM2MiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcmVnaXN0cnkgPSBuZXcgTWFwKCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGREZWNvZGVyKGNhc2VzLCBpbXBvcnRGbikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoY2FzZXMpKSB7XG4gICAgY2FzZXMgPSBbY2FzZXNdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIH1cbiAgY2FzZXMuZm9yRWFjaCgoYykgPT4gcmVnaXN0cnkuc2V0KGMsIGltcG9ydEZuKSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXREZWNvZGVyKGZpbGVEaXJlY3RvcnkpIHtcbiAgY29uc3QgaW1wb3J0Rm4gPSByZWdpc3RyeS5nZXQoZmlsZURpcmVjdG9yeS5Db21wcmVzc2lvbik7XG4gIGlmICghaW1wb3J0Rm4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gY29tcHJlc3Npb24gbWV0aG9kIGlkZW50aWZpZXI6ICR7ZmlsZURpcmVjdG9yeS5Db21wcmVzc2lvbn1gKTtcbiAgfVxuICBjb25zdCBEZWNvZGVyID0gYXdhaXQgaW1wb3J0Rm4oKTtcbiAgcmV0dXJuIG5ldyBEZWNvZGVyKGZpbGVEaXJlY3RvcnkpO1xufVxuXG4vLyBBZGQgZGVmYXVsdCBkZWNvZGVycyB0byByZWdpc3RyeSAoZW5kLXVzZXIgbWF5IG92ZXJyaWRlIHdpdGggb3RoZXIgaW1wbGVtZW50YXRpb25zKVxuYWRkRGVjb2RlcihbdW5kZWZpbmVkLCAxXSwgKCkgPT4gaW1wb3J0KCcuL3Jhdy5qcycpLnRoZW4oKG0pID0+IG0uZGVmYXVsdCkpO1xuYWRkRGVjb2Rlcig1LCAoKSA9PiBpbXBvcnQoJy4vbHp3LmpzJykudGhlbigobSkgPT4gbS5kZWZhdWx0KSk7XG5hZGREZWNvZGVyKDYsICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKCdvbGQgc3R5bGUgSlBFRyBjb21wcmVzc2lvbiBpcyBub3Qgc3VwcG9ydGVkLicpO1xufSk7XG5hZGREZWNvZGVyKDcsICgpID0+IGltcG9ydCgnLi9qcGVnLmpzJykudGhlbigobSkgPT4gbS5kZWZhdWx0KSk7XG5hZGREZWNvZGVyKFs4LCAzMjk0Nl0sICgpID0+IGltcG9ydCgnLi9kZWZsYXRlLmpzJykudGhlbigobSkgPT4gbS5kZWZhdWx0KSk7XG5hZGREZWNvZGVyKDMyNzczLCAoKSA9PiBpbXBvcnQoJy4vcGFja2JpdHMuanMnKS50aGVuKChtKSA9PiBtLmRlZmF1bHQpKTtcbmFkZERlY29kZXIoMzQ4ODcsICgpID0+IGltcG9ydCgnLi9sZXJjLmpzJylcbiAgLnRoZW4oYXN5bmMgKG0pID0+IHtcbiAgICBhd2FpdCBtLnpzdGQuaW5pdCgpO1xuICAgIHJldHVybiBtO1xuICB9KVxuICAudGhlbigobSkgPT4gbS5kZWZhdWx0KSxcbik7XG5hZGREZWNvZGVyKDUwMDAxLCAoKSA9PiBpbXBvcnQoJy4vd2ViaW1hZ2UuanMnKS50aGVuKChtKSA9PiBtLmRlZmF1bHQpKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/compression/index.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/dataslice.js":
/*!*******************************************************!*\
  !*** ./node_modules/geotiff/dist-module/dataslice.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return DataSlice; });\nclass DataSlice {\n  constructor(arrayBuffer, sliceOffset, littleEndian, bigTiff) {\n    this._dataView = new DataView(arrayBuffer);\n    this._sliceOffset = sliceOffset;\n    this._littleEndian = littleEndian;\n    this._bigTiff = bigTiff;\n  }\n\n  get sliceOffset() {\n    return this._sliceOffset;\n  }\n\n  get sliceTop() {\n    return this._sliceOffset + this.buffer.byteLength;\n  }\n\n  get littleEndian() {\n    return this._littleEndian;\n  }\n\n  get bigTiff() {\n    return this._bigTiff;\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  covers(offset, length) {\n    return this.sliceOffset <= offset && this.sliceTop >= offset + length;\n  }\n\n  readUint8(offset) {\n    return this._dataView.getUint8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt8(offset) {\n    return this._dataView.getInt8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint16(offset) {\n    return this._dataView.getUint16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt16(offset) {\n    return this._dataView.getInt16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint32(offset) {\n    return this._dataView.getUint32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt32(offset) {\n    return this._dataView.getInt32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat32(offset) {\n    return this._dataView.getFloat32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat64(offset) {\n    return this._dataView.getFloat64(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint64(offset) {\n    const left = this.readUint32(offset);\n    const right = this.readUint32(offset + 4);\n    let combined;\n    if (this._littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  readInt64(offset) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (this._littleEndian ? 7 : 0)) & 0x80)\n      > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(\n        offset + (this._littleEndian ? i : 7 - i),\n      );\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  readOffset(offset) {\n    if (this._bigTiff) {\n      return this.readUint64(offset);\n    }\n    return this.readUint32(offset);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9kYXRhc2xpY2UuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9kYXRhc2xpY2UuanM/YmZmZSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBjbGFzcyBEYXRhU2xpY2Uge1xuICBjb25zdHJ1Y3RvcihhcnJheUJ1ZmZlciwgc2xpY2VPZmZzZXQsIGxpdHRsZUVuZGlhbiwgYmlnVGlmZikge1xuICAgIHRoaXMuX2RhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGFycmF5QnVmZmVyKTtcbiAgICB0aGlzLl9zbGljZU9mZnNldCA9IHNsaWNlT2Zmc2V0O1xuICAgIHRoaXMuX2xpdHRsZUVuZGlhbiA9IGxpdHRsZUVuZGlhbjtcbiAgICB0aGlzLl9iaWdUaWZmID0gYmlnVGlmZjtcbiAgfVxuXG4gIGdldCBzbGljZU9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2xpY2VPZmZzZXQ7XG4gIH1cblxuICBnZXQgc2xpY2VUb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NsaWNlT2Zmc2V0ICsgdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgfVxuXG4gIGdldCBsaXR0bGVFbmRpYW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xpdHRsZUVuZGlhbjtcbiAgfVxuXG4gIGdldCBiaWdUaWZmKCkge1xuICAgIHJldHVybiB0aGlzLl9iaWdUaWZmO1xuICB9XG5cbiAgZ2V0IGJ1ZmZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuYnVmZmVyO1xuICB9XG5cbiAgY292ZXJzKG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2xpY2VPZmZzZXQgPD0gb2Zmc2V0ICYmIHRoaXMuc2xpY2VUb3AgPj0gb2Zmc2V0ICsgbGVuZ3RoO1xuICB9XG5cbiAgcmVhZFVpbnQ4KG9mZnNldCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5nZXRVaW50OChcbiAgICAgIG9mZnNldCAtIHRoaXMuX3NsaWNlT2Zmc2V0LCB0aGlzLl9saXR0bGVFbmRpYW4sXG4gICAgKTtcbiAgfVxuXG4gIHJlYWRJbnQ4KG9mZnNldCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5nZXRJbnQ4KFxuICAgICAgb2Zmc2V0IC0gdGhpcy5fc2xpY2VPZmZzZXQsIHRoaXMuX2xpdHRsZUVuZGlhbixcbiAgICApO1xuICB9XG5cbiAgcmVhZFVpbnQxNihvZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0VWludDE2KFxuICAgICAgb2Zmc2V0IC0gdGhpcy5fc2xpY2VPZmZzZXQsIHRoaXMuX2xpdHRsZUVuZGlhbixcbiAgICApO1xuICB9XG5cbiAgcmVhZEludDE2KG9mZnNldCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5nZXRJbnQxNihcbiAgICAgIG9mZnNldCAtIHRoaXMuX3NsaWNlT2Zmc2V0LCB0aGlzLl9saXR0bGVFbmRpYW4sXG4gICAgKTtcbiAgfVxuXG4gIHJlYWRVaW50MzIob2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmdldFVpbnQzMihcbiAgICAgIG9mZnNldCAtIHRoaXMuX3NsaWNlT2Zmc2V0LCB0aGlzLl9saXR0bGVFbmRpYW4sXG4gICAgKTtcbiAgfVxuXG4gIHJlYWRJbnQzMihvZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0SW50MzIoXG4gICAgICBvZmZzZXQgLSB0aGlzLl9zbGljZU9mZnNldCwgdGhpcy5fbGl0dGxlRW5kaWFuLFxuICAgICk7XG4gIH1cblxuICByZWFkRmxvYXQzMihvZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0RmxvYXQzMihcbiAgICAgIG9mZnNldCAtIHRoaXMuX3NsaWNlT2Zmc2V0LCB0aGlzLl9saXR0bGVFbmRpYW4sXG4gICAgKTtcbiAgfVxuXG4gIHJlYWRGbG9hdDY0KG9mZnNldCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5nZXRGbG9hdDY0KFxuICAgICAgb2Zmc2V0IC0gdGhpcy5fc2xpY2VPZmZzZXQsIHRoaXMuX2xpdHRsZUVuZGlhbixcbiAgICApO1xuICB9XG5cbiAgcmVhZFVpbnQ2NChvZmZzZXQpIHtcbiAgICBjb25zdCBsZWZ0ID0gdGhpcy5yZWFkVWludDMyKG9mZnNldCk7XG4gICAgY29uc3QgcmlnaHQgPSB0aGlzLnJlYWRVaW50MzIob2Zmc2V0ICsgNCk7XG4gICAgbGV0IGNvbWJpbmVkO1xuICAgIGlmICh0aGlzLl9saXR0bGVFbmRpYW4pIHtcbiAgICAgIGNvbWJpbmVkID0gbGVmdCArICgoMiAqKiAzMikgKiByaWdodCk7XG4gICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGNvbWJpbmVkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYCR7Y29tYmluZWR9IGV4Y2VlZHMgTUFYX1NBRkVfSU5URUdFUi4gYFxuICAgICAgICAgICsgJ1ByZWNpc2lvbiBtYXkgYmUgbG9zdC4gUGxlYXNlIHJlcG9ydCBpZiB5b3UgZ2V0IHRoaXMgbWVzc2FnZSB0byBodHRwczovL2dpdGh1Yi5jb20vZ2VvdGlmZmpzL2dlb3RpZmYuanMvaXNzdWVzJyxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21iaW5lZDtcbiAgICB9XG4gICAgY29tYmluZWQgPSAoKDIgKiogMzIpICogbGVmdCkgKyByaWdodDtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGNvbWJpbmVkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgJHtjb21iaW5lZH0gZXhjZWVkcyBNQVhfU0FGRV9JTlRFR0VSLiBgXG4gICAgICAgICsgJ1ByZWNpc2lvbiBtYXkgYmUgbG9zdC4gUGxlYXNlIHJlcG9ydCBpZiB5b3UgZ2V0IHRoaXMgbWVzc2FnZSB0byBodHRwczovL2dpdGh1Yi5jb20vZ2VvdGlmZmpzL2dlb3RpZmYuanMvaXNzdWVzJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbWJpbmVkO1xuICB9XG5cbiAgLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81NTMzODM4NC84MDYwNTkxXG4gIHJlYWRJbnQ2NChvZmZzZXQpIHtcbiAgICBsZXQgdmFsdWUgPSAwO1xuICAgIGNvbnN0IGlzTmVnYXRpdmUgPSAodGhpcy5fZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgKHRoaXMuX2xpdHRsZUVuZGlhbiA/IDcgOiAwKSkgJiAweDgwKVxuICAgICAgPiAwO1xuICAgIGxldCBjYXJyeWluZyA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICAgIGxldCBieXRlID0gdGhpcy5fZGF0YVZpZXcuZ2V0VWludDgoXG4gICAgICAgIG9mZnNldCArICh0aGlzLl9saXR0bGVFbmRpYW4gPyBpIDogNyAtIGkpLFxuICAgICAgKTtcbiAgICAgIGlmIChpc05lZ2F0aXZlKSB7XG4gICAgICAgIGlmIChjYXJyeWluZykge1xuICAgICAgICAgIGlmIChieXRlICE9PSAweDAwKSB7XG4gICAgICAgICAgICBieXRlID0gfihieXRlIC0gMSkgJiAweGZmO1xuICAgICAgICAgICAgY2FycnlpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnl0ZSA9IH5ieXRlICYgMHhmZjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFsdWUgKz0gYnl0ZSAqICgyNTYgKiogaSk7XG4gICAgfVxuICAgIGlmIChpc05lZ2F0aXZlKSB7XG4gICAgICB2YWx1ZSA9IC12YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcmVhZE9mZnNldChvZmZzZXQpIHtcbiAgICBpZiAodGhpcy5fYmlnVGlmZikge1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFVpbnQ2NChvZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZWFkVWludDMyKG9mZnNldCk7XG4gIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/dataslice.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/dataview64.js":
/*!********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/dataview64.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return DataView64; });\n/* harmony import */ var _petamoriken_float16__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @petamoriken/float16 */ \"./node_modules/@petamoriken/float16/browser/float16.js\");\n/* harmony import */ var _petamoriken_float16__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_petamoriken_float16__WEBPACK_IMPORTED_MODULE_0__);\n\n\nclass DataView64 {\n  constructor(arrayBuffer) {\n    this._dataView = new DataView(arrayBuffer);\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  getUint64(offset, littleEndian) {\n    const left = this.getUint32(offset, littleEndian);\n    const right = this.getUint32(offset + 4, littleEndian);\n    let combined;\n    if (littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  getInt64(offset, littleEndian) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (littleEndian ? 7 : 0)) & 0x80) > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(offset + (littleEndian ? i : 7 - i));\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  getUint8(offset, littleEndian) {\n    return this._dataView.getUint8(offset, littleEndian);\n  }\n\n  getInt8(offset, littleEndian) {\n    return this._dataView.getInt8(offset, littleEndian);\n  }\n\n  getUint16(offset, littleEndian) {\n    return this._dataView.getUint16(offset, littleEndian);\n  }\n\n  getInt16(offset, littleEndian) {\n    return this._dataView.getInt16(offset, littleEndian);\n  }\n\n  getUint32(offset, littleEndian) {\n    return this._dataView.getUint32(offset, littleEndian);\n  }\n\n  getInt32(offset, littleEndian) {\n    return this._dataView.getInt32(offset, littleEndian);\n  }\n\n  getFloat16(offset, littleEndian) {\n    return Object(_petamoriken_float16__WEBPACK_IMPORTED_MODULE_0__[\"getFloat16\"])(this._dataView, offset, littleEndian);\n  }\n\n  getFloat32(offset, littleEndian) {\n    return this._dataView.getFloat32(offset, littleEndian);\n  }\n\n  getFloat64(offset, littleEndian) {\n    return this._dataView.getFloat64(offset, littleEndian);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9kYXRhdmlldzY0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvZGF0YXZpZXc2NC5qcz82NTQ1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEZsb2F0MTYgfSBmcm9tICdAcGV0YW1vcmlrZW4vZmxvYXQxNic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERhdGFWaWV3NjQge1xuICBjb25zdHJ1Y3RvcihhcnJheUJ1ZmZlcikge1xuICAgIHRoaXMuX2RhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGFycmF5QnVmZmVyKTtcbiAgfVxuXG4gIGdldCBidWZmZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmJ1ZmZlcjtcbiAgfVxuXG4gIGdldFVpbnQ2NChvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgIGNvbnN0IGxlZnQgPSB0aGlzLmdldFVpbnQzMihvZmZzZXQsIGxpdHRsZUVuZGlhbik7XG4gICAgY29uc3QgcmlnaHQgPSB0aGlzLmdldFVpbnQzMihvZmZzZXQgKyA0LCBsaXR0bGVFbmRpYW4pO1xuICAgIGxldCBjb21iaW5lZDtcbiAgICBpZiAobGl0dGxlRW5kaWFuKSB7XG4gICAgICBjb21iaW5lZCA9IGxlZnQgKyAoKDIgKiogMzIpICogcmlnaHQpO1xuICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihjb21iaW5lZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGAke2NvbWJpbmVkfSBleGNlZWRzIE1BWF9TQUZFX0lOVEVHRVIuIGBcbiAgICAgICAgICArICdQcmVjaXNpb24gbWF5IGJlIGxvc3QuIFBsZWFzZSByZXBvcnQgaWYgeW91IGdldCB0aGlzIG1lc3NhZ2UgdG8gaHR0cHM6Ly9naXRodWIuY29tL2dlb3RpZmZqcy9nZW90aWZmLmpzL2lzc3VlcycsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29tYmluZWQ7XG4gICAgfVxuICAgIGNvbWJpbmVkID0gKCgyICoqIDMyKSAqIGxlZnQpICsgcmlnaHQ7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihjb21iaW5lZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYCR7Y29tYmluZWR9IGV4Y2VlZHMgTUFYX1NBRkVfSU5URUdFUi4gYFxuICAgICAgICArICdQcmVjaXNpb24gbWF5IGJlIGxvc3QuIFBsZWFzZSByZXBvcnQgaWYgeW91IGdldCB0aGlzIG1lc3NhZ2UgdG8gaHR0cHM6Ly9naXRodWIuY29tL2dlb3RpZmZqcy9nZW90aWZmLmpzL2lzc3VlcycsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBjb21iaW5lZDtcbiAgfVxuXG4gIC8vIGFkYXB0ZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTUzMzgzODQvODA2MDU5MVxuICBnZXRJbnQ2NChvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgIGxldCB2YWx1ZSA9IDA7XG4gICAgY29uc3QgaXNOZWdhdGl2ZSA9ICh0aGlzLl9kYXRhVmlldy5nZXRVaW50OChvZmZzZXQgKyAobGl0dGxlRW5kaWFuID8gNyA6IDApKSAmIDB4ODApID4gMDtcbiAgICBsZXQgY2FycnlpbmcgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICBsZXQgYnl0ZSA9IHRoaXMuX2RhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIChsaXR0bGVFbmRpYW4gPyBpIDogNyAtIGkpKTtcbiAgICAgIGlmIChpc05lZ2F0aXZlKSB7XG4gICAgICAgIGlmIChjYXJyeWluZykge1xuICAgICAgICAgIGlmIChieXRlICE9PSAweDAwKSB7XG4gICAgICAgICAgICBieXRlID0gfihieXRlIC0gMSkgJiAweGZmO1xuICAgICAgICAgICAgY2FycnlpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnl0ZSA9IH5ieXRlICYgMHhmZjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFsdWUgKz0gYnl0ZSAqICgyNTYgKiogaSk7XG4gICAgfVxuICAgIGlmIChpc05lZ2F0aXZlKSB7XG4gICAgICB2YWx1ZSA9IC12YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgZ2V0VWludDgob2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuICB9XG5cbiAgZ2V0SW50OChvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5nZXRJbnQ4KG9mZnNldCwgbGl0dGxlRW5kaWFuKTtcbiAgfVxuXG4gIGdldFVpbnQxNihvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuICB9XG5cbiAgZ2V0SW50MTYob2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0SW50MTYob2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuICB9XG5cbiAgZ2V0VWludDMyKG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmdldFVpbnQzMihvZmZzZXQsIGxpdHRsZUVuZGlhbik7XG4gIH1cblxuICBnZXRJbnQzMihvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5nZXRJbnQzMihvZmZzZXQsIGxpdHRsZUVuZGlhbik7XG4gIH1cblxuICBnZXRGbG9hdDE2KG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgcmV0dXJuIGdldEZsb2F0MTYodGhpcy5fZGF0YVZpZXcsIG9mZnNldCwgbGl0dGxlRW5kaWFuKTtcbiAgfVxuXG4gIGdldEZsb2F0MzIob2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0RmxvYXQzMihvZmZzZXQsIGxpdHRsZUVuZGlhbik7XG4gIH1cblxuICBnZXRGbG9hdDY0KG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmdldEZsb2F0NjQob2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuICB9XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/dataview64.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/geotiff.js":
/*!*****************************************************!*\
  !*** ./node_modules/geotiff/dist-module/geotiff.js ***!
  \*****************************************************/
/*! exports provided: globals, rgb, BaseDecoder, getDecoder, addDecoder, setLogger, GeoTIFF, default, MultiGeoTIFF, fromUrl, fromCustomClient, fromArrayBuffer, fromFile, fromBlob, fromUrls, writeArrayBuffer, Pool, GeoTIFFImage, BaseClient, BaseResponse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GeoTIFF\", function() { return GeoTIFF; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MultiGeoTIFF\", function() { return MultiGeoTIFF; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromUrl\", function() { return fromUrl; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromCustomClient\", function() { return fromCustomClient; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromArrayBuffer\", function() { return fromArrayBuffer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromFile\", function() { return fromFile; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromBlob\", function() { return fromBlob; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromUrls\", function() { return fromUrls; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"writeArrayBuffer\", function() { return writeArrayBuffer; });\n/* harmony import */ var _geotiffimage_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geotiffimage.js */ \"./node_modules/geotiff/dist-module/geotiffimage.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"GeoTIFFImage\", function() { return _geotiffimage_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; });\n\n/* harmony import */ var _dataview64_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dataview64.js */ \"./node_modules/geotiff/dist-module/dataview64.js\");\n/* harmony import */ var _dataslice_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dataslice.js */ \"./node_modules/geotiff/dist-module/dataslice.js\");\n/* harmony import */ var _pool_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pool.js */ \"./node_modules/geotiff/dist-module/pool.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Pool\", function() { return _pool_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]; });\n\n/* harmony import */ var _source_remote_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./source/remote.js */ \"./node_modules/geotiff/dist-module/source/remote.js\");\n/* harmony import */ var _source_arraybuffer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./source/arraybuffer.js */ \"./node_modules/geotiff/dist-module/source/arraybuffer.js\");\n/* harmony import */ var _source_filereader_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./source/filereader.js */ \"./node_modules/geotiff/dist-module/source/filereader.js\");\n/* harmony import */ var _source_file_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./source/file.js */ \"./node_modules/geotiff/dist-module/source/file.js\");\n/* harmony import */ var _source_client_base_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./source/client/base.js */ \"./node_modules/geotiff/dist-module/source/client/base.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"BaseClient\", function() { return _source_client_base_js__WEBPACK_IMPORTED_MODULE_8__[\"BaseClient\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"BaseResponse\", function() { return _source_client_base_js__WEBPACK_IMPORTED_MODULE_8__[\"BaseResponse\"]; });\n\n/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./globals.js */ \"./node_modules/geotiff/dist-module/globals.js\");\n/* harmony import */ var _geotiffwriter_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./geotiffwriter.js */ \"./node_modules/geotiff/dist-module/geotiffwriter.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"globals\", function() { return _globals_js__WEBPACK_IMPORTED_MODULE_9__; });\n/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./rgb.js */ \"./node_modules/geotiff/dist-module/rgb.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"rgb\", function() { return _rgb_js__WEBPACK_IMPORTED_MODULE_11__; });\n/* harmony import */ var _compression_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./compression/index.js */ \"./node_modules/geotiff/dist-module/compression/index.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getDecoder\", function() { return _compression_index_js__WEBPACK_IMPORTED_MODULE_12__[\"getDecoder\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"addDecoder\", function() { return _compression_index_js__WEBPACK_IMPORTED_MODULE_12__[\"addDecoder\"]; });\n\n/* harmony import */ var _logging_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./logging.js */ \"./node_modules/geotiff/dist-module/logging.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"setLogger\", function() { return _logging_js__WEBPACK_IMPORTED_MODULE_13__[\"setLogger\"]; });\n\n/* harmony import */ var _compression_basedecoder_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./compression/basedecoder.js */ \"./node_modules/geotiff/dist-module/compression/basedecoder.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"BaseDecoder\", function() { return _compression_basedecoder_js__WEBPACK_IMPORTED_MODULE_14__[\"default\"]; });\n\n/** @module geotiff */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @typedef {Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array | Float32Array | Float64Array}\n * TypedArray\n */\n\n/**\n * @typedef {{ height:number, width: number }} Dimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray & { height: number; width: number}`\n * @typedef {TypedArray & Dimensions} TypedArrayWithDimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray[] & { height: number; width: number}`\n * @typedef {TypedArray[] & Dimensions} TypedArrayArrayWithDimensions\n */\n\n/**\n *  The autogenerated docs are a little confusing here. The effective type is:\n *\n * `(TypedArray | TypedArray[]) & { height: number; width: number}`\n * @typedef {TypedArrayWithDimensions | TypedArrayArrayWithDimensions} ReadRasterResult\n */\n\nfunction getFieldTypeLength(fieldType) {\n  switch (fieldType) {\n    case _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].BYTE: case _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].ASCII: case _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].SBYTE: case _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].UNDEFINED:\n      return 1;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].SHORT: case _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].SSHORT:\n      return 2;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].LONG: case _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].SLONG: case _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].FLOAT: case _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].IFD:\n      return 4;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].RATIONAL: case _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].SRATIONAL: case _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].DOUBLE:\n    case _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].LONG8: case _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].SLONG8: case _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].IFD8:\n      return 8;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n}\n\nfunction parseGeoKeyDirectory(fileDirectory) {\n  const rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;\n  if (!rawGeoKeyDirectory) {\n    return null;\n  }\n\n  const geoKeyDirectory = {};\n  for (let i = 4; i <= rawGeoKeyDirectory[3] * 4; i += 4) {\n    const key = _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"geoKeyNames\"][rawGeoKeyDirectory[i]];\n    const location = (rawGeoKeyDirectory[i + 1])\n      ? (_globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTagNames\"][rawGeoKeyDirectory[i + 1]]) : null;\n    const count = rawGeoKeyDirectory[i + 2];\n    const offset = rawGeoKeyDirectory[i + 3];\n\n    let value = null;\n    if (!location) {\n      value = offset;\n    } else {\n      value = fileDirectory[location];\n      if (typeof value === 'undefined' || value === null) {\n        throw new Error(`Could not get value of geoKey '${key}'.`);\n      } else if (typeof value === 'string') {\n        value = value.substring(offset, offset + count - 1);\n      } else if (value.subarray) {\n        value = value.subarray(offset, offset + count);\n        if (count === 1) {\n          value = value[0];\n        }\n      }\n    }\n    geoKeyDirectory[key] = value;\n  }\n  return geoKeyDirectory;\n}\n\nfunction getValues(dataSlice, fieldType, count, offset) {\n  let values = null;\n  let readMethod = null;\n  const fieldTypeLength = getFieldTypeLength(fieldType);\n\n  switch (fieldType) {\n    case _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].BYTE: case _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].ASCII: case _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].UNDEFINED:\n      values = new Uint8Array(count); readMethod = dataSlice.readUint8;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].SBYTE:\n      values = new Int8Array(count); readMethod = dataSlice.readInt8;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].SHORT:\n      values = new Uint16Array(count); readMethod = dataSlice.readUint16;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].SSHORT:\n      values = new Int16Array(count); readMethod = dataSlice.readInt16;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].LONG: case _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].IFD:\n      values = new Uint32Array(count); readMethod = dataSlice.readUint32;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].SLONG:\n      values = new Int32Array(count); readMethod = dataSlice.readInt32;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].LONG8: case _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].IFD8:\n      values = new Array(count); readMethod = dataSlice.readUint64;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].SLONG8:\n      values = new Array(count); readMethod = dataSlice.readInt64;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].RATIONAL:\n      values = new Uint32Array(count * 2); readMethod = dataSlice.readUint32;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].SRATIONAL:\n      values = new Int32Array(count * 2); readMethod = dataSlice.readInt32;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].FLOAT:\n      values = new Float32Array(count); readMethod = dataSlice.readFloat32;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].DOUBLE:\n      values = new Float64Array(count); readMethod = dataSlice.readFloat64;\n      break;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n\n  // normal fields\n  if (!(fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].RATIONAL || fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].SRATIONAL)) {\n    for (let i = 0; i < count; ++i) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n    }\n  } else { // RATIONAL or SRATIONAL\n    for (let i = 0; i < count; i += 2) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n      values[i + 1] = readMethod.call(\n        dataSlice, offset + ((i * fieldTypeLength) + 4),\n      );\n    }\n  }\n\n  if (fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].ASCII) {\n    return new TextDecoder('utf-8').decode(values);\n  }\n  return values;\n}\n\n/**\n * Data class to store the parsed file directory, geo key directory and\n * offset to the next IFD\n */\nclass ImageFileDirectory {\n  constructor(fileDirectory, geoKeyDirectory, nextIFDByteOffset) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeyDirectory = geoKeyDirectory;\n    this.nextIFDByteOffset = nextIFDByteOffset;\n  }\n}\n\n/**\n * Error class for cases when an IFD index was requested, that does not exist\n * in the file.\n */\nclass GeoTIFFImageIndexError extends Error {\n  constructor(index) {\n    super(`No image at index ${index}`);\n    this.index = index;\n  }\n}\n\nclass GeoTIFFBase {\n  /**\n   * (experimental) Reads raster data from the best fitting image. This function uses\n   * the image with the lowest resolution that is still a higher resolution than the\n   * requested resolution.\n   * When specified, the `bbox` option is translated to the `window` option and the\n   * `resX` and `resY` to `width` and `height` respectively.\n   * Then, the [readRasters]{@link GeoTIFFImage#readRasters} method of the selected\n   * image is called and the result returned.\n   * @see GeoTIFFImage.readRasters\n   * @param {import('./geotiffimage').ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded array(s), with `height` and `width`, as a promise\n   */\n  async readRasters(options = {}) {\n    const { window: imageWindow, width, height } = options;\n    let { resX, resY, bbox } = options;\n\n    const firstImage = await this.getImage();\n    let usedImage = firstImage;\n    const imageCount = await this.getImageCount();\n    const imgBBox = firstImage.getBoundingBox();\n\n    if (imageWindow && bbox) {\n      throw new Error('Both \"bbox\" and \"window\" passed.');\n    }\n\n    // if width/height is passed, transform it to resolution\n    if (width || height) {\n      // if we have an image window (pixel coordinates), transform it to a BBox\n      // using the origin/resolution of the first image.\n      if (imageWindow) {\n        const [oX, oY] = firstImage.getOrigin();\n        const [rX, rY] = firstImage.getResolution();\n\n        bbox = [\n          oX + (imageWindow[0] * rX),\n          oY + (imageWindow[1] * rY),\n          oX + (imageWindow[2] * rX),\n          oY + (imageWindow[3] * rY),\n        ];\n      }\n\n      // if we have a bbox (or calculated one)\n\n      const usedBBox = bbox || imgBBox;\n\n      if (width) {\n        if (resX) {\n          throw new Error('Both width and resX passed');\n        }\n        resX = (usedBBox[2] - usedBBox[0]) / width;\n      }\n      if (height) {\n        if (resY) {\n          throw new Error('Both width and resY passed');\n        }\n        resY = (usedBBox[3] - usedBBox[1]) / height;\n      }\n    }\n\n    // if resolution is set or calculated, try to get the image with the worst acceptable resolution\n    if (resX || resY) {\n      const allImages = [];\n      for (let i = 0; i < imageCount; ++i) {\n        const image = await this.getImage(i);\n        const { SubfileType: subfileType, NewSubfileType: newSubfileType } = image.fileDirectory;\n        if (i === 0 || subfileType === 2 || newSubfileType & 1) {\n          allImages.push(image);\n        }\n      }\n\n      allImages.sort((a, b) => a.getWidth() - b.getWidth());\n      for (let i = 0; i < allImages.length; ++i) {\n        const image = allImages[i];\n        const imgResX = (imgBBox[2] - imgBBox[0]) / image.getWidth();\n        const imgResY = (imgBBox[3] - imgBBox[1]) / image.getHeight();\n\n        usedImage = image;\n        if ((resX && resX > imgResX) || (resY && resY > imgResY)) {\n          break;\n        }\n      }\n    }\n\n    let wnd = imageWindow;\n    if (bbox) {\n      const [oX, oY] = firstImage.getOrigin();\n      const [imageResX, imageResY] = usedImage.getResolution(firstImage);\n\n      wnd = [\n        Math.round((bbox[0] - oX) / imageResX),\n        Math.round((bbox[1] - oY) / imageResY),\n        Math.round((bbox[2] - oX) / imageResX),\n        Math.round((bbox[3] - oY) / imageResY),\n      ];\n      wnd = [\n        Math.min(wnd[0], wnd[2]),\n        Math.min(wnd[1], wnd[3]),\n        Math.max(wnd[0], wnd[2]),\n        Math.max(wnd[1], wnd[3]),\n      ];\n    }\n\n    return usedImage.readRasters({ ...options, window: wnd });\n  }\n}\n\n/**\n * @typedef {Object} GeoTIFFOptions\n * @property {boolean} [cache=false] whether or not decoded tiles shall be cached.\n */\n\n/**\n * The abstraction for a whole GeoTIFF file.\n * @augments GeoTIFFBase\n */\nclass GeoTIFF extends GeoTIFFBase {\n  /**\n   * @constructor\n   * @param {*} source The datasource to read from.\n   * @param {boolean} littleEndian Whether the image uses little endian.\n   * @param {boolean} bigTiff Whether the image uses bigTIFF conventions.\n   * @param {number} firstIFDOffset The numeric byte-offset from the start of the image\n   *                                to the first IFD.\n   * @param {GeoTIFFOptions} [options] further options.\n   */\n  constructor(source, littleEndian, bigTiff, firstIFDOffset, options = {}) {\n    super();\n    this.source = source;\n    this.littleEndian = littleEndian;\n    this.bigTiff = bigTiff;\n    this.firstIFDOffset = firstIFDOffset;\n    this.cache = options.cache || false;\n    this.ifdRequests = [];\n    this.ghostValues = null;\n  }\n\n  async getSlice(offset, size) {\n    const fallbackSize = this.bigTiff ? 4048 : 1024;\n    return new _dataslice_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](\n      (await this.source.fetch([{\n        offset,\n        length: typeof size !== 'undefined' ? size : fallbackSize,\n      }]))[0],\n      offset,\n      this.littleEndian,\n      this.bigTiff,\n    );\n  }\n\n  /**\n   * Instructs to parse an image file directory at the given file offset.\n   * As there is no way to ensure that a location is indeed the start of an IFD,\n   * this function must be called with caution (e.g only using the IFD offsets from\n   * the headers or other IFDs).\n   * @param {number} offset the offset to parse the IFD at\n   * @returns {Promise<ImageFileDirectory>} the parsed IFD\n   */\n  async parseFileDirectoryAt(offset) {\n    const entrySize = this.bigTiff ? 20 : 12;\n    const offsetSize = this.bigTiff ? 8 : 2;\n\n    let dataSlice = await this.getSlice(offset);\n    const numDirEntries = this.bigTiff\n      ? dataSlice.readUint64(offset)\n      : dataSlice.readUint16(offset);\n\n    // if the slice does not cover the whole IFD, request a bigger slice, where the\n    // whole IFD fits: num of entries + n x tag length + offset to next IFD\n    const byteSize = (numDirEntries * entrySize) + (this.bigTiff ? 16 : 6);\n    if (!dataSlice.covers(offset, byteSize)) {\n      dataSlice = await this.getSlice(offset, byteSize);\n    }\n\n    const fileDirectory = {};\n\n    // loop over the IFD and create a file directory object\n    let i = offset + (this.bigTiff ? 8 : 2);\n    for (let entryCount = 0; entryCount < numDirEntries; i += entrySize, ++entryCount) {\n      const fieldTag = dataSlice.readUint16(i);\n      const fieldType = dataSlice.readUint16(i + 2);\n      const typeCount = this.bigTiff\n        ? dataSlice.readUint64(i + 4)\n        : dataSlice.readUint32(i + 4);\n\n      let fieldValues;\n      let value;\n      const fieldTypeLength = getFieldTypeLength(fieldType);\n      const valueOffset = i + (this.bigTiff ? 12 : 8);\n\n      // check whether the value is directly encoded in the tag or refers to a\n      // different external byte range\n      if (fieldTypeLength * typeCount <= (this.bigTiff ? 8 : 4)) {\n        fieldValues = getValues(dataSlice, fieldType, typeCount, valueOffset);\n      } else {\n        // resolve the reference to the actual byte range\n        const actualOffset = dataSlice.readOffset(valueOffset);\n        const length = getFieldTypeLength(fieldType) * typeCount;\n\n        // check, whether we actually cover the referenced byte range; if not,\n        // request a new slice of bytes to read from it\n        if (dataSlice.covers(actualOffset, length)) {\n          fieldValues = getValues(dataSlice, fieldType, typeCount, actualOffset);\n        } else {\n          const fieldDataSlice = await this.getSlice(actualOffset, length);\n          fieldValues = getValues(fieldDataSlice, fieldType, typeCount, actualOffset);\n        }\n      }\n\n      // unpack single values from the array\n      if (typeCount === 1 && _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"arrayFields\"].indexOf(fieldTag) === -1\n        && !(fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].RATIONAL || fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].SRATIONAL)) {\n        value = fieldValues[0];\n      } else {\n        value = fieldValues;\n      }\n\n      // write the tags value to the file directly\n      fileDirectory[_globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTagNames\"][fieldTag]] = value;\n    }\n    const geoKeyDirectory = parseGeoKeyDirectory(fileDirectory);\n    const nextIFDByteOffset = dataSlice.readOffset(\n      offset + offsetSize + (entrySize * numDirEntries),\n    );\n\n    return new ImageFileDirectory(\n      fileDirectory,\n      geoKeyDirectory,\n      nextIFDByteOffset,\n    );\n  }\n\n  async requestIFD(index) {\n    // see if we already have that IFD index requested.\n    if (this.ifdRequests[index]) {\n      // attach to an already requested IFD\n      return this.ifdRequests[index];\n    } else if (index === 0) {\n      // special case for index 0\n      this.ifdRequests[index] = this.parseFileDirectoryAt(this.firstIFDOffset);\n      return this.ifdRequests[index];\n    } else if (!this.ifdRequests[index - 1]) {\n      // if the previous IFD was not yet loaded, load that one first\n      // this is the recursive call.\n      try {\n        this.ifdRequests[index - 1] = this.requestIFD(index - 1);\n      } catch (e) {\n        // if the previous one already was an index error, rethrow\n        // with the current index\n        if (e instanceof GeoTIFFImageIndexError) {\n          throw new GeoTIFFImageIndexError(index);\n        }\n        // rethrow anything else\n        throw e;\n      }\n    }\n    // if the previous IFD was loaded, we can finally fetch the one we are interested in.\n    // we need to wrap this in an IIFE, otherwise this.ifdRequests[index] would be delayed\n    this.ifdRequests[index] = (async () => {\n      const previousIfd = await this.ifdRequests[index - 1];\n      if (previousIfd.nextIFDByteOffset === 0) {\n        throw new GeoTIFFImageIndexError(index);\n      }\n      return this.parseFileDirectoryAt(previousIfd.nextIFDByteOffset);\n    })();\n    return this.ifdRequests[index];\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    const ifd = await this.requestIFD(index);\n    return new _geotiffimage_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\n      ifd.fileDirectory, ifd.geoKeyDirectory,\n      this.dataView, this.littleEndian, this.cache, this.source,\n    );\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    let index = 0;\n    // loop until we run out of IFDs\n    let hasNext = true;\n    while (hasNext) {\n      try {\n        await this.requestIFD(index);\n        ++index;\n      } catch (e) {\n        if (e instanceof GeoTIFFImageIndexError) {\n          hasNext = false;\n        } else {\n          throw e;\n        }\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Get the values of the COG ghost area as a parsed map.\n   * See https://gdal.org/drivers/raster/cog.html#header-ghost-area for reference\n   * @returns {Promise<Object>} the parsed ghost area or null, if no such area was found\n   */\n  async getGhostValues() {\n    const offset = this.bigTiff ? 16 : 8;\n    if (this.ghostValues) {\n      return this.ghostValues;\n    }\n    const detectionString = 'GDAL_STRUCTURAL_METADATA_SIZE=';\n    const heuristicAreaSize = detectionString.length + 100;\n    let slice = await this.getSlice(offset, heuristicAreaSize);\n    if (detectionString === getValues(slice, _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].ASCII, detectionString.length, offset)) {\n      const valuesString = getValues(slice, _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].ASCII, heuristicAreaSize, offset);\n      const firstLine = valuesString.split('\\n')[0];\n      const metadataSize = Number(firstLine.split('=')[1].split(' ')[0]) + firstLine.length;\n      if (metadataSize > heuristicAreaSize) {\n        slice = await this.getSlice(offset, metadataSize);\n      }\n      const fullString = getValues(slice, _globals_js__WEBPACK_IMPORTED_MODULE_9__[\"fieldTypes\"].ASCII, metadataSize, offset);\n      this.ghostValues = {};\n      fullString\n        .split('\\n')\n        .filter((line) => line.length > 0)\n        .map((line) => line.split('='))\n        .forEach(([key, value]) => {\n          this.ghostValues[key] = value;\n        });\n    }\n    return this.ghostValues;\n  }\n\n  /**\n   * Parse a (Geo)TIFF file from the given source.\n   *\n   * @param {*} source The source of data to parse from.\n   * @param {GeoTIFFOptions} [options] Additional options.\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   */\n  static async fromSource(source, options, signal) {\n    const headerData = (await source.fetch([{ offset: 0, length: 1024 }], signal))[0];\n    const dataView = new _dataview64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](headerData);\n\n    const BOM = dataView.getUint16(0, 0);\n    let littleEndian;\n    if (BOM === 0x4949) {\n      littleEndian = true;\n    } else if (BOM === 0x4D4D) {\n      littleEndian = false;\n    } else {\n      throw new TypeError('Invalid byte order value.');\n    }\n\n    const magicNumber = dataView.getUint16(2, littleEndian);\n    let bigTiff;\n    if (magicNumber === 42) {\n      bigTiff = false;\n    } else if (magicNumber === 43) {\n      bigTiff = true;\n      const offsetByteSize = dataView.getUint16(4, littleEndian);\n      if (offsetByteSize !== 8) {\n        throw new Error('Unsupported offset byte-size.');\n      }\n    } else {\n      throw new TypeError('Invalid magic number.');\n    }\n\n    const firstIFDOffset = bigTiff\n      ? dataView.getUint64(8, littleEndian)\n      : dataView.getUint32(4, littleEndian);\n    return new GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset, options);\n  }\n\n  /**\n   * Closes the underlying file buffer\n   * N.B. After the GeoTIFF has been completely processed it needs\n   * to be closed but only if it has been constructed from a file.\n   */\n  close() {\n    if (typeof this.source.close === 'function') {\n      return this.source.close();\n    }\n    return false;\n  }\n}\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (GeoTIFF);\n\n/**\n * Wrapper for GeoTIFF files that have external overviews.\n * @augments GeoTIFFBase\n */\nclass MultiGeoTIFF extends GeoTIFFBase {\n  /**\n   * Construct a new MultiGeoTIFF from a main and several overview files.\n   * @param {GeoTIFF} mainFile The main GeoTIFF file.\n   * @param {GeoTIFF[]} overviewFiles An array of overview files.\n   */\n  constructor(mainFile, overviewFiles) {\n    super();\n    this.mainFile = mainFile;\n    this.overviewFiles = overviewFiles;\n    this.imageFiles = [mainFile].concat(overviewFiles);\n\n    this.fileDirectoriesPerFile = null;\n    this.fileDirectoriesPerFileParsing = null;\n    this.imageCount = null;\n  }\n\n  async parseFileDirectoriesPerFile() {\n    const requests = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)]\n      .concat(this.overviewFiles.map((file) => file.parseFileDirectoryAt(file.firstIFDOffset)));\n\n    this.fileDirectoriesPerFile = await Promise.all(requests);\n    return this.fileDirectoriesPerFile;\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    await this.getImageCount();\n    await this.parseFileDirectoriesPerFile();\n    let visited = 0;\n    let relativeIndex = 0;\n    for (let i = 0; i < this.imageFiles.length; i++) {\n      const imageFile = this.imageFiles[i];\n      for (let ii = 0; ii < this.imageCounts[i]; ii++) {\n        if (index === visited) {\n          const ifd = await imageFile.requestIFD(relativeIndex);\n          return new _geotiffimage_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\n            ifd.fileDirectory, ifd.geoKeyDirectory,\n            imageFile.dataView, imageFile.littleEndian, imageFile.cache, imageFile.source,\n          );\n        }\n        visited++;\n        relativeIndex++;\n      }\n      relativeIndex = 0;\n    }\n\n    throw new RangeError('Invalid image index');\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    if (this.imageCount !== null) {\n      return this.imageCount;\n    }\n    const requests = [this.mainFile.getImageCount()]\n      .concat(this.overviewFiles.map((file) => file.getImageCount()));\n    this.imageCounts = await Promise.all(requests);\n    this.imageCount = this.imageCounts.reduce((count, ifds) => count + ifds, 0);\n    return this.imageCount;\n  }\n}\n\n\n\n/**\n * Creates a new GeoTIFF from a remote URL.\n * @param {string} url The URL to access the image from\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nasync function fromUrl(url, options = {}, signal) {\n  return GeoTIFF.fromSource(Object(_source_remote_js__WEBPACK_IMPORTED_MODULE_4__[\"makeRemoteSource\"])(url, options), signal);\n}\n\n/**\n * Creates a new GeoTIFF from a custom {@link BaseClient}.\n * @param {BaseClient} client The client.\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nasync function fromCustomClient(client, options = {}, signal) {\n  return GeoTIFF.fromSource(Object(_source_remote_js__WEBPACK_IMPORTED_MODULE_4__[\"makeCustomSource\"])(client, options), signal);\n}\n\n/**\n * Construct a new GeoTIFF from an\n * [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}.\n * @param {ArrayBuffer} arrayBuffer The data to read the file from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nasync function fromArrayBuffer(arrayBuffer, signal) {\n  return GeoTIFF.fromSource(Object(_source_arraybuffer_js__WEBPACK_IMPORTED_MODULE_5__[\"makeBufferSource\"])(arrayBuffer), signal);\n}\n\n/**\n * Construct a GeoTIFF from a local file path. This uses the node\n * [filesystem API]{@link https://nodejs.org/api/fs.html} and is\n * not available on browsers.\n *\n * N.B. After the GeoTIFF has been completely processed it needs\n * to be closed but only if it has been constructed from a file.\n * @param {string} path The file path to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nasync function fromFile(path, signal) {\n  return GeoTIFF.fromSource(Object(_source_file_js__WEBPACK_IMPORTED_MODULE_7__[\"makeFileSource\"])(path), signal);\n}\n\n/**\n * Construct a GeoTIFF from an HTML\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob} or\n * [File]{@link https://developer.mozilla.org/en-US/docs/Web/API/File}\n * object.\n * @param {Blob|File} blob The Blob or File object to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nasync function fromBlob(blob, signal) {\n  return GeoTIFF.fromSource(Object(_source_filereader_js__WEBPACK_IMPORTED_MODULE_6__[\"makeFileReaderSource\"])(blob), signal);\n}\n\n/**\n * Construct a MultiGeoTIFF from the given URLs.\n * @param {string} mainUrl The URL for the main file.\n * @param {string[]} overviewUrls An array of URLs for the overview images.\n * @param {Object} [options] Additional options to pass to the source.\n *                           See [makeRemoteSource]{@link module:source.makeRemoteSource}\n *                           for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<MultiGeoTIFF>} The resulting MultiGeoTIFF file.\n */\nasync function fromUrls(mainUrl, overviewUrls = [], options = {}, signal) {\n  const mainFile = await GeoTIFF.fromSource(Object(_source_remote_js__WEBPACK_IMPORTED_MODULE_4__[\"makeRemoteSource\"])(mainUrl, options), signal);\n  const overviewFiles = await Promise.all(\n    overviewUrls.map((url) => GeoTIFF.fromSource(Object(_source_remote_js__WEBPACK_IMPORTED_MODULE_4__[\"makeRemoteSource\"])(url, options))),\n  );\n\n  return new MultiGeoTIFF(mainFile, overviewFiles);\n}\n\n/**\n * Main creating function for GeoTIFF files.\n * @param {(Array)} array of pixel values\n * @returns {metadata} metadata\n */\nfunction writeArrayBuffer(values, metadata) {\n  return Object(_geotiffwriter_js__WEBPACK_IMPORTED_MODULE_10__[\"writeGeotiff\"])(values, metadata);\n}\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9nZW90aWZmLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvZ2VvdGlmZi5qcz8yNzIxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbW9kdWxlIGdlb3RpZmYgKi9cbmltcG9ydCBHZW9USUZGSW1hZ2UgZnJvbSAnLi9nZW90aWZmaW1hZ2UuanMnO1xuaW1wb3J0IERhdGFWaWV3NjQgZnJvbSAnLi9kYXRhdmlldzY0LmpzJztcbmltcG9ydCBEYXRhU2xpY2UgZnJvbSAnLi9kYXRhc2xpY2UuanMnO1xuaW1wb3J0IFBvb2wgZnJvbSAnLi9wb29sLmpzJztcblxuaW1wb3J0IHsgbWFrZVJlbW90ZVNvdXJjZSwgbWFrZUN1c3RvbVNvdXJjZSB9IGZyb20gJy4vc291cmNlL3JlbW90ZS5qcyc7XG5pbXBvcnQgeyBtYWtlQnVmZmVyU291cmNlIH0gZnJvbSAnLi9zb3VyY2UvYXJyYXlidWZmZXIuanMnO1xuaW1wb3J0IHsgbWFrZUZpbGVSZWFkZXJTb3VyY2UgfSBmcm9tICcuL3NvdXJjZS9maWxlcmVhZGVyLmpzJztcbmltcG9ydCB7IG1ha2VGaWxlU291cmNlIH0gZnJvbSAnLi9zb3VyY2UvZmlsZS5qcyc7XG5pbXBvcnQgeyBCYXNlQ2xpZW50LCBCYXNlUmVzcG9uc2UgfSBmcm9tICcuL3NvdXJjZS9jbGllbnQvYmFzZS5qcyc7XG5cbmltcG9ydCB7IGZpZWxkVHlwZXMsIGZpZWxkVGFnTmFtZXMsIGFycmF5RmllbGRzLCBnZW9LZXlOYW1lcyB9IGZyb20gJy4vZ2xvYmFscy5qcyc7XG5pbXBvcnQgeyB3cml0ZUdlb3RpZmYgfSBmcm9tICcuL2dlb3RpZmZ3cml0ZXIuanMnO1xuaW1wb3J0ICogYXMgZ2xvYmFscyBmcm9tICcuL2dsb2JhbHMuanMnO1xuaW1wb3J0ICogYXMgcmdiIGZyb20gJy4vcmdiLmpzJztcbmltcG9ydCB7IGdldERlY29kZXIsIGFkZERlY29kZXIgfSBmcm9tICcuL2NvbXByZXNzaW9uL2luZGV4LmpzJztcbmltcG9ydCB7IHNldExvZ2dlciB9IGZyb20gJy4vbG9nZ2luZy5qcyc7XG5cbmV4cG9ydCB7IGdsb2JhbHMgfTtcbmV4cG9ydCB7IHJnYiB9O1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBCYXNlRGVjb2RlciB9IGZyb20gJy4vY29tcHJlc3Npb24vYmFzZWRlY29kZXIuanMnO1xuZXhwb3J0IHsgZ2V0RGVjb2RlciwgYWRkRGVjb2RlciB9O1xuZXhwb3J0IHsgc2V0TG9nZ2VyIH07XG5cbi8qKlxuICogQHR5cGVkZWYge1VpbnQ4QXJyYXkgfCBJbnQ4QXJyYXkgfCBVaW50MTZBcnJheSB8IEludDE2QXJyYXkgfCBVaW50MzJBcnJheSB8IEludDMyQXJyYXkgfCBGbG9hdDMyQXJyYXkgfCBGbG9hdDY0QXJyYXl9XG4gKiBUeXBlZEFycmF5XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7eyBoZWlnaHQ6bnVtYmVyLCB3aWR0aDogbnVtYmVyIH19IERpbWVuc2lvbnNcbiAqL1xuXG4vKipcbiAqIFRoZSBhdXRvZ2VuZXJhdGVkIGRvY3MgYXJlIGEgbGl0dGxlIGNvbmZ1c2luZyBoZXJlLiBUaGUgZWZmZWN0aXZlIHR5cGUgaXM6XG4gKlxuICogYFR5cGVkQXJyYXkgJiB7IGhlaWdodDogbnVtYmVyOyB3aWR0aDogbnVtYmVyfWBcbiAqIEB0eXBlZGVmIHtUeXBlZEFycmF5ICYgRGltZW5zaW9uc30gVHlwZWRBcnJheVdpdGhEaW1lbnNpb25zXG4gKi9cblxuLyoqXG4gKiBUaGUgYXV0b2dlbmVyYXRlZCBkb2NzIGFyZSBhIGxpdHRsZSBjb25mdXNpbmcgaGVyZS4gVGhlIGVmZmVjdGl2ZSB0eXBlIGlzOlxuICpcbiAqIGBUeXBlZEFycmF5W10gJiB7IGhlaWdodDogbnVtYmVyOyB3aWR0aDogbnVtYmVyfWBcbiAqIEB0eXBlZGVmIHtUeXBlZEFycmF5W10gJiBEaW1lbnNpb25zfSBUeXBlZEFycmF5QXJyYXlXaXRoRGltZW5zaW9uc1xuICovXG5cbi8qKlxuICogIFRoZSBhdXRvZ2VuZXJhdGVkIGRvY3MgYXJlIGEgbGl0dGxlIGNvbmZ1c2luZyBoZXJlLiBUaGUgZWZmZWN0aXZlIHR5cGUgaXM6XG4gKlxuICogYChUeXBlZEFycmF5IHwgVHlwZWRBcnJheVtdKSAmIHsgaGVpZ2h0OiBudW1iZXI7IHdpZHRoOiBudW1iZXJ9YFxuICogQHR5cGVkZWYge1R5cGVkQXJyYXlXaXRoRGltZW5zaW9ucyB8IFR5cGVkQXJyYXlBcnJheVdpdGhEaW1lbnNpb25zfSBSZWFkUmFzdGVyUmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gZ2V0RmllbGRUeXBlTGVuZ3RoKGZpZWxkVHlwZSkge1xuICBzd2l0Y2ggKGZpZWxkVHlwZSkge1xuICAgIGNhc2UgZmllbGRUeXBlcy5CWVRFOiBjYXNlIGZpZWxkVHlwZXMuQVNDSUk6IGNhc2UgZmllbGRUeXBlcy5TQllURTogY2FzZSBmaWVsZFR5cGVzLlVOREVGSU5FRDpcbiAgICAgIHJldHVybiAxO1xuICAgIGNhc2UgZmllbGRUeXBlcy5TSE9SVDogY2FzZSBmaWVsZFR5cGVzLlNTSE9SVDpcbiAgICAgIHJldHVybiAyO1xuICAgIGNhc2UgZmllbGRUeXBlcy5MT05HOiBjYXNlIGZpZWxkVHlwZXMuU0xPTkc6IGNhc2UgZmllbGRUeXBlcy5GTE9BVDogY2FzZSBmaWVsZFR5cGVzLklGRDpcbiAgICAgIHJldHVybiA0O1xuICAgIGNhc2UgZmllbGRUeXBlcy5SQVRJT05BTDogY2FzZSBmaWVsZFR5cGVzLlNSQVRJT05BTDogY2FzZSBmaWVsZFR5cGVzLkRPVUJMRTpcbiAgICBjYXNlIGZpZWxkVHlwZXMuTE9ORzg6IGNhc2UgZmllbGRUeXBlcy5TTE9ORzg6IGNhc2UgZmllbGRUeXBlcy5JRkQ4OlxuICAgICAgcmV0dXJuIDg7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIGZpZWxkIHR5cGU6ICR7ZmllbGRUeXBlfWApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlR2VvS2V5RGlyZWN0b3J5KGZpbGVEaXJlY3RvcnkpIHtcbiAgY29uc3QgcmF3R2VvS2V5RGlyZWN0b3J5ID0gZmlsZURpcmVjdG9yeS5HZW9LZXlEaXJlY3Rvcnk7XG4gIGlmICghcmF3R2VvS2V5RGlyZWN0b3J5KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBnZW9LZXlEaXJlY3RvcnkgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDQ7IGkgPD0gcmF3R2VvS2V5RGlyZWN0b3J5WzNdICogNDsgaSArPSA0KSB7XG4gICAgY29uc3Qga2V5ID0gZ2VvS2V5TmFtZXNbcmF3R2VvS2V5RGlyZWN0b3J5W2ldXTtcbiAgICBjb25zdCBsb2NhdGlvbiA9IChyYXdHZW9LZXlEaXJlY3RvcnlbaSArIDFdKVxuICAgICAgPyAoZmllbGRUYWdOYW1lc1tyYXdHZW9LZXlEaXJlY3RvcnlbaSArIDFdXSkgOiBudWxsO1xuICAgIGNvbnN0IGNvdW50ID0gcmF3R2VvS2V5RGlyZWN0b3J5W2kgKyAyXTtcbiAgICBjb25zdCBvZmZzZXQgPSByYXdHZW9LZXlEaXJlY3RvcnlbaSArIDNdO1xuXG4gICAgbGV0IHZhbHVlID0gbnVsbDtcbiAgICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgICB2YWx1ZSA9IG9mZnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSBmaWxlRGlyZWN0b3J5W2xvY2F0aW9uXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGdldCB2YWx1ZSBvZiBnZW9LZXkgJyR7a2V5fScuYCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcob2Zmc2V0LCBvZmZzZXQgKyBjb3VudCAtIDEpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZS5zdWJhcnJheSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgY291bnQpO1xuICAgICAgICBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGdlb0tleURpcmVjdG9yeVtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGdlb0tleURpcmVjdG9yeTtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVzKGRhdGFTbGljZSwgZmllbGRUeXBlLCBjb3VudCwgb2Zmc2V0KSB7XG4gIGxldCB2YWx1ZXMgPSBudWxsO1xuICBsZXQgcmVhZE1ldGhvZCA9IG51bGw7XG4gIGNvbnN0IGZpZWxkVHlwZUxlbmd0aCA9IGdldEZpZWxkVHlwZUxlbmd0aChmaWVsZFR5cGUpO1xuXG4gIHN3aXRjaCAoZmllbGRUeXBlKSB7XG4gICAgY2FzZSBmaWVsZFR5cGVzLkJZVEU6IGNhc2UgZmllbGRUeXBlcy5BU0NJSTogY2FzZSBmaWVsZFR5cGVzLlVOREVGSU5FRDpcbiAgICAgIHZhbHVlcyA9IG5ldyBVaW50OEFycmF5KGNvdW50KTsgcmVhZE1ldGhvZCA9IGRhdGFTbGljZS5yZWFkVWludDg7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGZpZWxkVHlwZXMuU0JZVEU6XG4gICAgICB2YWx1ZXMgPSBuZXcgSW50OEFycmF5KGNvdW50KTsgcmVhZE1ldGhvZCA9IGRhdGFTbGljZS5yZWFkSW50ODtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmllbGRUeXBlcy5TSE9SVDpcbiAgICAgIHZhbHVlcyA9IG5ldyBVaW50MTZBcnJheShjb3VudCk7IHJlYWRNZXRob2QgPSBkYXRhU2xpY2UucmVhZFVpbnQxNjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmllbGRUeXBlcy5TU0hPUlQ6XG4gICAgICB2YWx1ZXMgPSBuZXcgSW50MTZBcnJheShjb3VudCk7IHJlYWRNZXRob2QgPSBkYXRhU2xpY2UucmVhZEludDE2O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBmaWVsZFR5cGVzLkxPTkc6IGNhc2UgZmllbGRUeXBlcy5JRkQ6XG4gICAgICB2YWx1ZXMgPSBuZXcgVWludDMyQXJyYXkoY291bnQpOyByZWFkTWV0aG9kID0gZGF0YVNsaWNlLnJlYWRVaW50MzI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGZpZWxkVHlwZXMuU0xPTkc6XG4gICAgICB2YWx1ZXMgPSBuZXcgSW50MzJBcnJheShjb3VudCk7IHJlYWRNZXRob2QgPSBkYXRhU2xpY2UucmVhZEludDMyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBmaWVsZFR5cGVzLkxPTkc4OiBjYXNlIGZpZWxkVHlwZXMuSUZEODpcbiAgICAgIHZhbHVlcyA9IG5ldyBBcnJheShjb3VudCk7IHJlYWRNZXRob2QgPSBkYXRhU2xpY2UucmVhZFVpbnQ2NDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmllbGRUeXBlcy5TTE9ORzg6XG4gICAgICB2YWx1ZXMgPSBuZXcgQXJyYXkoY291bnQpOyByZWFkTWV0aG9kID0gZGF0YVNsaWNlLnJlYWRJbnQ2NDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmllbGRUeXBlcy5SQVRJT05BTDpcbiAgICAgIHZhbHVlcyA9IG5ldyBVaW50MzJBcnJheShjb3VudCAqIDIpOyByZWFkTWV0aG9kID0gZGF0YVNsaWNlLnJlYWRVaW50MzI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGZpZWxkVHlwZXMuU1JBVElPTkFMOlxuICAgICAgdmFsdWVzID0gbmV3IEludDMyQXJyYXkoY291bnQgKiAyKTsgcmVhZE1ldGhvZCA9IGRhdGFTbGljZS5yZWFkSW50MzI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGZpZWxkVHlwZXMuRkxPQVQ6XG4gICAgICB2YWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KGNvdW50KTsgcmVhZE1ldGhvZCA9IGRhdGFTbGljZS5yZWFkRmxvYXQzMjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmllbGRUeXBlcy5ET1VCTEU6XG4gICAgICB2YWx1ZXMgPSBuZXcgRmxvYXQ2NEFycmF5KGNvdW50KTsgcmVhZE1ldGhvZCA9IGRhdGFTbGljZS5yZWFkRmxvYXQ2NDtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBmaWVsZCB0eXBlOiAke2ZpZWxkVHlwZX1gKTtcbiAgfVxuXG4gIC8vIG5vcm1hbCBmaWVsZHNcbiAgaWYgKCEoZmllbGRUeXBlID09PSBmaWVsZFR5cGVzLlJBVElPTkFMIHx8IGZpZWxkVHlwZSA9PT0gZmllbGRUeXBlcy5TUkFUSU9OQUwpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICB2YWx1ZXNbaV0gPSByZWFkTWV0aG9kLmNhbGwoXG4gICAgICAgIGRhdGFTbGljZSwgb2Zmc2V0ICsgKGkgKiBmaWVsZFR5cGVMZW5ndGgpLFxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7IC8vIFJBVElPTkFMIG9yIFNSQVRJT05BTFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkgKz0gMikge1xuICAgICAgdmFsdWVzW2ldID0gcmVhZE1ldGhvZC5jYWxsKFxuICAgICAgICBkYXRhU2xpY2UsIG9mZnNldCArIChpICogZmllbGRUeXBlTGVuZ3RoKSxcbiAgICAgICk7XG4gICAgICB2YWx1ZXNbaSArIDFdID0gcmVhZE1ldGhvZC5jYWxsKFxuICAgICAgICBkYXRhU2xpY2UsIG9mZnNldCArICgoaSAqIGZpZWxkVHlwZUxlbmd0aCkgKyA0KSxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGZpZWxkVHlwZSA9PT0gZmllbGRUeXBlcy5BU0NJSSkge1xuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoJ3V0Zi04JykuZGVjb2RlKHZhbHVlcyk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlcztcbn1cblxuLyoqXG4gKiBEYXRhIGNsYXNzIHRvIHN0b3JlIHRoZSBwYXJzZWQgZmlsZSBkaXJlY3RvcnksIGdlbyBrZXkgZGlyZWN0b3J5IGFuZFxuICogb2Zmc2V0IHRvIHRoZSBuZXh0IElGRFxuICovXG5jbGFzcyBJbWFnZUZpbGVEaXJlY3Rvcnkge1xuICBjb25zdHJ1Y3RvcihmaWxlRGlyZWN0b3J5LCBnZW9LZXlEaXJlY3RvcnksIG5leHRJRkRCeXRlT2Zmc2V0KSB7XG4gICAgdGhpcy5maWxlRGlyZWN0b3J5ID0gZmlsZURpcmVjdG9yeTtcbiAgICB0aGlzLmdlb0tleURpcmVjdG9yeSA9IGdlb0tleURpcmVjdG9yeTtcbiAgICB0aGlzLm5leHRJRkRCeXRlT2Zmc2V0ID0gbmV4dElGREJ5dGVPZmZzZXQ7XG4gIH1cbn1cblxuLyoqXG4gKiBFcnJvciBjbGFzcyBmb3IgY2FzZXMgd2hlbiBhbiBJRkQgaW5kZXggd2FzIHJlcXVlc3RlZCwgdGhhdCBkb2VzIG5vdCBleGlzdFxuICogaW4gdGhlIGZpbGUuXG4gKi9cbmNsYXNzIEdlb1RJRkZJbWFnZUluZGV4RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGluZGV4KSB7XG4gICAgc3VwZXIoYE5vIGltYWdlIGF0IGluZGV4ICR7aW5kZXh9YCk7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICB9XG59XG5cbmNsYXNzIEdlb1RJRkZCYXNlIHtcbiAgLyoqXG4gICAqIChleHBlcmltZW50YWwpIFJlYWRzIHJhc3RlciBkYXRhIGZyb20gdGhlIGJlc3QgZml0dGluZyBpbWFnZS4gVGhpcyBmdW5jdGlvbiB1c2VzXG4gICAqIHRoZSBpbWFnZSB3aXRoIHRoZSBsb3dlc3QgcmVzb2x1dGlvbiB0aGF0IGlzIHN0aWxsIGEgaGlnaGVyIHJlc29sdXRpb24gdGhhbiB0aGVcbiAgICogcmVxdWVzdGVkIHJlc29sdXRpb24uXG4gICAqIFdoZW4gc3BlY2lmaWVkLCB0aGUgYGJib3hgIG9wdGlvbiBpcyB0cmFuc2xhdGVkIHRvIHRoZSBgd2luZG93YCBvcHRpb24gYW5kIHRoZVxuICAgKiBgcmVzWGAgYW5kIGByZXNZYCB0byBgd2lkdGhgIGFuZCBgaGVpZ2h0YCByZXNwZWN0aXZlbHkuXG4gICAqIFRoZW4sIHRoZSBbcmVhZFJhc3RlcnNde0BsaW5rIEdlb1RJRkZJbWFnZSNyZWFkUmFzdGVyc30gbWV0aG9kIG9mIHRoZSBzZWxlY3RlZFxuICAgKiBpbWFnZSBpcyBjYWxsZWQgYW5kIHRoZSByZXN1bHQgcmV0dXJuZWQuXG4gICAqIEBzZWUgR2VvVElGRkltYWdlLnJlYWRSYXN0ZXJzXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuL2dlb3RpZmZpbWFnZScpLlJlYWRSYXN0ZXJPcHRpb25zfSBbb3B0aW9ucz17fV0gb3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZWFkUmFzdGVyUmVzdWx0Pn0gdGhlIGRlY29kZWQgYXJyYXkocyksIHdpdGggYGhlaWdodGAgYW5kIGB3aWR0aGAsIGFzIGEgcHJvbWlzZVxuICAgKi9cbiAgYXN5bmMgcmVhZFJhc3RlcnMob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyB3aW5kb3c6IGltYWdlV2luZG93LCB3aWR0aCwgaGVpZ2h0IH0gPSBvcHRpb25zO1xuICAgIGxldCB7IHJlc1gsIHJlc1ksIGJib3ggfSA9IG9wdGlvbnM7XG5cbiAgICBjb25zdCBmaXJzdEltYWdlID0gYXdhaXQgdGhpcy5nZXRJbWFnZSgpO1xuICAgIGxldCB1c2VkSW1hZ2UgPSBmaXJzdEltYWdlO1xuICAgIGNvbnN0IGltYWdlQ291bnQgPSBhd2FpdCB0aGlzLmdldEltYWdlQ291bnQoKTtcbiAgICBjb25zdCBpbWdCQm94ID0gZmlyc3RJbWFnZS5nZXRCb3VuZGluZ0JveCgpO1xuXG4gICAgaWYgKGltYWdlV2luZG93ICYmIGJib3gpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQm90aCBcImJib3hcIiBhbmQgXCJ3aW5kb3dcIiBwYXNzZWQuJyk7XG4gICAgfVxuXG4gICAgLy8gaWYgd2lkdGgvaGVpZ2h0IGlzIHBhc3NlZCwgdHJhbnNmb3JtIGl0IHRvIHJlc29sdXRpb25cbiAgICBpZiAod2lkdGggfHwgaGVpZ2h0KSB7XG4gICAgICAvLyBpZiB3ZSBoYXZlIGFuIGltYWdlIHdpbmRvdyAocGl4ZWwgY29vcmRpbmF0ZXMpLCB0cmFuc2Zvcm0gaXQgdG8gYSBCQm94XG4gICAgICAvLyB1c2luZyB0aGUgb3JpZ2luL3Jlc29sdXRpb24gb2YgdGhlIGZpcnN0IGltYWdlLlxuICAgICAgaWYgKGltYWdlV2luZG93KSB7XG4gICAgICAgIGNvbnN0IFtvWCwgb1ldID0gZmlyc3RJbWFnZS5nZXRPcmlnaW4oKTtcbiAgICAgICAgY29uc3QgW3JYLCByWV0gPSBmaXJzdEltYWdlLmdldFJlc29sdXRpb24oKTtcblxuICAgICAgICBiYm94ID0gW1xuICAgICAgICAgIG9YICsgKGltYWdlV2luZG93WzBdICogclgpLFxuICAgICAgICAgIG9ZICsgKGltYWdlV2luZG93WzFdICogclkpLFxuICAgICAgICAgIG9YICsgKGltYWdlV2luZG93WzJdICogclgpLFxuICAgICAgICAgIG9ZICsgKGltYWdlV2luZG93WzNdICogclkpLFxuICAgICAgICBdO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiB3ZSBoYXZlIGEgYmJveCAob3IgY2FsY3VsYXRlZCBvbmUpXG5cbiAgICAgIGNvbnN0IHVzZWRCQm94ID0gYmJveCB8fCBpbWdCQm94O1xuXG4gICAgICBpZiAod2lkdGgpIHtcbiAgICAgICAgaWYgKHJlc1gpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JvdGggd2lkdGggYW5kIHJlc1ggcGFzc2VkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzWCA9ICh1c2VkQkJveFsyXSAtIHVzZWRCQm94WzBdKSAvIHdpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKGhlaWdodCkge1xuICAgICAgICBpZiAocmVzWSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQm90aCB3aWR0aCBhbmQgcmVzWSBwYXNzZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXNZID0gKHVzZWRCQm94WzNdIC0gdXNlZEJCb3hbMV0pIC8gaGVpZ2h0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHJlc29sdXRpb24gaXMgc2V0IG9yIGNhbGN1bGF0ZWQsIHRyeSB0byBnZXQgdGhlIGltYWdlIHdpdGggdGhlIHdvcnN0IGFjY2VwdGFibGUgcmVzb2x1dGlvblxuICAgIGlmIChyZXNYIHx8IHJlc1kpIHtcbiAgICAgIGNvbnN0IGFsbEltYWdlcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbWFnZUNvdW50OyArK2kpIHtcbiAgICAgICAgY29uc3QgaW1hZ2UgPSBhd2FpdCB0aGlzLmdldEltYWdlKGkpO1xuICAgICAgICBjb25zdCB7IFN1YmZpbGVUeXBlOiBzdWJmaWxlVHlwZSwgTmV3U3ViZmlsZVR5cGU6IG5ld1N1YmZpbGVUeXBlIH0gPSBpbWFnZS5maWxlRGlyZWN0b3J5O1xuICAgICAgICBpZiAoaSA9PT0gMCB8fCBzdWJmaWxlVHlwZSA9PT0gMiB8fCBuZXdTdWJmaWxlVHlwZSAmIDEpIHtcbiAgICAgICAgICBhbGxJbWFnZXMucHVzaChpbWFnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYWxsSW1hZ2VzLnNvcnQoKGEsIGIpID0+IGEuZ2V0V2lkdGgoKSAtIGIuZ2V0V2lkdGgoKSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsbEltYWdlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBpbWFnZSA9IGFsbEltYWdlc1tpXTtcbiAgICAgICAgY29uc3QgaW1nUmVzWCA9IChpbWdCQm94WzJdIC0gaW1nQkJveFswXSkgLyBpbWFnZS5nZXRXaWR0aCgpO1xuICAgICAgICBjb25zdCBpbWdSZXNZID0gKGltZ0JCb3hbM10gLSBpbWdCQm94WzFdKSAvIGltYWdlLmdldEhlaWdodCgpO1xuXG4gICAgICAgIHVzZWRJbWFnZSA9IGltYWdlO1xuICAgICAgICBpZiAoKHJlc1ggJiYgcmVzWCA+IGltZ1Jlc1gpIHx8IChyZXNZICYmIHJlc1kgPiBpbWdSZXNZKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHduZCA9IGltYWdlV2luZG93O1xuICAgIGlmIChiYm94KSB7XG4gICAgICBjb25zdCBbb1gsIG9ZXSA9IGZpcnN0SW1hZ2UuZ2V0T3JpZ2luKCk7XG4gICAgICBjb25zdCBbaW1hZ2VSZXNYLCBpbWFnZVJlc1ldID0gdXNlZEltYWdlLmdldFJlc29sdXRpb24oZmlyc3RJbWFnZSk7XG5cbiAgICAgIHduZCA9IFtcbiAgICAgICAgTWF0aC5yb3VuZCgoYmJveFswXSAtIG9YKSAvIGltYWdlUmVzWCksXG4gICAgICAgIE1hdGgucm91bmQoKGJib3hbMV0gLSBvWSkgLyBpbWFnZVJlc1kpLFxuICAgICAgICBNYXRoLnJvdW5kKChiYm94WzJdIC0gb1gpIC8gaW1hZ2VSZXNYKSxcbiAgICAgICAgTWF0aC5yb3VuZCgoYmJveFszXSAtIG9ZKSAvIGltYWdlUmVzWSksXG4gICAgICBdO1xuICAgICAgd25kID0gW1xuICAgICAgICBNYXRoLm1pbih3bmRbMF0sIHduZFsyXSksXG4gICAgICAgIE1hdGgubWluKHduZFsxXSwgd25kWzNdKSxcbiAgICAgICAgTWF0aC5tYXgod25kWzBdLCB3bmRbMl0pLFxuICAgICAgICBNYXRoLm1heCh3bmRbMV0sIHduZFszXSksXG4gICAgICBdO1xuICAgIH1cblxuICAgIHJldHVybiB1c2VkSW1hZ2UucmVhZFJhc3RlcnMoeyAuLi5vcHRpb25zLCB3aW5kb3c6IHduZCB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEdlb1RJRkZPcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjYWNoZT1mYWxzZV0gd2hldGhlciBvciBub3QgZGVjb2RlZCB0aWxlcyBzaGFsbCBiZSBjYWNoZWQuXG4gKi9cblxuLyoqXG4gKiBUaGUgYWJzdHJhY3Rpb24gZm9yIGEgd2hvbGUgR2VvVElGRiBmaWxlLlxuICogQGF1Z21lbnRzIEdlb1RJRkZCYXNlXG4gKi9cbmNsYXNzIEdlb1RJRkYgZXh0ZW5kcyBHZW9USUZGQmFzZSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHsqfSBzb3VyY2UgVGhlIGRhdGFzb3VyY2UgdG8gcmVhZCBmcm9tLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxpdHRsZUVuZGlhbiBXaGV0aGVyIHRoZSBpbWFnZSB1c2VzIGxpdHRsZSBlbmRpYW4uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gYmlnVGlmZiBXaGV0aGVyIHRoZSBpbWFnZSB1c2VzIGJpZ1RJRkYgY29udmVudGlvbnMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmaXJzdElGRE9mZnNldCBUaGUgbnVtZXJpYyBieXRlLW9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgaW1hZ2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIHRoZSBmaXJzdCBJRkQuXG4gICAqIEBwYXJhbSB7R2VvVElGRk9wdGlvbnN9IFtvcHRpb25zXSBmdXJ0aGVyIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIGxpdHRsZUVuZGlhbiwgYmlnVGlmZiwgZmlyc3RJRkRPZmZzZXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5saXR0bGVFbmRpYW4gPSBsaXR0bGVFbmRpYW47XG4gICAgdGhpcy5iaWdUaWZmID0gYmlnVGlmZjtcbiAgICB0aGlzLmZpcnN0SUZET2Zmc2V0ID0gZmlyc3RJRkRPZmZzZXQ7XG4gICAgdGhpcy5jYWNoZSA9IG9wdGlvbnMuY2FjaGUgfHwgZmFsc2U7XG4gICAgdGhpcy5pZmRSZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMuZ2hvc3RWYWx1ZXMgPSBudWxsO1xuICB9XG5cbiAgYXN5bmMgZ2V0U2xpY2Uob2Zmc2V0LCBzaXplKSB7XG4gICAgY29uc3QgZmFsbGJhY2tTaXplID0gdGhpcy5iaWdUaWZmID8gNDA0OCA6IDEwMjQ7XG4gICAgcmV0dXJuIG5ldyBEYXRhU2xpY2UoXG4gICAgICAoYXdhaXQgdGhpcy5zb3VyY2UuZmV0Y2goW3tcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBsZW5ndGg6IHR5cGVvZiBzaXplICE9PSAndW5kZWZpbmVkJyA/IHNpemUgOiBmYWxsYmFja1NpemUsXG4gICAgICB9XSkpWzBdLFxuICAgICAgb2Zmc2V0LFxuICAgICAgdGhpcy5saXR0bGVFbmRpYW4sXG4gICAgICB0aGlzLmJpZ1RpZmYsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnN0cnVjdHMgdG8gcGFyc2UgYW4gaW1hZ2UgZmlsZSBkaXJlY3RvcnkgYXQgdGhlIGdpdmVuIGZpbGUgb2Zmc2V0LlxuICAgKiBBcyB0aGVyZSBpcyBubyB3YXkgdG8gZW5zdXJlIHRoYXQgYSBsb2NhdGlvbiBpcyBpbmRlZWQgdGhlIHN0YXJ0IG9mIGFuIElGRCxcbiAgICogdGhpcyBmdW5jdGlvbiBtdXN0IGJlIGNhbGxlZCB3aXRoIGNhdXRpb24gKGUuZyBvbmx5IHVzaW5nIHRoZSBJRkQgb2Zmc2V0cyBmcm9tXG4gICAqIHRoZSBoZWFkZXJzIG9yIG90aGVyIElGRHMpLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IHRoZSBvZmZzZXQgdG8gcGFyc2UgdGhlIElGRCBhdFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxJbWFnZUZpbGVEaXJlY3Rvcnk+fSB0aGUgcGFyc2VkIElGRFxuICAgKi9cbiAgYXN5bmMgcGFyc2VGaWxlRGlyZWN0b3J5QXQob2Zmc2V0KSB7XG4gICAgY29uc3QgZW50cnlTaXplID0gdGhpcy5iaWdUaWZmID8gMjAgOiAxMjtcbiAgICBjb25zdCBvZmZzZXRTaXplID0gdGhpcy5iaWdUaWZmID8gOCA6IDI7XG5cbiAgICBsZXQgZGF0YVNsaWNlID0gYXdhaXQgdGhpcy5nZXRTbGljZShvZmZzZXQpO1xuICAgIGNvbnN0IG51bURpckVudHJpZXMgPSB0aGlzLmJpZ1RpZmZcbiAgICAgID8gZGF0YVNsaWNlLnJlYWRVaW50NjQob2Zmc2V0KVxuICAgICAgOiBkYXRhU2xpY2UucmVhZFVpbnQxNihvZmZzZXQpO1xuXG4gICAgLy8gaWYgdGhlIHNsaWNlIGRvZXMgbm90IGNvdmVyIHRoZSB3aG9sZSBJRkQsIHJlcXVlc3QgYSBiaWdnZXIgc2xpY2UsIHdoZXJlIHRoZVxuICAgIC8vIHdob2xlIElGRCBmaXRzOiBudW0gb2YgZW50cmllcyArIG4geCB0YWcgbGVuZ3RoICsgb2Zmc2V0IHRvIG5leHQgSUZEXG4gICAgY29uc3QgYnl0ZVNpemUgPSAobnVtRGlyRW50cmllcyAqIGVudHJ5U2l6ZSkgKyAodGhpcy5iaWdUaWZmID8gMTYgOiA2KTtcbiAgICBpZiAoIWRhdGFTbGljZS5jb3ZlcnMob2Zmc2V0LCBieXRlU2l6ZSkpIHtcbiAgICAgIGRhdGFTbGljZSA9IGF3YWl0IHRoaXMuZ2V0U2xpY2Uob2Zmc2V0LCBieXRlU2l6ZSk7XG4gICAgfVxuXG4gICAgY29uc3QgZmlsZURpcmVjdG9yeSA9IHt9O1xuXG4gICAgLy8gbG9vcCBvdmVyIHRoZSBJRkQgYW5kIGNyZWF0ZSBhIGZpbGUgZGlyZWN0b3J5IG9iamVjdFxuICAgIGxldCBpID0gb2Zmc2V0ICsgKHRoaXMuYmlnVGlmZiA/IDggOiAyKTtcbiAgICBmb3IgKGxldCBlbnRyeUNvdW50ID0gMDsgZW50cnlDb3VudCA8IG51bURpckVudHJpZXM7IGkgKz0gZW50cnlTaXplLCArK2VudHJ5Q291bnQpIHtcbiAgICAgIGNvbnN0IGZpZWxkVGFnID0gZGF0YVNsaWNlLnJlYWRVaW50MTYoaSk7XG4gICAgICBjb25zdCBmaWVsZFR5cGUgPSBkYXRhU2xpY2UucmVhZFVpbnQxNihpICsgMik7XG4gICAgICBjb25zdCB0eXBlQ291bnQgPSB0aGlzLmJpZ1RpZmZcbiAgICAgICAgPyBkYXRhU2xpY2UucmVhZFVpbnQ2NChpICsgNClcbiAgICAgICAgOiBkYXRhU2xpY2UucmVhZFVpbnQzMihpICsgNCk7XG5cbiAgICAgIGxldCBmaWVsZFZhbHVlcztcbiAgICAgIGxldCB2YWx1ZTtcbiAgICAgIGNvbnN0IGZpZWxkVHlwZUxlbmd0aCA9IGdldEZpZWxkVHlwZUxlbmd0aChmaWVsZFR5cGUpO1xuICAgICAgY29uc3QgdmFsdWVPZmZzZXQgPSBpICsgKHRoaXMuYmlnVGlmZiA/IDEyIDogOCk7XG5cbiAgICAgIC8vIGNoZWNrIHdoZXRoZXIgdGhlIHZhbHVlIGlzIGRpcmVjdGx5IGVuY29kZWQgaW4gdGhlIHRhZyBvciByZWZlcnMgdG8gYVxuICAgICAgLy8gZGlmZmVyZW50IGV4dGVybmFsIGJ5dGUgcmFuZ2VcbiAgICAgIGlmIChmaWVsZFR5cGVMZW5ndGggKiB0eXBlQ291bnQgPD0gKHRoaXMuYmlnVGlmZiA/IDggOiA0KSkge1xuICAgICAgICBmaWVsZFZhbHVlcyA9IGdldFZhbHVlcyhkYXRhU2xpY2UsIGZpZWxkVHlwZSwgdHlwZUNvdW50LCB2YWx1ZU9mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZXNvbHZlIHRoZSByZWZlcmVuY2UgdG8gdGhlIGFjdHVhbCBieXRlIHJhbmdlXG4gICAgICAgIGNvbnN0IGFjdHVhbE9mZnNldCA9IGRhdGFTbGljZS5yZWFkT2Zmc2V0KHZhbHVlT2Zmc2V0KTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZ2V0RmllbGRUeXBlTGVuZ3RoKGZpZWxkVHlwZSkgKiB0eXBlQ291bnQ7XG5cbiAgICAgICAgLy8gY2hlY2ssIHdoZXRoZXIgd2UgYWN0dWFsbHkgY292ZXIgdGhlIHJlZmVyZW5jZWQgYnl0ZSByYW5nZTsgaWYgbm90LFxuICAgICAgICAvLyByZXF1ZXN0IGEgbmV3IHNsaWNlIG9mIGJ5dGVzIHRvIHJlYWQgZnJvbSBpdFxuICAgICAgICBpZiAoZGF0YVNsaWNlLmNvdmVycyhhY3R1YWxPZmZzZXQsIGxlbmd0aCkpIHtcbiAgICAgICAgICBmaWVsZFZhbHVlcyA9IGdldFZhbHVlcyhkYXRhU2xpY2UsIGZpZWxkVHlwZSwgdHlwZUNvdW50LCBhY3R1YWxPZmZzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGZpZWxkRGF0YVNsaWNlID0gYXdhaXQgdGhpcy5nZXRTbGljZShhY3R1YWxPZmZzZXQsIGxlbmd0aCk7XG4gICAgICAgICAgZmllbGRWYWx1ZXMgPSBnZXRWYWx1ZXMoZmllbGREYXRhU2xpY2UsIGZpZWxkVHlwZSwgdHlwZUNvdW50LCBhY3R1YWxPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHVucGFjayBzaW5nbGUgdmFsdWVzIGZyb20gdGhlIGFycmF5XG4gICAgICBpZiAodHlwZUNvdW50ID09PSAxICYmIGFycmF5RmllbGRzLmluZGV4T2YoZmllbGRUYWcpID09PSAtMVxuICAgICAgICAmJiAhKGZpZWxkVHlwZSA9PT0gZmllbGRUeXBlcy5SQVRJT05BTCB8fCBmaWVsZFR5cGUgPT09IGZpZWxkVHlwZXMuU1JBVElPTkFMKSkge1xuICAgICAgICB2YWx1ZSA9IGZpZWxkVmFsdWVzWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBmaWVsZFZhbHVlcztcbiAgICAgIH1cblxuICAgICAgLy8gd3JpdGUgdGhlIHRhZ3MgdmFsdWUgdG8gdGhlIGZpbGUgZGlyZWN0bHlcbiAgICAgIGZpbGVEaXJlY3RvcnlbZmllbGRUYWdOYW1lc1tmaWVsZFRhZ11dID0gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IGdlb0tleURpcmVjdG9yeSA9IHBhcnNlR2VvS2V5RGlyZWN0b3J5KGZpbGVEaXJlY3RvcnkpO1xuICAgIGNvbnN0IG5leHRJRkRCeXRlT2Zmc2V0ID0gZGF0YVNsaWNlLnJlYWRPZmZzZXQoXG4gICAgICBvZmZzZXQgKyBvZmZzZXRTaXplICsgKGVudHJ5U2l6ZSAqIG51bURpckVudHJpZXMpLFxuICAgICk7XG5cbiAgICByZXR1cm4gbmV3IEltYWdlRmlsZURpcmVjdG9yeShcbiAgICAgIGZpbGVEaXJlY3RvcnksXG4gICAgICBnZW9LZXlEaXJlY3RvcnksXG4gICAgICBuZXh0SUZEQnl0ZU9mZnNldCxcbiAgICApO1xuICB9XG5cbiAgYXN5bmMgcmVxdWVzdElGRChpbmRleCkge1xuICAgIC8vIHNlZSBpZiB3ZSBhbHJlYWR5IGhhdmUgdGhhdCBJRkQgaW5kZXggcmVxdWVzdGVkLlxuICAgIGlmICh0aGlzLmlmZFJlcXVlc3RzW2luZGV4XSkge1xuICAgICAgLy8gYXR0YWNoIHRvIGFuIGFscmVhZHkgcmVxdWVzdGVkIElGRFxuICAgICAgcmV0dXJuIHRoaXMuaWZkUmVxdWVzdHNbaW5kZXhdO1xuICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3IgaW5kZXggMFxuICAgICAgdGhpcy5pZmRSZXF1ZXN0c1tpbmRleF0gPSB0aGlzLnBhcnNlRmlsZURpcmVjdG9yeUF0KHRoaXMuZmlyc3RJRkRPZmZzZXQpO1xuICAgICAgcmV0dXJuIHRoaXMuaWZkUmVxdWVzdHNbaW5kZXhdO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuaWZkUmVxdWVzdHNbaW5kZXggLSAxXSkge1xuICAgICAgLy8gaWYgdGhlIHByZXZpb3VzIElGRCB3YXMgbm90IHlldCBsb2FkZWQsIGxvYWQgdGhhdCBvbmUgZmlyc3RcbiAgICAgIC8vIHRoaXMgaXMgdGhlIHJlY3Vyc2l2ZSBjYWxsLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5pZmRSZXF1ZXN0c1tpbmRleCAtIDFdID0gdGhpcy5yZXF1ZXN0SUZEKGluZGV4IC0gMSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGlmIHRoZSBwcmV2aW91cyBvbmUgYWxyZWFkeSB3YXMgYW4gaW5kZXggZXJyb3IsIHJldGhyb3dcbiAgICAgICAgLy8gd2l0aCB0aGUgY3VycmVudCBpbmRleFxuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEdlb1RJRkZJbWFnZUluZGV4RXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgR2VvVElGRkltYWdlSW5kZXhFcnJvcihpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV0aHJvdyBhbnl0aGluZyBlbHNlXG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGlmIHRoZSBwcmV2aW91cyBJRkQgd2FzIGxvYWRlZCwgd2UgY2FuIGZpbmFsbHkgZmV0Y2ggdGhlIG9uZSB3ZSBhcmUgaW50ZXJlc3RlZCBpbi5cbiAgICAvLyB3ZSBuZWVkIHRvIHdyYXAgdGhpcyBpbiBhbiBJSUZFLCBvdGhlcndpc2UgdGhpcy5pZmRSZXF1ZXN0c1tpbmRleF0gd291bGQgYmUgZGVsYXllZFxuICAgIHRoaXMuaWZkUmVxdWVzdHNbaW5kZXhdID0gKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHByZXZpb3VzSWZkID0gYXdhaXQgdGhpcy5pZmRSZXF1ZXN0c1tpbmRleCAtIDFdO1xuICAgICAgaWYgKHByZXZpb3VzSWZkLm5leHRJRkRCeXRlT2Zmc2V0ID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBHZW9USUZGSW1hZ2VJbmRleEVycm9yKGluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRmlsZURpcmVjdG9yeUF0KHByZXZpb3VzSWZkLm5leHRJRkRCeXRlT2Zmc2V0KTtcbiAgICB9KSgpO1xuICAgIHJldHVybiB0aGlzLmlmZFJlcXVlc3RzW2luZGV4XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG4tdGggaW50ZXJuYWwgc3ViZmlsZSBvZiBhbiBpbWFnZS4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGlzIHJldHVybmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4PTBdIHRoZSBpbmRleCBvZiB0aGUgaW1hZ2UgdG8gcmV0dXJuLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHZW9USUZGSW1hZ2U+fSB0aGUgaW1hZ2UgYXQgdGhlIGdpdmVuIGluZGV4XG4gICAqL1xuICBhc3luYyBnZXRJbWFnZShpbmRleCA9IDApIHtcbiAgICBjb25zdCBpZmQgPSBhd2FpdCB0aGlzLnJlcXVlc3RJRkQoaW5kZXgpO1xuICAgIHJldHVybiBuZXcgR2VvVElGRkltYWdlKFxuICAgICAgaWZkLmZpbGVEaXJlY3RvcnksIGlmZC5nZW9LZXlEaXJlY3RvcnksXG4gICAgICB0aGlzLmRhdGFWaWV3LCB0aGlzLmxpdHRsZUVuZGlhbiwgdGhpcy5jYWNoZSwgdGhpcy5zb3VyY2UsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb3VudCBvZiB0aGUgaW50ZXJuYWwgc3ViZmlsZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcj59IHRoZSBudW1iZXIgb2YgaW50ZXJuYWwgc3ViZmlsZSBpbWFnZXNcbiAgICovXG4gIGFzeW5jIGdldEltYWdlQ291bnQoKSB7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICAvLyBsb29wIHVudGlsIHdlIHJ1biBvdXQgb2YgSUZEc1xuICAgIGxldCBoYXNOZXh0ID0gdHJ1ZTtcbiAgICB3aGlsZSAoaGFzTmV4dCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5yZXF1ZXN0SUZEKGluZGV4KTtcbiAgICAgICAgKytpbmRleDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBHZW9USUZGSW1hZ2VJbmRleEVycm9yKSB7XG4gICAgICAgICAgaGFzTmV4dCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWVzIG9mIHRoZSBDT0cgZ2hvc3QgYXJlYSBhcyBhIHBhcnNlZCBtYXAuXG4gICAqIFNlZSBodHRwczovL2dkYWwub3JnL2RyaXZlcnMvcmFzdGVyL2NvZy5odG1sI2hlYWRlci1naG9zdC1hcmVhIGZvciByZWZlcmVuY2VcbiAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gdGhlIHBhcnNlZCBnaG9zdCBhcmVhIG9yIG51bGwsIGlmIG5vIHN1Y2ggYXJlYSB3YXMgZm91bmRcbiAgICovXG4gIGFzeW5jIGdldEdob3N0VmFsdWVzKCkge1xuICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuYmlnVGlmZiA/IDE2IDogODtcbiAgICBpZiAodGhpcy5naG9zdFZhbHVlcykge1xuICAgICAgcmV0dXJuIHRoaXMuZ2hvc3RWYWx1ZXM7XG4gICAgfVxuICAgIGNvbnN0IGRldGVjdGlvblN0cmluZyA9ICdHREFMX1NUUlVDVFVSQUxfTUVUQURBVEFfU0laRT0nO1xuICAgIGNvbnN0IGhldXJpc3RpY0FyZWFTaXplID0gZGV0ZWN0aW9uU3RyaW5nLmxlbmd0aCArIDEwMDtcbiAgICBsZXQgc2xpY2UgPSBhd2FpdCB0aGlzLmdldFNsaWNlKG9mZnNldCwgaGV1cmlzdGljQXJlYVNpemUpO1xuICAgIGlmIChkZXRlY3Rpb25TdHJpbmcgPT09IGdldFZhbHVlcyhzbGljZSwgZmllbGRUeXBlcy5BU0NJSSwgZGV0ZWN0aW9uU3RyaW5nLmxlbmd0aCwgb2Zmc2V0KSkge1xuICAgICAgY29uc3QgdmFsdWVzU3RyaW5nID0gZ2V0VmFsdWVzKHNsaWNlLCBmaWVsZFR5cGVzLkFTQ0lJLCBoZXVyaXN0aWNBcmVhU2l6ZSwgb2Zmc2V0KTtcbiAgICAgIGNvbnN0IGZpcnN0TGluZSA9IHZhbHVlc1N0cmluZy5zcGxpdCgnXFxuJylbMF07XG4gICAgICBjb25zdCBtZXRhZGF0YVNpemUgPSBOdW1iZXIoZmlyc3RMaW5lLnNwbGl0KCc9JylbMV0uc3BsaXQoJyAnKVswXSkgKyBmaXJzdExpbmUubGVuZ3RoO1xuICAgICAgaWYgKG1ldGFkYXRhU2l6ZSA+IGhldXJpc3RpY0FyZWFTaXplKSB7XG4gICAgICAgIHNsaWNlID0gYXdhaXQgdGhpcy5nZXRTbGljZShvZmZzZXQsIG1ldGFkYXRhU2l6ZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBmdWxsU3RyaW5nID0gZ2V0VmFsdWVzKHNsaWNlLCBmaWVsZFR5cGVzLkFTQ0lJLCBtZXRhZGF0YVNpemUsIG9mZnNldCk7XG4gICAgICB0aGlzLmdob3N0VmFsdWVzID0ge307XG4gICAgICBmdWxsU3RyaW5nXG4gICAgICAgIC5zcGxpdCgnXFxuJylcbiAgICAgICAgLmZpbHRlcigobGluZSkgPT4gbGluZS5sZW5ndGggPiAwKVxuICAgICAgICAubWFwKChsaW5lKSA9PiBsaW5lLnNwbGl0KCc9JykpXG4gICAgICAgIC5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICB0aGlzLmdob3N0VmFsdWVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdob3N0VmFsdWVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgKEdlbylUSUZGIGZpbGUgZnJvbSB0aGUgZ2l2ZW4gc291cmNlLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHNvdXJjZSBUaGUgc291cmNlIG9mIGRhdGEgdG8gcGFyc2UgZnJvbS5cbiAgICogQHBhcmFtIHtHZW9USUZGT3B0aW9uc30gW29wdGlvbnNdIEFkZGl0aW9uYWwgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gW3NpZ25hbF0gQW4gQWJvcnRTaWduYWwgdGhhdCBtYXkgYmUgc2lnbmFsbGVkIGlmIHRoZSByZXF1ZXN0IGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGJlIGFib3J0ZWRcbiAgICovXG4gIHN0YXRpYyBhc3luYyBmcm9tU291cmNlKHNvdXJjZSwgb3B0aW9ucywgc2lnbmFsKSB7XG4gICAgY29uc3QgaGVhZGVyRGF0YSA9IChhd2FpdCBzb3VyY2UuZmV0Y2goW3sgb2Zmc2V0OiAwLCBsZW5ndGg6IDEwMjQgfV0sIHNpZ25hbCkpWzBdO1xuICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3NjQoaGVhZGVyRGF0YSk7XG5cbiAgICBjb25zdCBCT00gPSBkYXRhVmlldy5nZXRVaW50MTYoMCwgMCk7XG4gICAgbGV0IGxpdHRsZUVuZGlhbjtcbiAgICBpZiAoQk9NID09PSAweDQ5NDkpIHtcbiAgICAgIGxpdHRsZUVuZGlhbiA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChCT00gPT09IDB4NEQ0RCkge1xuICAgICAgbGl0dGxlRW5kaWFuID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYnl0ZSBvcmRlciB2YWx1ZS4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBtYWdpY051bWJlciA9IGRhdGFWaWV3LmdldFVpbnQxNigyLCBsaXR0bGVFbmRpYW4pO1xuICAgIGxldCBiaWdUaWZmO1xuICAgIGlmIChtYWdpY051bWJlciA9PT0gNDIpIHtcbiAgICAgIGJpZ1RpZmYgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKG1hZ2ljTnVtYmVyID09PSA0Mykge1xuICAgICAgYmlnVGlmZiA9IHRydWU7XG4gICAgICBjb25zdCBvZmZzZXRCeXRlU2l6ZSA9IGRhdGFWaWV3LmdldFVpbnQxNig0LCBsaXR0bGVFbmRpYW4pO1xuICAgICAgaWYgKG9mZnNldEJ5dGVTaXplICE9PSA4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgb2Zmc2V0IGJ5dGUtc2l6ZS4nKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtYWdpYyBudW1iZXIuJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZmlyc3RJRkRPZmZzZXQgPSBiaWdUaWZmXG4gICAgICA/IGRhdGFWaWV3LmdldFVpbnQ2NCg4LCBsaXR0bGVFbmRpYW4pXG4gICAgICA6IGRhdGFWaWV3LmdldFVpbnQzMig0LCBsaXR0bGVFbmRpYW4pO1xuICAgIHJldHVybiBuZXcgR2VvVElGRihzb3VyY2UsIGxpdHRsZUVuZGlhbiwgYmlnVGlmZiwgZmlyc3RJRkRPZmZzZXQsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgdW5kZXJseWluZyBmaWxlIGJ1ZmZlclxuICAgKiBOLkIuIEFmdGVyIHRoZSBHZW9USUZGIGhhcyBiZWVuIGNvbXBsZXRlbHkgcHJvY2Vzc2VkIGl0IG5lZWRzXG4gICAqIHRvIGJlIGNsb3NlZCBidXQgb25seSBpZiBpdCBoYXMgYmVlbiBjb25zdHJ1Y3RlZCBmcm9tIGEgZmlsZS5cbiAgICovXG4gIGNsb3NlKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5zb3VyY2UuY2xvc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5jbG9zZSgpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IHsgR2VvVElGRiB9O1xuZXhwb3J0IGRlZmF1bHQgR2VvVElGRjtcblxuLyoqXG4gKiBXcmFwcGVyIGZvciBHZW9USUZGIGZpbGVzIHRoYXQgaGF2ZSBleHRlcm5hbCBvdmVydmlld3MuXG4gKiBAYXVnbWVudHMgR2VvVElGRkJhc2VcbiAqL1xuY2xhc3MgTXVsdGlHZW9USUZGIGV4dGVuZHMgR2VvVElGRkJhc2Uge1xuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IE11bHRpR2VvVElGRiBmcm9tIGEgbWFpbiBhbmQgc2V2ZXJhbCBvdmVydmlldyBmaWxlcy5cbiAgICogQHBhcmFtIHtHZW9USUZGfSBtYWluRmlsZSBUaGUgbWFpbiBHZW9USUZGIGZpbGUuXG4gICAqIEBwYXJhbSB7R2VvVElGRltdfSBvdmVydmlld0ZpbGVzIEFuIGFycmF5IG9mIG92ZXJ2aWV3IGZpbGVzLlxuICAgKi9cbiAgY29uc3RydWN0b3IobWFpbkZpbGUsIG92ZXJ2aWV3RmlsZXMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubWFpbkZpbGUgPSBtYWluRmlsZTtcbiAgICB0aGlzLm92ZXJ2aWV3RmlsZXMgPSBvdmVydmlld0ZpbGVzO1xuICAgIHRoaXMuaW1hZ2VGaWxlcyA9IFttYWluRmlsZV0uY29uY2F0KG92ZXJ2aWV3RmlsZXMpO1xuXG4gICAgdGhpcy5maWxlRGlyZWN0b3JpZXNQZXJGaWxlID0gbnVsbDtcbiAgICB0aGlzLmZpbGVEaXJlY3Rvcmllc1BlckZpbGVQYXJzaW5nID0gbnVsbDtcbiAgICB0aGlzLmltYWdlQ291bnQgPSBudWxsO1xuICB9XG5cbiAgYXN5bmMgcGFyc2VGaWxlRGlyZWN0b3JpZXNQZXJGaWxlKCkge1xuICAgIGNvbnN0IHJlcXVlc3RzID0gW3RoaXMubWFpbkZpbGUucGFyc2VGaWxlRGlyZWN0b3J5QXQodGhpcy5tYWluRmlsZS5maXJzdElGRE9mZnNldCldXG4gICAgICAuY29uY2F0KHRoaXMub3ZlcnZpZXdGaWxlcy5tYXAoKGZpbGUpID0+IGZpbGUucGFyc2VGaWxlRGlyZWN0b3J5QXQoZmlsZS5maXJzdElGRE9mZnNldCkpKTtcblxuICAgIHRoaXMuZmlsZURpcmVjdG9yaWVzUGVyRmlsZSA9IGF3YWl0IFByb21pc2UuYWxsKHJlcXVlc3RzKTtcbiAgICByZXR1cm4gdGhpcy5maWxlRGlyZWN0b3JpZXNQZXJGaWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbi10aCBpbnRlcm5hbCBzdWJmaWxlIG9mIGFuIGltYWdlLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgaXMgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXg9MF0gdGhlIGluZGV4IG9mIHRoZSBpbWFnZSB0byByZXR1cm4uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEdlb1RJRkZJbWFnZT59IHRoZSBpbWFnZSBhdCB0aGUgZ2l2ZW4gaW5kZXhcbiAgICovXG4gIGFzeW5jIGdldEltYWdlKGluZGV4ID0gMCkge1xuICAgIGF3YWl0IHRoaXMuZ2V0SW1hZ2VDb3VudCgpO1xuICAgIGF3YWl0IHRoaXMucGFyc2VGaWxlRGlyZWN0b3JpZXNQZXJGaWxlKCk7XG4gICAgbGV0IHZpc2l0ZWQgPSAwO1xuICAgIGxldCByZWxhdGl2ZUluZGV4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW1hZ2VGaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaW1hZ2VGaWxlID0gdGhpcy5pbWFnZUZpbGVzW2ldO1xuICAgICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IHRoaXMuaW1hZ2VDb3VudHNbaV07IGlpKyspIHtcbiAgICAgICAgaWYgKGluZGV4ID09PSB2aXNpdGVkKSB7XG4gICAgICAgICAgY29uc3QgaWZkID0gYXdhaXQgaW1hZ2VGaWxlLnJlcXVlc3RJRkQocmVsYXRpdmVJbmRleCk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBHZW9USUZGSW1hZ2UoXG4gICAgICAgICAgICBpZmQuZmlsZURpcmVjdG9yeSwgaWZkLmdlb0tleURpcmVjdG9yeSxcbiAgICAgICAgICAgIGltYWdlRmlsZS5kYXRhVmlldywgaW1hZ2VGaWxlLmxpdHRsZUVuZGlhbiwgaW1hZ2VGaWxlLmNhY2hlLCBpbWFnZUZpbGUuc291cmNlLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmlzaXRlZCsrO1xuICAgICAgICByZWxhdGl2ZUluZGV4Kys7XG4gICAgICB9XG4gICAgICByZWxhdGl2ZUluZGV4ID0gMDtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBpbWFnZSBpbmRleCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvdW50IG9mIHRoZSBpbnRlcm5hbCBzdWJmaWxlcy5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyPn0gdGhlIG51bWJlciBvZiBpbnRlcm5hbCBzdWJmaWxlIGltYWdlc1xuICAgKi9cbiAgYXN5bmMgZ2V0SW1hZ2VDb3VudCgpIHtcbiAgICBpZiAodGhpcy5pbWFnZUNvdW50ICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbWFnZUNvdW50O1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0cyA9IFt0aGlzLm1haW5GaWxlLmdldEltYWdlQ291bnQoKV1cbiAgICAgIC5jb25jYXQodGhpcy5vdmVydmlld0ZpbGVzLm1hcCgoZmlsZSkgPT4gZmlsZS5nZXRJbWFnZUNvdW50KCkpKTtcbiAgICB0aGlzLmltYWdlQ291bnRzID0gYXdhaXQgUHJvbWlzZS5hbGwocmVxdWVzdHMpO1xuICAgIHRoaXMuaW1hZ2VDb3VudCA9IHRoaXMuaW1hZ2VDb3VudHMucmVkdWNlKChjb3VudCwgaWZkcykgPT4gY291bnQgKyBpZmRzLCAwKTtcbiAgICByZXR1cm4gdGhpcy5pbWFnZUNvdW50O1xuICB9XG59XG5cbmV4cG9ydCB7IE11bHRpR2VvVElGRiB9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgR2VvVElGRiBmcm9tIGEgcmVtb3RlIFVSTC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byBhY2Nlc3MgdGhlIGltYWdlIGZyb21cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIHNvdXJjZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlIHtAbGluayBtYWtlUmVtb3RlU291cmNlfSBmb3IgZGV0YWlscy5cbiAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IFtzaWduYWxdIEFuIEFib3J0U2lnbmFsIHRoYXQgbWF5IGJlIHNpZ25hbGxlZCBpZiB0aGUgcmVxdWVzdCBpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYmUgYWJvcnRlZFxuICogQHJldHVybnMge1Byb21pc2U8R2VvVElGRj59IFRoZSByZXN1bHRpbmcgR2VvVElGRiBmaWxlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZnJvbVVybCh1cmwsIG9wdGlvbnMgPSB7fSwgc2lnbmFsKSB7XG4gIHJldHVybiBHZW9USUZGLmZyb21Tb3VyY2UobWFrZVJlbW90ZVNvdXJjZSh1cmwsIG9wdGlvbnMpLCBzaWduYWwpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgR2VvVElGRiBmcm9tIGEgY3VzdG9tIHtAbGluayBCYXNlQ2xpZW50fS5cbiAqIEBwYXJhbSB7QmFzZUNsaWVudH0gY2xpZW50IFRoZSBjbGllbnQuXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBzb3VyY2UuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZSB7QGxpbmsgbWFrZVJlbW90ZVNvdXJjZX0gZm9yIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Fib3J0U2lnbmFsfSBbc2lnbmFsXSBBbiBBYm9ydFNpZ25hbCB0aGF0IG1heSBiZSBzaWduYWxsZWQgaWYgdGhlIHJlcXVlc3QgaXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGJlIGFib3J0ZWRcbiAqIEByZXR1cm5zIHtQcm9taXNlPEdlb1RJRkY+fSBUaGUgcmVzdWx0aW5nIEdlb1RJRkYgZmlsZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZyb21DdXN0b21DbGllbnQoY2xpZW50LCBvcHRpb25zID0ge30sIHNpZ25hbCkge1xuICByZXR1cm4gR2VvVElGRi5mcm9tU291cmNlKG1ha2VDdXN0b21Tb3VyY2UoY2xpZW50LCBvcHRpb25zKSwgc2lnbmFsKTtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3QgYSBuZXcgR2VvVElGRiBmcm9tIGFuXG4gKiBbQXJyYXlCdWZmZXJde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5QnVmZmVyfS5cbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBkYXRhIHRvIHJlYWQgdGhlIGZpbGUgZnJvbS5cbiAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IFtzaWduYWxdIEFuIEFib3J0U2lnbmFsIHRoYXQgbWF5IGJlIHNpZ25hbGxlZCBpZiB0aGUgcmVxdWVzdCBpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYmUgYWJvcnRlZFxuICogQHJldHVybnMge1Byb21pc2U8R2VvVElGRj59IFRoZSByZXN1bHRpbmcgR2VvVElGRiBmaWxlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyKGFycmF5QnVmZmVyLCBzaWduYWwpIHtcbiAgcmV0dXJuIEdlb1RJRkYuZnJvbVNvdXJjZShtYWtlQnVmZmVyU291cmNlKGFycmF5QnVmZmVyKSwgc2lnbmFsKTtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3QgYSBHZW9USUZGIGZyb20gYSBsb2NhbCBmaWxlIHBhdGguIFRoaXMgdXNlcyB0aGUgbm9kZVxuICogW2ZpbGVzeXN0ZW0gQVBJXXtAbGluayBodHRwczovL25vZGVqcy5vcmcvYXBpL2ZzLmh0bWx9IGFuZCBpc1xuICogbm90IGF2YWlsYWJsZSBvbiBicm93c2Vycy5cbiAqXG4gKiBOLkIuIEFmdGVyIHRoZSBHZW9USUZGIGhhcyBiZWVuIGNvbXBsZXRlbHkgcHJvY2Vzc2VkIGl0IG5lZWRzXG4gKiB0byBiZSBjbG9zZWQgYnV0IG9ubHkgaWYgaXQgaGFzIGJlZW4gY29uc3RydWN0ZWQgZnJvbSBhIGZpbGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgZmlsZSBwYXRoIHRvIHJlYWQgZnJvbS5cbiAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IFtzaWduYWxdIEFuIEFib3J0U2lnbmFsIHRoYXQgbWF5IGJlIHNpZ25hbGxlZCBpZiB0aGUgcmVxdWVzdCBpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYmUgYWJvcnRlZFxuICogQHJldHVybnMge1Byb21pc2U8R2VvVElGRj59IFRoZSByZXN1bHRpbmcgR2VvVElGRiBmaWxlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZnJvbUZpbGUocGF0aCwgc2lnbmFsKSB7XG4gIHJldHVybiBHZW9USUZGLmZyb21Tb3VyY2UobWFrZUZpbGVTb3VyY2UocGF0aCksIHNpZ25hbCk7XG59XG5cbi8qKlxuICogQ29uc3RydWN0IGEgR2VvVElGRiBmcm9tIGFuIEhUTUxcbiAqIFtCbG9iXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQmxvYn0gb3JcbiAqIFtGaWxlXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRmlsZX1cbiAqIG9iamVjdC5cbiAqIEBwYXJhbSB7QmxvYnxGaWxlfSBibG9iIFRoZSBCbG9iIG9yIEZpbGUgb2JqZWN0IHRvIHJlYWQgZnJvbS5cbiAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IFtzaWduYWxdIEFuIEFib3J0U2lnbmFsIHRoYXQgbWF5IGJlIHNpZ25hbGxlZCBpZiB0aGUgcmVxdWVzdCBpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYmUgYWJvcnRlZFxuICogQHJldHVybnMge1Byb21pc2U8R2VvVElGRj59IFRoZSByZXN1bHRpbmcgR2VvVElGRiBmaWxlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZnJvbUJsb2IoYmxvYiwgc2lnbmFsKSB7XG4gIHJldHVybiBHZW9USUZGLmZyb21Tb3VyY2UobWFrZUZpbGVSZWFkZXJTb3VyY2UoYmxvYiksIHNpZ25hbCk7XG59XG5cbi8qKlxuICogQ29uc3RydWN0IGEgTXVsdGlHZW9USUZGIGZyb20gdGhlIGdpdmVuIFVSTHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFpblVybCBUaGUgVVJMIGZvciB0aGUgbWFpbiBmaWxlLlxuICogQHBhcmFtIHtzdHJpbmdbXX0gb3ZlcnZpZXdVcmxzIEFuIGFycmF5IG9mIFVSTHMgZm9yIHRoZSBvdmVydmlldyBpbWFnZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBzb3VyY2UuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZSBbbWFrZVJlbW90ZVNvdXJjZV17QGxpbmsgbW9kdWxlOnNvdXJjZS5tYWtlUmVtb3RlU291cmNlfVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgZGV0YWlscy5cbiAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IFtzaWduYWxdIEFuIEFib3J0U2lnbmFsIHRoYXQgbWF5IGJlIHNpZ25hbGxlZCBpZiB0aGUgcmVxdWVzdCBpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYmUgYWJvcnRlZFxuICogQHJldHVybnMge1Byb21pc2U8TXVsdGlHZW9USUZGPn0gVGhlIHJlc3VsdGluZyBNdWx0aUdlb1RJRkYgZmlsZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZyb21VcmxzKG1haW5VcmwsIG92ZXJ2aWV3VXJscyA9IFtdLCBvcHRpb25zID0ge30sIHNpZ25hbCkge1xuICBjb25zdCBtYWluRmlsZSA9IGF3YWl0IEdlb1RJRkYuZnJvbVNvdXJjZShtYWtlUmVtb3RlU291cmNlKG1haW5VcmwsIG9wdGlvbnMpLCBzaWduYWwpO1xuICBjb25zdCBvdmVydmlld0ZpbGVzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgb3ZlcnZpZXdVcmxzLm1hcCgodXJsKSA9PiBHZW9USUZGLmZyb21Tb3VyY2UobWFrZVJlbW90ZVNvdXJjZSh1cmwsIG9wdGlvbnMpKSksXG4gICk7XG5cbiAgcmV0dXJuIG5ldyBNdWx0aUdlb1RJRkYobWFpbkZpbGUsIG92ZXJ2aWV3RmlsZXMpO1xufVxuXG4vKipcbiAqIE1haW4gY3JlYXRpbmcgZnVuY3Rpb24gZm9yIEdlb1RJRkYgZmlsZXMuXG4gKiBAcGFyYW0geyhBcnJheSl9IGFycmF5IG9mIHBpeGVsIHZhbHVlc1xuICogQHJldHVybnMge21ldGFkYXRhfSBtZXRhZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JpdGVBcnJheUJ1ZmZlcih2YWx1ZXMsIG1ldGFkYXRhKSB7XG4gIHJldHVybiB3cml0ZUdlb3RpZmYodmFsdWVzLCBtZXRhZGF0YSk7XG59XG5cbmV4cG9ydCB7IFBvb2wgfTtcbmV4cG9ydCB7IEdlb1RJRkZJbWFnZSB9O1xuZXhwb3J0IHsgQmFzZUNsaWVudCwgQmFzZVJlc3BvbnNlIH07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/geotiff.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/geotiffimage.js":
/*!**********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/geotiffimage.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _petamoriken_float16__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @petamoriken/float16 */ \"./node_modules/@petamoriken/float16/browser/float16.js\");\n/* harmony import */ var _petamoriken_float16__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_petamoriken_float16__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var xml_utils_get_attribute_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! xml-utils/get-attribute.js */ \"./node_modules/xml-utils/get-attribute.js\");\n/* harmony import */ var xml_utils_get_attribute_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(xml_utils_get_attribute_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var xml_utils_find_tags_by_name_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! xml-utils/find-tags-by-name.js */ \"./node_modules/xml-utils/find-tags-by-name.js\");\n/* harmony import */ var xml_utils_find_tags_by_name_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(xml_utils_find_tags_by_name_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./globals.js */ \"./node_modules/geotiff/dist-module/globals.js\");\n/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rgb.js */ \"./node_modules/geotiff/dist-module/rgb.js\");\n/* harmony import */ var _compression_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./compression/index.js */ \"./node_modules/geotiff/dist-module/compression/index.js\");\n/* harmony import */ var _resample_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./resample.js */ \"./node_modules/geotiff/dist-module/resample.js\");\n/** @module geotiffimage */\n\n\n\n\n\n\n\n\n\n/**\n * @typedef {Object} ReadRasterOptions\n * @property {Array<number>} [window=whole window] the subset to read data from in pixels.\n * @property {Array<number>} [bbox=whole image] the subset to read data from in\n *                                           geographical coordinates.\n * @property {Array<number>} [samples=all samples] the selection of samples to read from. Default is all samples.\n * @property {boolean} [interleave=false] whether the data shall be read\n *                                             in one single array or separate\n *                                             arrays.\n * @property {Pool} [pool=null] The optional decoder pool to use.\n * @property {number} [width] The desired width of the output. When the width is not the\n *                                 same as the images, resampling will be performed.\n * @property {number} [height] The desired height of the output. When the width is not the\n *                                  same as the images, resampling will be performed.\n * @property {string} [resampleMethod='nearest'] The desired resampling method.\n * @property {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                                       to be aborted\n * @property {number|number[]} [fillValue] The value to use for parts of the image\n *                                              outside of the images extent. When multiple\n *                                              samples are requested, an array of fill values\n *                                              can be passed.\n */\n\n/** @typedef {import(\"./geotiff.js\").TypedArray} TypedArray */\n/** @typedef {import(\"./geotiff.js\").ReadRasterResult} ReadRasterResult */\n\nfunction sum(array, start, end) {\n  let s = 0;\n  for (let i = start; i < end; ++i) {\n    s += array[i];\n  }\n  return s;\n}\n\nfunction arrayForType(format, bitsPerSample, size) {\n  switch (format) {\n    case 1: // unsigned integer data\n      if (bitsPerSample <= 8) {\n        return new Uint8Array(size);\n      } else if (bitsPerSample <= 16) {\n        return new Uint16Array(size);\n      } else if (bitsPerSample <= 32) {\n        return new Uint32Array(size);\n      }\n      break;\n    case 2: // twos complement signed integer data\n      if (bitsPerSample === 8) {\n        return new Int8Array(size);\n      } else if (bitsPerSample === 16) {\n        return new Int16Array(size);\n      } else if (bitsPerSample === 32) {\n        return new Int32Array(size);\n      }\n      break;\n    case 3: // floating point data\n      switch (bitsPerSample) {\n        case 16:\n        case 32:\n          return new Float32Array(size);\n        case 64:\n          return new Float64Array(size);\n        default:\n          break;\n      }\n      break;\n    default:\n      break;\n  }\n  throw Error('Unsupported data format/bitsPerSample');\n}\n\nfunction needsNormalization(format, bitsPerSample) {\n  if ((format === 1 || format === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) {\n    return false;\n  } else if (format === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) {\n    return false;\n  }\n  return true;\n}\n\nfunction normalizeArray(inBuffer, format, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {\n  // const inByteArray = new Uint8Array(inBuffer);\n  const view = new DataView(inBuffer);\n  const outSize = planarConfiguration === 2\n    ? tileHeight * tileWidth\n    : tileHeight * tileWidth * samplesPerPixel;\n  const samplesToTransfer = planarConfiguration === 2\n    ? 1 : samplesPerPixel;\n  const outArray = arrayForType(format, bitsPerSample, outSize);\n  // let pixel = 0;\n\n  const bitMask = parseInt('1'.repeat(bitsPerSample), 2);\n\n  if (format === 1) { // unsigned integer\n    // translation of https://github.com/OSGeo/gdal/blob/master/gdal/frmts/gtiff/geotiff.cpp#L7337\n    let pixelBitSkip;\n    // let sampleBitOffset = 0;\n    if (planarConfiguration === 1) {\n      pixelBitSkip = samplesPerPixel * bitsPerSample;\n      // sampleBitOffset = (samplesPerPixel - 1) * bitsPerSample;\n    } else {\n      pixelBitSkip = bitsPerSample;\n    }\n\n    // Bits per line rounds up to next byte boundary.\n    let bitsPerLine = tileWidth * pixelBitSkip;\n    if ((bitsPerLine & 7) !== 0) {\n      bitsPerLine = (bitsPerLine + 7) & (~7);\n    }\n\n    for (let y = 0; y < tileHeight; ++y) {\n      const lineBitOffset = y * bitsPerLine;\n      for (let x = 0; x < tileWidth; ++x) {\n        const pixelBitOffset = lineBitOffset + (x * samplesToTransfer * bitsPerSample);\n        for (let i = 0; i < samplesToTransfer; ++i) {\n          const bitOffset = pixelBitOffset + (i * bitsPerSample);\n          const outIndex = (((y * tileWidth) + x) * samplesToTransfer) + i;\n\n          const byteOffset = Math.floor(bitOffset / 8);\n          const innerBitOffset = bitOffset % 8;\n          if (innerBitOffset + bitsPerSample <= 8) {\n            outArray[outIndex] = (view.getUint8(byteOffset) >> (8 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 16) {\n            outArray[outIndex] = (view.getUint16(byteOffset) >> (16 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 24) {\n            const raw = (view.getUint16(byteOffset) << 8) | (view.getUint8(byteOffset + 2));\n            outArray[outIndex] = (raw >> (24 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else {\n            outArray[outIndex] = (view.getUint32(byteOffset) >> (32 - bitsPerSample) - innerBitOffset) & bitMask;\n          }\n\n          // let outWord = 0;\n          // for (let bit = 0; bit < bitsPerSample; ++bit) {\n          //   if (inByteArray[bitOffset >> 3]\n          //     & (0x80 >> (bitOffset & 7))) {\n          //     outWord |= (1 << (bitsPerSample - 1 - bit));\n          //   }\n          //   ++bitOffset;\n          // }\n\n          // outArray[outIndex] = outWord;\n          // outArray[pixel] = outWord;\n          // pixel += 1;\n        }\n        // bitOffset = bitOffset + pixelBitSkip - bitsPerSample;\n      }\n    }\n  } else if (format === 3) { // floating point\n    // Float16 is handled elsewhere\n    // normalize 16/24 bit floats to 32 bit floats in the array\n    // console.time();\n    // if (bitsPerSample === 16) {\n    //   for (let byte = 0, outIndex = 0; byte < inBuffer.byteLength; byte += 2, ++outIndex) {\n    //     outArray[outIndex] = getFloat16(view, byte);\n    //   }\n    // }\n    // console.timeEnd()\n  }\n\n  return outArray.buffer;\n}\n\n/**\n * GeoTIFF sub-file image.\n */\nclass GeoTIFFImage {\n  /**\n   * @constructor\n   * @param {Object} fileDirectory The parsed file directory\n   * @param {Object} geoKeys The parsed geo-keys\n   * @param {DataView} dataView The DataView for the underlying file.\n   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian\n   * @param {Boolean} cache Whether or not decoded tiles shall be cached\n   * @param {import('./source/basesource').BaseSource} source The datasource to read from\n   */\n  constructor(fileDirectory, geoKeys, dataView, littleEndian, cache, source) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeys = geoKeys;\n    this.dataView = dataView;\n    this.littleEndian = littleEndian;\n    this.tiles = cache ? {} : null;\n    this.isTiled = !fileDirectory.StripOffsets;\n    const planarConfiguration = fileDirectory.PlanarConfiguration;\n    this.planarConfiguration = (typeof planarConfiguration === 'undefined') ? 1 : planarConfiguration;\n    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {\n      throw new Error('Invalid planar configuration.');\n    }\n\n    this.source = source;\n  }\n\n  /**\n   * Returns the associated parsed file directory.\n   * @returns {Object} the parsed file directory\n   */\n  getFileDirectory() {\n    return this.fileDirectory;\n  }\n\n  /**\n   * Returns the associated parsed geo keys.\n   * @returns {Object} the parsed geo keys\n   */\n  getGeoKeys() {\n    return this.geoKeys;\n  }\n\n  /**\n   * Returns the width of the image.\n   * @returns {Number} the width of the image\n   */\n  getWidth() {\n    return this.fileDirectory.ImageWidth;\n  }\n\n  /**\n   * Returns the height of the image.\n   * @returns {Number} the height of the image\n   */\n  getHeight() {\n    return this.fileDirectory.ImageLength;\n  }\n\n  /**\n   * Returns the number of samples per pixel.\n   * @returns {Number} the number of samples per pixel\n   */\n  getSamplesPerPixel() {\n    return typeof this.fileDirectory.SamplesPerPixel !== 'undefined'\n      ? this.fileDirectory.SamplesPerPixel : 1;\n  }\n\n  /**\n   * Returns the width of each tile.\n   * @returns {Number} the width of each tile\n   */\n  getTileWidth() {\n    return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();\n  }\n\n  /**\n   * Returns the height of each tile.\n   * @returns {Number} the height of each tile\n   */\n  getTileHeight() {\n    if (this.isTiled) {\n      return this.fileDirectory.TileLength;\n    }\n    if (typeof this.fileDirectory.RowsPerStrip !== 'undefined') {\n      return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());\n    }\n    return this.getHeight();\n  }\n\n  getBlockWidth() {\n    return this.getTileWidth();\n  }\n\n  getBlockHeight(y) {\n    if (this.isTiled || (y + 1) * this.getTileHeight() <= this.getHeight()) {\n      return this.getTileHeight();\n    } else {\n      return this.getHeight() - (y * this.getTileHeight());\n    }\n  }\n\n  /**\n   * Calculates the number of bytes for each pixel across all samples. Only full\n   * bytes are supported, an exception is thrown when this is not the case.\n   * @returns {Number} the bytes per pixel\n   */\n  getBytesPerPixel() {\n    let bytes = 0;\n    for (let i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {\n      bytes += this.getSampleByteSize(i);\n    }\n    return bytes;\n  }\n\n  getSampleByteSize(i) {\n    if (i >= this.fileDirectory.BitsPerSample.length) {\n      throw new RangeError(`Sample index ${i} is out of range.`);\n    }\n    return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8);\n  }\n\n  getReaderForSample(sampleIndex) {\n    const format = this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n    const bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];\n    switch (format) {\n      case 1: // unsigned integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getUint8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getUint16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getUint32;\n        }\n        break;\n      case 2: // twos complement signed integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getInt8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getInt16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getInt32;\n        }\n        break;\n      case 3:\n        switch (bitsPerSample) {\n          case 16:\n            return function (offset, littleEndian) {\n              return Object(_petamoriken_float16__WEBPACK_IMPORTED_MODULE_0__[\"getFloat16\"])(this, offset, littleEndian);\n            };\n          case 32:\n            return DataView.prototype.getFloat32;\n          case 64:\n            return DataView.prototype.getFloat64;\n          default:\n            break;\n        }\n        break;\n      default:\n        break;\n    }\n    throw Error('Unsupported data format/bitsPerSample');\n  }\n\n  getSampleFormat(sampleIndex = 0) {\n    return this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n  }\n\n  getBitsPerSample(sampleIndex = 0) {\n    return this.fileDirectory.BitsPerSample[sampleIndex];\n  }\n\n  getArrayForSample(sampleIndex, size) {\n    const format = this.getSampleFormat(sampleIndex);\n    const bitsPerSample = this.getBitsPerSample(sampleIndex);\n    return arrayForType(format, bitsPerSample, size);\n  }\n\n  /**\n   * Returns the decoded strip or tile.\n   * @param {Number} x the strip or tile x-offset\n   * @param {Number} y the tile y-offset (0 for stripped images)\n   * @param {Number} sample the sample to get for separated samples\n   * @param {import(\"./geotiff\").Pool|import(\"./geotiff\").BaseDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise.<ArrayBuffer>}\n   */\n  async getTileOrStrip(x, y, sample, poolOrDecoder, signal) {\n    const numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());\n    const numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());\n    let index;\n    const { tiles } = this;\n    if (this.planarConfiguration === 1) {\n      index = (y * numTilesPerRow) + x;\n    } else if (this.planarConfiguration === 2) {\n      index = (sample * numTilesPerRow * numTilesPerCol) + (y * numTilesPerRow) + x;\n    }\n\n    let offset;\n    let byteCount;\n    if (this.isTiled) {\n      offset = this.fileDirectory.TileOffsets[index];\n      byteCount = this.fileDirectory.TileByteCounts[index];\n    } else {\n      offset = this.fileDirectory.StripOffsets[index];\n      byteCount = this.fileDirectory.StripByteCounts[index];\n    }\n    const slice = (await this.source.fetch([{ offset, length: byteCount }], signal))[0];\n\n    let request;\n    if (tiles === null || !tiles[index]) {\n    // resolve each request by potentially applying array normalization\n      request = (async () => {\n        let data = await poolOrDecoder.decode(this.fileDirectory, slice);\n        const sampleFormat = this.getSampleFormat();\n        const bitsPerSample = this.getBitsPerSample();\n        if (needsNormalization(sampleFormat, bitsPerSample)) {\n          data = normalizeArray(\n            data,\n            sampleFormat,\n            this.planarConfiguration,\n            this.getSamplesPerPixel(),\n            bitsPerSample,\n            this.getTileWidth(),\n            this.getBlockHeight(y),\n          );\n        }\n        return data;\n      })();\n\n      // set the cache\n      if (tiles !== null) {\n        tiles[index] = request;\n      }\n    } else {\n      // get from the cache\n      request = tiles[index];\n    }\n\n    // cache the tile request\n    return { x, y, sample, data: await request };\n  }\n\n  /**\n   * Internal read function.\n   * @private\n   * @param {Array} imageWindow The image window in pixel coordinates\n   * @param {Array} samples The selected samples (0-based indices)\n   * @param {TypedArray|TypedArray[]} valueArrays The array(s) to write into\n   * @param {Boolean} interleave Whether or not to write in an interleaved manner\n   * @param {import(\"./geotiff\").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {number} width the width of window to be read into\n   * @param {number} height the height of window to be read into\n   * @param {number} resampleMethod the resampling method to be used when interpolating\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise<ReadRasterResult>}\n   */\n  async _readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width,\n    height, resampleMethod, signal) {\n    const tileWidth = this.getTileWidth();\n    const tileHeight = this.getTileHeight();\n    const imageWidth = this.getWidth();\n    const imageHeight = this.getHeight();\n\n    const minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);\n    const maxXTile = Math.min(\n      Math.ceil(imageWindow[2] / tileWidth),\n      Math.ceil(imageWidth / tileWidth),\n    );\n    const minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);\n    const maxYTile = Math.min(\n      Math.ceil(imageWindow[3] / tileHeight),\n      Math.ceil(imageHeight / tileHeight),\n    );\n    const windowWidth = imageWindow[2] - imageWindow[0];\n\n    let bytesPerPixel = this.getBytesPerPixel();\n\n    const srcSampleOffsets = [];\n    const sampleReaders = [];\n    for (let i = 0; i < samples.length; ++i) {\n      if (this.planarConfiguration === 1) {\n        srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8);\n      } else {\n        srcSampleOffsets.push(0);\n      }\n      sampleReaders.push(this.getReaderForSample(samples[i]));\n    }\n\n    const promises = [];\n    const { littleEndian } = this;\n\n    for (let yTile = minYTile; yTile < maxYTile; ++yTile) {\n      for (let xTile = minXTile; xTile < maxXTile; ++xTile) {\n        let getPromise;\n        if (this.planarConfiguration === 1) {\n          getPromise = this.getTileOrStrip(xTile, yTile, 0, poolOrDecoder, signal);\n        }\n        for (let sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex) {\n          const si = sampleIndex;\n          const sample = samples[sampleIndex];\n          if (this.planarConfiguration === 2) {\n            bytesPerPixel = this.getSampleByteSize(sample);\n            getPromise = this.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal);\n          }\n          const promise = getPromise.then((tile) => {\n            const buffer = tile.data;\n            const dataView = new DataView(buffer);\n            const blockHeight = this.getBlockHeight(tile.y);\n            const firstLine = tile.y * tileHeight;\n            const firstCol = tile.x * tileWidth;\n            const lastLine = firstLine + blockHeight;\n            const lastCol = (tile.x + 1) * tileWidth;\n            const reader = sampleReaders[si];\n\n            const ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]), imageHeight - firstLine);\n            const xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]), imageWidth - firstCol);\n\n            for (let y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y) {\n              for (let x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x) {\n                const pixelOffset = ((y * tileWidth) + x) * bytesPerPixel;\n                const value = reader.call(\n                  dataView, pixelOffset + srcSampleOffsets[si], littleEndian,\n                );\n                let windowCoordinate;\n                if (interleave) {\n                  windowCoordinate = ((y + firstLine - imageWindow[1]) * windowWidth * samples.length)\n                    + ((x + firstCol - imageWindow[0]) * samples.length)\n                    + si;\n                  valueArrays[windowCoordinate] = value;\n                } else {\n                  windowCoordinate = (\n                    (y + firstLine - imageWindow[1]) * windowWidth\n                  ) + x + firstCol - imageWindow[0];\n                  valueArrays[si][windowCoordinate] = value;\n                }\n              }\n            }\n          });\n          promises.push(promise);\n        }\n      }\n    }\n    await Promise.all(promises);\n\n    if ((width && (imageWindow[2] - imageWindow[0]) !== width)\n        || (height && (imageWindow[3] - imageWindow[1]) !== height)) {\n      let resampled;\n      if (interleave) {\n        resampled = Object(_resample_js__WEBPACK_IMPORTED_MODULE_6__[\"resampleInterleaved\"])(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          samples.length,\n          resampleMethod,\n        );\n      } else {\n        resampled = Object(_resample_js__WEBPACK_IMPORTED_MODULE_6__[\"resample\"])(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          resampleMethod,\n        );\n      }\n      resampled.width = width;\n      resampled.height = height;\n      return resampled;\n    }\n\n    valueArrays.width = width || imageWindow[2] - imageWindow[0];\n    valueArrays.height = height || imageWindow[3] - imageWindow[1];\n\n    return valueArrays;\n  }\n\n  /**\n   * Reads raster data from the image. This function reads all selected samples\n   * into separate arrays of the correct type for that sample or into a single\n   * combined array when `interleave` is set. When provided, only a subset\n   * of the raster is read for each sample.\n   *\n   * @param {ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded arrays as a promise\n   */\n  async readRasters({\n    window: wnd, samples = [], interleave, pool = null,\n    width, height, resampleMethod, fillValue, signal,\n  } = {}) {\n    const imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const imageWindowWidth = imageWindow[2] - imageWindow[0];\n    const imageWindowHeight = imageWindow[3] - imageWindow[1];\n    const numPixels = imageWindowWidth * imageWindowHeight;\n    const samplesPerPixel = this.getSamplesPerPixel();\n\n    if (!samples || !samples.length) {\n      for (let i = 0; i < samplesPerPixel; ++i) {\n        samples.push(i);\n      }\n    } else {\n      for (let i = 0; i < samples.length; ++i) {\n        if (samples[i] >= samplesPerPixel) {\n          return Promise.reject(new RangeError(`Invalid sample index '${samples[i]}'.`));\n        }\n      }\n    }\n    let valueArrays;\n    if (interleave) {\n      const format = this.fileDirectory.SampleFormat\n        ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;\n      const bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);\n      valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);\n      if (fillValue) {\n        valueArrays.fill(fillValue);\n      }\n    } else {\n      valueArrays = [];\n      for (let i = 0; i < samples.length; ++i) {\n        const valueArray = this.getArrayForSample(samples[i], numPixels);\n        if (Array.isArray(fillValue) && i < fillValue.length) {\n          valueArray.fill(fillValue[i]);\n        } else if (fillValue && !Array.isArray(fillValue)) {\n          valueArray.fill(fillValue);\n        }\n        valueArrays.push(valueArray);\n      }\n    }\n\n    const poolOrDecoder = pool || await Object(_compression_index_js__WEBPACK_IMPORTED_MODULE_5__[\"getDecoder\"])(this.fileDirectory);\n\n    const result = await this._readRaster(\n      imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal,\n    );\n    return result;\n  }\n\n  /**\n   * Reads raster data from the image as RGB. The result is always an\n   * interleaved typed array.\n   * Colorspaces other than RGB will be transformed to RGB, color maps expanded.\n   * When no other method is applicable, the first sample is used to produce a\n   * grayscale image.\n   * When provided, only a subset of the raster is read for each sample.\n   *\n   * @param {Object} [options] optional parameters\n   * @param {Array<number>} [options.window] the subset to read data from in pixels.\n   * @param {boolean} [options.interleave=true] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {import(\"./geotiff\").Pool} [options.pool=null] The optional decoder pool to use.\n   * @param {number} [options.width] The desired width of the output. When the width is no the\n   *                                 same as the images, resampling will be performed.\n   * @param {number} [options.height] The desired height of the output. When the width is no the\n   *                                  same as the images, resampling will be performed.\n   * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {boolean} [options.enableAlpha=false] Enable reading alpha channel if present.\n   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n   *                                       to be aborted\n   * @returns {Promise<ReadRasterResult>} the RGB array as a Promise\n   */\n  async readRGB({ window, interleave = true, pool = null, width, height,\n    resampleMethod, enableAlpha = false, signal } = {}) {\n    const imageWindow = window || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const pi = this.fileDirectory.PhotometricInterpretation;\n\n    if (pi === _globals_js__WEBPACK_IMPORTED_MODULE_3__[\"photometricInterpretations\"].RGB) {\n      let s = [0, 1, 2];\n      if ((!(this.fileDirectory.ExtraSamples === _globals_js__WEBPACK_IMPORTED_MODULE_3__[\"ExtraSamplesValues\"].Unspecified)) && enableAlpha) {\n        s = [];\n        for (let i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1) {\n          s.push(i);\n        }\n      }\n      return this.readRasters({\n        window,\n        interleave,\n        samples: s,\n        pool,\n        width,\n        height,\n        resampleMethod,\n        signal,\n      });\n    }\n\n    let samples;\n    switch (pi) {\n      case _globals_js__WEBPACK_IMPORTED_MODULE_3__[\"photometricInterpretations\"].WhiteIsZero:\n      case _globals_js__WEBPACK_IMPORTED_MODULE_3__[\"photometricInterpretations\"].BlackIsZero:\n      case _globals_js__WEBPACK_IMPORTED_MODULE_3__[\"photometricInterpretations\"].Palette:\n        samples = [0];\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_3__[\"photometricInterpretations\"].CMYK:\n        samples = [0, 1, 2, 3];\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_3__[\"photometricInterpretations\"].YCbCr:\n      case _globals_js__WEBPACK_IMPORTED_MODULE_3__[\"photometricInterpretations\"].CIELab:\n        samples = [0, 1, 2];\n        break;\n      default:\n        throw new Error('Invalid or unsupported photometric interpretation.');\n    }\n\n    const subOptions = {\n      window: imageWindow,\n      interleave: true,\n      samples,\n      pool,\n      width,\n      height,\n      resampleMethod,\n      signal,\n    };\n    const { fileDirectory } = this;\n    const raster = await this.readRasters(subOptions);\n\n    const max = 2 ** this.fileDirectory.BitsPerSample[0];\n    let data;\n    switch (pi) {\n      case _globals_js__WEBPACK_IMPORTED_MODULE_3__[\"photometricInterpretations\"].WhiteIsZero:\n        data = Object(_rgb_js__WEBPACK_IMPORTED_MODULE_4__[\"fromWhiteIsZero\"])(raster, max);\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_3__[\"photometricInterpretations\"].BlackIsZero:\n        data = Object(_rgb_js__WEBPACK_IMPORTED_MODULE_4__[\"fromBlackIsZero\"])(raster, max);\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_3__[\"photometricInterpretations\"].Palette:\n        data = Object(_rgb_js__WEBPACK_IMPORTED_MODULE_4__[\"fromPalette\"])(raster, fileDirectory.ColorMap);\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_3__[\"photometricInterpretations\"].CMYK:\n        data = Object(_rgb_js__WEBPACK_IMPORTED_MODULE_4__[\"fromCMYK\"])(raster);\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_3__[\"photometricInterpretations\"].YCbCr:\n        data = Object(_rgb_js__WEBPACK_IMPORTED_MODULE_4__[\"fromYCbCr\"])(raster);\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_3__[\"photometricInterpretations\"].CIELab:\n        data = Object(_rgb_js__WEBPACK_IMPORTED_MODULE_4__[\"fromCIELab\"])(raster);\n        break;\n      default:\n        throw new Error('Unsupported photometric interpretation.');\n    }\n\n    // if non-interleaved data is requested, we must split the channels\n    // into their respective arrays\n    if (!interleave) {\n      const red = new Uint8Array(data.length / 3);\n      const green = new Uint8Array(data.length / 3);\n      const blue = new Uint8Array(data.length / 3);\n      for (let i = 0, j = 0; i < data.length; i += 3, ++j) {\n        red[j] = data[i];\n        green[j] = data[i + 1];\n        blue[j] = data[i + 2];\n      }\n      data = [red, green, blue];\n    }\n\n    data.width = raster.width;\n    data.height = raster.height;\n    return data;\n  }\n\n  /**\n   * Returns an array of tiepoints.\n   * @returns {Object[]}\n   */\n  getTiePoints() {\n    if (!this.fileDirectory.ModelTiepoint) {\n      return [];\n    }\n\n    const tiePoints = [];\n    for (let i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {\n      tiePoints.push({\n        i: this.fileDirectory.ModelTiepoint[i],\n        j: this.fileDirectory.ModelTiepoint[i + 1],\n        k: this.fileDirectory.ModelTiepoint[i + 2],\n        x: this.fileDirectory.ModelTiepoint[i + 3],\n        y: this.fileDirectory.ModelTiepoint[i + 4],\n        z: this.fileDirectory.ModelTiepoint[i + 5],\n      });\n    }\n    return tiePoints;\n  }\n\n  /**\n   * Returns the parsed GDAL metadata items.\n   *\n   * If sample is passed to null, dataset-level metadata will be returned.\n   * Otherwise only metadata specific to the provided sample will be returned.\n   *\n   * @param {number} [sample=null] The sample index.\n   * @returns {Object}\n   */\n  getGDALMetadata(sample = null) {\n    const metadata = {};\n    if (!this.fileDirectory.GDAL_METADATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_METADATA;\n\n    let items = xml_utils_find_tags_by_name_js__WEBPACK_IMPORTED_MODULE_2___default()(string, 'Item');\n\n    if (sample === null) {\n      items = items.filter((item) => xml_utils_get_attribute_js__WEBPACK_IMPORTED_MODULE_1___default()(item, 'sample') === undefined);\n    } else {\n      items = items.filter((item) => Number(xml_utils_get_attribute_js__WEBPACK_IMPORTED_MODULE_1___default()(item, 'sample')) === sample);\n    }\n\n    for (let i = 0; i < items.length; ++i) {\n      const item = items[i];\n      metadata[xml_utils_get_attribute_js__WEBPACK_IMPORTED_MODULE_1___default()(item, 'name')] = item.inner;\n    }\n    return metadata;\n  }\n\n  /**\n   * Returns the GDAL nodata value\n   * @returns {number|null}\n   */\n  getGDALNoData() {\n    if (!this.fileDirectory.GDAL_NODATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_NODATA;\n    return Number(string.substring(0, string.length - 1));\n  }\n\n  /**\n   * Returns the image origin as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @returns {Array<number>} The origin as a vector\n   */\n  getOrigin() {\n    const tiePoints = this.fileDirectory.ModelTiepoint;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n    if (tiePoints && tiePoints.length === 6) {\n      return [\n        tiePoints[3],\n        tiePoints[4],\n        tiePoints[5],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[3],\n        modelTransformation[7],\n        modelTransformation[11],\n      ];\n    }\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns the image resolution as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from\n   *                                             in cases when the current image does not have the\n   *                                             required tags on its own.\n   * @returns {Array<number>} The resolution as a vector\n   */\n  getResolution(referenceImage = null) {\n    const modelPixelScale = this.fileDirectory.ModelPixelScale;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n\n    if (modelPixelScale) {\n      return [\n        modelPixelScale[0],\n        -modelPixelScale[1],\n        modelPixelScale[2],\n      ];\n    }\n    if (modelTransformation) {\n      if (modelTransformation[1] === 0 && modelTransformation[4] === 0) {\n        return [\n          modelTransformation[0],\n          -modelTransformation[5],\n          modelTransformation[10],\n        ];\n      }\n      return [\n        Math.sqrt((modelTransformation[0] * modelTransformation[0])\n          + (modelTransformation[4] * modelTransformation[4])),\n        -Math.sqrt((modelTransformation[1] * modelTransformation[1])\n          + (modelTransformation[5] * modelTransformation[5])),\n        modelTransformation[10]];\n    }\n\n    if (referenceImage) {\n      const [refResX, refResY, refResZ] = referenceImage.getResolution();\n      return [\n        refResX * referenceImage.getWidth() / this.getWidth(),\n        refResY * referenceImage.getHeight() / this.getHeight(),\n        refResZ * referenceImage.getWidth() / this.getWidth(),\n      ];\n    }\n\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns whether or not the pixels of the image depict an area (or point).\n   * @returns {Boolean} Whether the pixels are a point\n   */\n  pixelIsArea() {\n    return this.geoKeys.GTRasterTypeGeoKey === 1;\n  }\n\n  /**\n   * Returns the image bounding box as an array of 4 values: min-x, min-y,\n   * max-x and max-y. When the image has no affine transformation, then an\n   * exception is thrown.\n   * @param {boolean} [tilegrid=false] If true return extent for a tilegrid\n   *                                   without adjustment for ModelTransformation.\n   * @returns {Array<number>} The bounding box\n   */\n  getBoundingBox(tilegrid = false) {\n    const height = this.getHeight();\n    const width = this.getWidth();\n\n    if (this.fileDirectory.ModelTransformation && !tilegrid) {\n      // eslint-disable-next-line no-unused-vars\n      const [a, b, c, d, e, f, g, h] = this.fileDirectory.ModelTransformation;\n\n      const corners = [\n        [0, 0],\n        [0, height],\n        [width, 0],\n        [width, height],\n      ];\n\n      const projected = corners.map(([I, J]) => [\n        d + (a * I) + (b * J),\n        h + (e * I) + (f * J),\n      ]);\n\n      const xs = projected.map((pt) => pt[0]);\n      const ys = projected.map((pt) => pt[1]);\n\n      return [\n        Math.min(...xs),\n        Math.min(...ys),\n        Math.max(...xs),\n        Math.max(...ys),\n      ];\n    } else {\n      const origin = this.getOrigin();\n      const resolution = this.getResolution();\n\n      const x1 = origin[0];\n      const y1 = origin[1];\n\n      const x2 = x1 + (resolution[0] * width);\n      const y2 = y1 + (resolution[1] * height);\n\n      return [\n        Math.min(x1, x2),\n        Math.min(y1, y2),\n        Math.max(x1, x2),\n        Math.max(y1, y2),\n      ];\n    }\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (GeoTIFFImage);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9nZW90aWZmaW1hZ2UuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9nZW90aWZmaW1hZ2UuanM/NDU4YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQG1vZHVsZSBnZW90aWZmaW1hZ2UgKi9cbmltcG9ydCB7IGdldEZsb2F0MTYgfSBmcm9tICdAcGV0YW1vcmlrZW4vZmxvYXQxNic7XG5pbXBvcnQgZ2V0QXR0cmlidXRlIGZyb20gJ3htbC11dGlscy9nZXQtYXR0cmlidXRlLmpzJztcbmltcG9ydCBmaW5kVGFnc0J5TmFtZSBmcm9tICd4bWwtdXRpbHMvZmluZC10YWdzLWJ5LW5hbWUuanMnO1xuXG5pbXBvcnQgeyBwaG90b21ldHJpY0ludGVycHJldGF0aW9ucywgRXh0cmFTYW1wbGVzVmFsdWVzIH0gZnJvbSAnLi9nbG9iYWxzLmpzJztcbmltcG9ydCB7IGZyb21XaGl0ZUlzWmVybywgZnJvbUJsYWNrSXNaZXJvLCBmcm9tUGFsZXR0ZSwgZnJvbUNNWUssIGZyb21ZQ2JDciwgZnJvbUNJRUxhYiB9IGZyb20gJy4vcmdiLmpzJztcbmltcG9ydCB7IGdldERlY29kZXIgfSBmcm9tICcuL2NvbXByZXNzaW9uL2luZGV4LmpzJztcbmltcG9ydCB7IHJlc2FtcGxlLCByZXNhbXBsZUludGVybGVhdmVkIH0gZnJvbSAnLi9yZXNhbXBsZS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUmVhZFJhc3Rlck9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gW3dpbmRvdz13aG9sZSB3aW5kb3ddIHRoZSBzdWJzZXQgdG8gcmVhZCBkYXRhIGZyb20gaW4gcGl4ZWxzLlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBbYmJveD13aG9sZSBpbWFnZV0gdGhlIHN1YnNldCB0byByZWFkIGRhdGEgZnJvbSBpblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzLlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBbc2FtcGxlcz1hbGwgc2FtcGxlc10gdGhlIHNlbGVjdGlvbiBvZiBzYW1wbGVzIHRvIHJlYWQgZnJvbS4gRGVmYXVsdCBpcyBhbGwgc2FtcGxlcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ludGVybGVhdmU9ZmFsc2VdIHdoZXRoZXIgdGhlIGRhdGEgc2hhbGwgYmUgcmVhZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiBvbmUgc2luZ2xlIGFycmF5IG9yIHNlcGFyYXRlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5cy5cbiAqIEBwcm9wZXJ0eSB7UG9vbH0gW3Bvb2w9bnVsbF0gVGhlIG9wdGlvbmFsIGRlY29kZXIgcG9vbCB0byB1c2UuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3dpZHRoXSBUaGUgZGVzaXJlZCB3aWR0aCBvZiB0aGUgb3V0cHV0LiBXaGVuIHRoZSB3aWR0aCBpcyBub3QgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhbWUgYXMgdGhlIGltYWdlcywgcmVzYW1wbGluZyB3aWxsIGJlIHBlcmZvcm1lZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbaGVpZ2h0XSBUaGUgZGVzaXJlZCBoZWlnaHQgb2YgdGhlIG91dHB1dC4gV2hlbiB0aGUgd2lkdGggaXMgbm90IHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2FtZSBhcyB0aGUgaW1hZ2VzLCByZXNhbXBsaW5nIHdpbGwgYmUgcGVyZm9ybWVkLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtyZXNhbXBsZU1ldGhvZD0nbmVhcmVzdCddIFRoZSBkZXNpcmVkIHJlc2FtcGxpbmcgbWV0aG9kLlxuICogQHByb3BlcnR5IHtBYm9ydFNpZ25hbH0gW3NpZ25hbF0gQW4gQWJvcnRTaWduYWwgdGhhdCBtYXkgYmUgc2lnbmFsbGVkIGlmIHRoZSByZXF1ZXN0IGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGJlIGFib3J0ZWRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfG51bWJlcltdfSBbZmlsbFZhbHVlXSBUaGUgdmFsdWUgdG8gdXNlIGZvciBwYXJ0cyBvZiB0aGUgaW1hZ2VcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHNpZGUgb2YgdGhlIGltYWdlcyBleHRlbnQuIFdoZW4gbXVsdGlwbGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZXMgYXJlIHJlcXVlc3RlZCwgYW4gYXJyYXkgb2YgZmlsbCB2YWx1ZXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbiBiZSBwYXNzZWQuXG4gKi9cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL2dlb3RpZmYuanNcIikuVHlwZWRBcnJheX0gVHlwZWRBcnJheSAqL1xuLyoqIEB0eXBlZGVmIHtpbXBvcnQoXCIuL2dlb3RpZmYuanNcIikuUmVhZFJhc3RlclJlc3VsdH0gUmVhZFJhc3RlclJlc3VsdCAqL1xuXG5mdW5jdGlvbiBzdW0oYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IHMgPSAwO1xuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHMgKz0gYXJyYXlbaV07XG4gIH1cbiAgcmV0dXJuIHM7XG59XG5cbmZ1bmN0aW9uIGFycmF5Rm9yVHlwZShmb3JtYXQsIGJpdHNQZXJTYW1wbGUsIHNpemUpIHtcbiAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICBjYXNlIDE6IC8vIHVuc2lnbmVkIGludGVnZXIgZGF0YVxuICAgICAgaWYgKGJpdHNQZXJTYW1wbGUgPD0gOCkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgICB9IGVsc2UgaWYgKGJpdHNQZXJTYW1wbGUgPD0gMTYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50MTZBcnJheShzaXplKTtcbiAgICAgIH0gZWxzZSBpZiAoYml0c1BlclNhbXBsZSA8PSAzMikge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KHNpemUpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOiAvLyB0d29zIGNvbXBsZW1lbnQgc2lnbmVkIGludGVnZXIgZGF0YVxuICAgICAgaWYgKGJpdHNQZXJTYW1wbGUgPT09IDgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnQ4QXJyYXkoc2l6ZSk7XG4gICAgICB9IGVsc2UgaWYgKGJpdHNQZXJTYW1wbGUgPT09IDE2KSB7XG4gICAgICAgIHJldHVybiBuZXcgSW50MTZBcnJheShzaXplKTtcbiAgICAgIH0gZWxzZSBpZiAoYml0c1BlclNhbXBsZSA9PT0gMzIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KHNpemUpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOiAvLyBmbG9hdGluZyBwb2ludCBkYXRhXG4gICAgICBzd2l0Y2ggKGJpdHNQZXJTYW1wbGUpIHtcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShzaXplKTtcbiAgICAgICAgY2FzZSA2NDpcbiAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0NjRBcnJheShzaXplKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgfVxuICB0aHJvdyBFcnJvcignVW5zdXBwb3J0ZWQgZGF0YSBmb3JtYXQvYml0c1BlclNhbXBsZScpO1xufVxuXG5mdW5jdGlvbiBuZWVkc05vcm1hbGl6YXRpb24oZm9ybWF0LCBiaXRzUGVyU2FtcGxlKSB7XG4gIGlmICgoZm9ybWF0ID09PSAxIHx8IGZvcm1hdCA9PT0gMikgJiYgYml0c1BlclNhbXBsZSA8PSAzMiAmJiBiaXRzUGVyU2FtcGxlICUgOCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChmb3JtYXQgPT09IDMgJiYgKGJpdHNQZXJTYW1wbGUgPT09IDE2IHx8IGJpdHNQZXJTYW1wbGUgPT09IDMyIHx8IGJpdHNQZXJTYW1wbGUgPT09IDY0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkoaW5CdWZmZXIsIGZvcm1hdCwgcGxhbmFyQ29uZmlndXJhdGlvbiwgc2FtcGxlc1BlclBpeGVsLCBiaXRzUGVyU2FtcGxlLCB0aWxlV2lkdGgsIHRpbGVIZWlnaHQpIHtcbiAgLy8gY29uc3QgaW5CeXRlQXJyYXkgPSBuZXcgVWludDhBcnJheShpbkJ1ZmZlcik7XG4gIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoaW5CdWZmZXIpO1xuICBjb25zdCBvdXRTaXplID0gcGxhbmFyQ29uZmlndXJhdGlvbiA9PT0gMlxuICAgID8gdGlsZUhlaWdodCAqIHRpbGVXaWR0aFxuICAgIDogdGlsZUhlaWdodCAqIHRpbGVXaWR0aCAqIHNhbXBsZXNQZXJQaXhlbDtcbiAgY29uc3Qgc2FtcGxlc1RvVHJhbnNmZXIgPSBwbGFuYXJDb25maWd1cmF0aW9uID09PSAyXG4gICAgPyAxIDogc2FtcGxlc1BlclBpeGVsO1xuICBjb25zdCBvdXRBcnJheSA9IGFycmF5Rm9yVHlwZShmb3JtYXQsIGJpdHNQZXJTYW1wbGUsIG91dFNpemUpO1xuICAvLyBsZXQgcGl4ZWwgPSAwO1xuXG4gIGNvbnN0IGJpdE1hc2sgPSBwYXJzZUludCgnMScucmVwZWF0KGJpdHNQZXJTYW1wbGUpLCAyKTtcblxuICBpZiAoZm9ybWF0ID09PSAxKSB7IC8vIHVuc2lnbmVkIGludGVnZXJcbiAgICAvLyB0cmFuc2xhdGlvbiBvZiBodHRwczovL2dpdGh1Yi5jb20vT1NHZW8vZ2RhbC9ibG9iL21hc3Rlci9nZGFsL2ZybXRzL2d0aWZmL2dlb3RpZmYuY3BwI0w3MzM3XG4gICAgbGV0IHBpeGVsQml0U2tpcDtcbiAgICAvLyBsZXQgc2FtcGxlQml0T2Zmc2V0ID0gMDtcbiAgICBpZiAocGxhbmFyQ29uZmlndXJhdGlvbiA9PT0gMSkge1xuICAgICAgcGl4ZWxCaXRTa2lwID0gc2FtcGxlc1BlclBpeGVsICogYml0c1BlclNhbXBsZTtcbiAgICAgIC8vIHNhbXBsZUJpdE9mZnNldCA9IChzYW1wbGVzUGVyUGl4ZWwgLSAxKSAqIGJpdHNQZXJTYW1wbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBpeGVsQml0U2tpcCA9IGJpdHNQZXJTYW1wbGU7XG4gICAgfVxuXG4gICAgLy8gQml0cyBwZXIgbGluZSByb3VuZHMgdXAgdG8gbmV4dCBieXRlIGJvdW5kYXJ5LlxuICAgIGxldCBiaXRzUGVyTGluZSA9IHRpbGVXaWR0aCAqIHBpeGVsQml0U2tpcDtcbiAgICBpZiAoKGJpdHNQZXJMaW5lICYgNykgIT09IDApIHtcbiAgICAgIGJpdHNQZXJMaW5lID0gKGJpdHNQZXJMaW5lICsgNykgJiAofjcpO1xuICAgIH1cblxuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGlsZUhlaWdodDsgKyt5KSB7XG4gICAgICBjb25zdCBsaW5lQml0T2Zmc2V0ID0geSAqIGJpdHNQZXJMaW5lO1xuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aWxlV2lkdGg7ICsreCkge1xuICAgICAgICBjb25zdCBwaXhlbEJpdE9mZnNldCA9IGxpbmVCaXRPZmZzZXQgKyAoeCAqIHNhbXBsZXNUb1RyYW5zZmVyICogYml0c1BlclNhbXBsZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2FtcGxlc1RvVHJhbnNmZXI7ICsraSkge1xuICAgICAgICAgIGNvbnN0IGJpdE9mZnNldCA9IHBpeGVsQml0T2Zmc2V0ICsgKGkgKiBiaXRzUGVyU2FtcGxlKTtcbiAgICAgICAgICBjb25zdCBvdXRJbmRleCA9ICgoKHkgKiB0aWxlV2lkdGgpICsgeCkgKiBzYW1wbGVzVG9UcmFuc2ZlcikgKyBpO1xuXG4gICAgICAgICAgY29uc3QgYnl0ZU9mZnNldCA9IE1hdGguZmxvb3IoYml0T2Zmc2V0IC8gOCk7XG4gICAgICAgICAgY29uc3QgaW5uZXJCaXRPZmZzZXQgPSBiaXRPZmZzZXQgJSA4O1xuICAgICAgICAgIGlmIChpbm5lckJpdE9mZnNldCArIGJpdHNQZXJTYW1wbGUgPD0gOCkge1xuICAgICAgICAgICAgb3V0QXJyYXlbb3V0SW5kZXhdID0gKHZpZXcuZ2V0VWludDgoYnl0ZU9mZnNldCkgPj4gKDggLSBiaXRzUGVyU2FtcGxlKSAtIGlubmVyQml0T2Zmc2V0KSAmIGJpdE1hc2s7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbm5lckJpdE9mZnNldCArIGJpdHNQZXJTYW1wbGUgPD0gMTYpIHtcbiAgICAgICAgICAgIG91dEFycmF5W291dEluZGV4XSA9ICh2aWV3LmdldFVpbnQxNihieXRlT2Zmc2V0KSA+PiAoMTYgLSBiaXRzUGVyU2FtcGxlKSAtIGlubmVyQml0T2Zmc2V0KSAmIGJpdE1hc2s7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbm5lckJpdE9mZnNldCArIGJpdHNQZXJTYW1wbGUgPD0gMjQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJhdyA9ICh2aWV3LmdldFVpbnQxNihieXRlT2Zmc2V0KSA8PCA4KSB8ICh2aWV3LmdldFVpbnQ4KGJ5dGVPZmZzZXQgKyAyKSk7XG4gICAgICAgICAgICBvdXRBcnJheVtvdXRJbmRleF0gPSAocmF3ID4+ICgyNCAtIGJpdHNQZXJTYW1wbGUpIC0gaW5uZXJCaXRPZmZzZXQpICYgYml0TWFzaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0QXJyYXlbb3V0SW5kZXhdID0gKHZpZXcuZ2V0VWludDMyKGJ5dGVPZmZzZXQpID4+ICgzMiAtIGJpdHNQZXJTYW1wbGUpIC0gaW5uZXJCaXRPZmZzZXQpICYgYml0TWFzaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBsZXQgb3V0V29yZCA9IDA7XG4gICAgICAgICAgLy8gZm9yIChsZXQgYml0ID0gMDsgYml0IDwgYml0c1BlclNhbXBsZTsgKytiaXQpIHtcbiAgICAgICAgICAvLyAgIGlmIChpbkJ5dGVBcnJheVtiaXRPZmZzZXQgPj4gM11cbiAgICAgICAgICAvLyAgICAgJiAoMHg4MCA+PiAoYml0T2Zmc2V0ICYgNykpKSB7XG4gICAgICAgICAgLy8gICAgIG91dFdvcmQgfD0gKDEgPDwgKGJpdHNQZXJTYW1wbGUgLSAxIC0gYml0KSk7XG4gICAgICAgICAgLy8gICB9XG4gICAgICAgICAgLy8gICArK2JpdE9mZnNldDtcbiAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAvLyBvdXRBcnJheVtvdXRJbmRleF0gPSBvdXRXb3JkO1xuICAgICAgICAgIC8vIG91dEFycmF5W3BpeGVsXSA9IG91dFdvcmQ7XG4gICAgICAgICAgLy8gcGl4ZWwgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBiaXRPZmZzZXQgPSBiaXRPZmZzZXQgKyBwaXhlbEJpdFNraXAgLSBiaXRzUGVyU2FtcGxlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChmb3JtYXQgPT09IDMpIHsgLy8gZmxvYXRpbmcgcG9pbnRcbiAgICAvLyBGbG9hdDE2IGlzIGhhbmRsZWQgZWxzZXdoZXJlXG4gICAgLy8gbm9ybWFsaXplIDE2LzI0IGJpdCBmbG9hdHMgdG8gMzIgYml0IGZsb2F0cyBpbiB0aGUgYXJyYXlcbiAgICAvLyBjb25zb2xlLnRpbWUoKTtcbiAgICAvLyBpZiAoYml0c1BlclNhbXBsZSA9PT0gMTYpIHtcbiAgICAvLyAgIGZvciAobGV0IGJ5dGUgPSAwLCBvdXRJbmRleCA9IDA7IGJ5dGUgPCBpbkJ1ZmZlci5ieXRlTGVuZ3RoOyBieXRlICs9IDIsICsrb3V0SW5kZXgpIHtcbiAgICAvLyAgICAgb3V0QXJyYXlbb3V0SW5kZXhdID0gZ2V0RmxvYXQxNih2aWV3LCBieXRlKTtcbiAgICAvLyAgIH1cbiAgICAvLyB9XG4gICAgLy8gY29uc29sZS50aW1lRW5kKClcbiAgfVxuXG4gIHJldHVybiBvdXRBcnJheS5idWZmZXI7XG59XG5cbi8qKlxuICogR2VvVElGRiBzdWItZmlsZSBpbWFnZS5cbiAqL1xuY2xhc3MgR2VvVElGRkltYWdlIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge09iamVjdH0gZmlsZURpcmVjdG9yeSBUaGUgcGFyc2VkIGZpbGUgZGlyZWN0b3J5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBnZW9LZXlzIFRoZSBwYXJzZWQgZ2VvLWtleXNcbiAgICogQHBhcmFtIHtEYXRhVmlld30gZGF0YVZpZXcgVGhlIERhdGFWaWV3IGZvciB0aGUgdW5kZXJseWluZyBmaWxlLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGxpdHRsZUVuZGlhbiBXaGV0aGVyIHRoZSBmaWxlIGlzIGVuY29kZWQgaW4gbGl0dGxlIG9yIGJpZyBlbmRpYW5cbiAgICogQHBhcmFtIHtCb29sZWFufSBjYWNoZSBXaGV0aGVyIG9yIG5vdCBkZWNvZGVkIHRpbGVzIHNoYWxsIGJlIGNhY2hlZFxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi9zb3VyY2UvYmFzZXNvdXJjZScpLkJhc2VTb3VyY2V9IHNvdXJjZSBUaGUgZGF0YXNvdXJjZSB0byByZWFkIGZyb21cbiAgICovXG4gIGNvbnN0cnVjdG9yKGZpbGVEaXJlY3RvcnksIGdlb0tleXMsIGRhdGFWaWV3LCBsaXR0bGVFbmRpYW4sIGNhY2hlLCBzb3VyY2UpIHtcbiAgICB0aGlzLmZpbGVEaXJlY3RvcnkgPSBmaWxlRGlyZWN0b3J5O1xuICAgIHRoaXMuZ2VvS2V5cyA9IGdlb0tleXM7XG4gICAgdGhpcy5kYXRhVmlldyA9IGRhdGFWaWV3O1xuICAgIHRoaXMubGl0dGxlRW5kaWFuID0gbGl0dGxlRW5kaWFuO1xuICAgIHRoaXMudGlsZXMgPSBjYWNoZSA/IHt9IDogbnVsbDtcbiAgICB0aGlzLmlzVGlsZWQgPSAhZmlsZURpcmVjdG9yeS5TdHJpcE9mZnNldHM7XG4gICAgY29uc3QgcGxhbmFyQ29uZmlndXJhdGlvbiA9IGZpbGVEaXJlY3RvcnkuUGxhbmFyQ29uZmlndXJhdGlvbjtcbiAgICB0aGlzLnBsYW5hckNvbmZpZ3VyYXRpb24gPSAodHlwZW9mIHBsYW5hckNvbmZpZ3VyYXRpb24gPT09ICd1bmRlZmluZWQnKSA/IDEgOiBwbGFuYXJDb25maWd1cmF0aW9uO1xuICAgIGlmICh0aGlzLnBsYW5hckNvbmZpZ3VyYXRpb24gIT09IDEgJiYgdGhpcy5wbGFuYXJDb25maWd1cmF0aW9uICE9PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGxhbmFyIGNvbmZpZ3VyYXRpb24uJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXNzb2NpYXRlZCBwYXJzZWQgZmlsZSBkaXJlY3RvcnkuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBwYXJzZWQgZmlsZSBkaXJlY3RvcnlcbiAgICovXG4gIGdldEZpbGVEaXJlY3RvcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsZURpcmVjdG9yeTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhc3NvY2lhdGVkIHBhcnNlZCBnZW8ga2V5cy5cbiAgICogQHJldHVybnMge09iamVjdH0gdGhlIHBhcnNlZCBnZW8ga2V5c1xuICAgKi9cbiAgZ2V0R2VvS2V5cygpIHtcbiAgICByZXR1cm4gdGhpcy5nZW9LZXlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSBpbWFnZS5cbiAgICogQHJldHVybnMge051bWJlcn0gdGhlIHdpZHRoIG9mIHRoZSBpbWFnZVxuICAgKi9cbiAgZ2V0V2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsZURpcmVjdG9yeS5JbWFnZVdpZHRoO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhlaWdodCBvZiB0aGUgaW1hZ2UuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBoZWlnaHQgb2YgdGhlIGltYWdlXG4gICAqL1xuICBnZXRIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsZURpcmVjdG9yeS5JbWFnZUxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygc2FtcGxlcyBwZXIgcGl4ZWwuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBudW1iZXIgb2Ygc2FtcGxlcyBwZXIgcGl4ZWxcbiAgICovXG4gIGdldFNhbXBsZXNQZXJQaXhlbCgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMuZmlsZURpcmVjdG9yeS5TYW1wbGVzUGVyUGl4ZWwgIT09ICd1bmRlZmluZWQnXG4gICAgICA/IHRoaXMuZmlsZURpcmVjdG9yeS5TYW1wbGVzUGVyUGl4ZWwgOiAxO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIGVhY2ggdGlsZS5cbiAgICogQHJldHVybnMge051bWJlcn0gdGhlIHdpZHRoIG9mIGVhY2ggdGlsZVxuICAgKi9cbiAgZ2V0VGlsZVdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmlzVGlsZWQgPyB0aGlzLmZpbGVEaXJlY3RvcnkuVGlsZVdpZHRoIDogdGhpcy5nZXRXaWR0aCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhlaWdodCBvZiBlYWNoIHRpbGUuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBoZWlnaHQgb2YgZWFjaCB0aWxlXG4gICAqL1xuICBnZXRUaWxlSGVpZ2h0KCkge1xuICAgIGlmICh0aGlzLmlzVGlsZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbGVEaXJlY3RvcnkuVGlsZUxlbmd0aDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLmZpbGVEaXJlY3RvcnkuUm93c1BlclN0cmlwICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIE1hdGgubWluKHRoaXMuZmlsZURpcmVjdG9yeS5Sb3dzUGVyU3RyaXAsIHRoaXMuZ2V0SGVpZ2h0KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRIZWlnaHQoKTtcbiAgfVxuXG4gIGdldEJsb2NrV2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VGlsZVdpZHRoKCk7XG4gIH1cblxuICBnZXRCbG9ja0hlaWdodCh5KSB7XG4gICAgaWYgKHRoaXMuaXNUaWxlZCB8fCAoeSArIDEpICogdGhpcy5nZXRUaWxlSGVpZ2h0KCkgPD0gdGhpcy5nZXRIZWlnaHQoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VGlsZUhlaWdodCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRIZWlnaHQoKSAtICh5ICogdGhpcy5nZXRUaWxlSGVpZ2h0KCkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgYnl0ZXMgZm9yIGVhY2ggcGl4ZWwgYWNyb3NzIGFsbCBzYW1wbGVzLiBPbmx5IGZ1bGxcbiAgICogYnl0ZXMgYXJlIHN1cHBvcnRlZCwgYW4gZXhjZXB0aW9uIGlzIHRocm93biB3aGVuIHRoaXMgaXMgbm90IHRoZSBjYXNlLlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgYnl0ZXMgcGVyIHBpeGVsXG4gICAqL1xuICBnZXRCeXRlc1BlclBpeGVsKCkge1xuICAgIGxldCBieXRlcyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpbGVEaXJlY3RvcnkuQml0c1BlclNhbXBsZS5sZW5ndGg7ICsraSkge1xuICAgICAgYnl0ZXMgKz0gdGhpcy5nZXRTYW1wbGVCeXRlU2l6ZShpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9XG5cbiAgZ2V0U2FtcGxlQnl0ZVNpemUoaSkge1xuICAgIGlmIChpID49IHRoaXMuZmlsZURpcmVjdG9yeS5CaXRzUGVyU2FtcGxlLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFNhbXBsZSBpbmRleCAke2l9IGlzIG91dCBvZiByYW5nZS5gKTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmZpbGVEaXJlY3RvcnkuQml0c1BlclNhbXBsZVtpXSAvIDgpO1xuICB9XG5cbiAgZ2V0UmVhZGVyRm9yU2FtcGxlKHNhbXBsZUluZGV4KSB7XG4gICAgY29uc3QgZm9ybWF0ID0gdGhpcy5maWxlRGlyZWN0b3J5LlNhbXBsZUZvcm1hdFxuICAgICAgPyB0aGlzLmZpbGVEaXJlY3RvcnkuU2FtcGxlRm9ybWF0W3NhbXBsZUluZGV4XSA6IDE7XG4gICAgY29uc3QgYml0c1BlclNhbXBsZSA9IHRoaXMuZmlsZURpcmVjdG9yeS5CaXRzUGVyU2FtcGxlW3NhbXBsZUluZGV4XTtcbiAgICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgICAgY2FzZSAxOiAvLyB1bnNpZ25lZCBpbnRlZ2VyIGRhdGFcbiAgICAgICAgaWYgKGJpdHNQZXJTYW1wbGUgPD0gOCkge1xuICAgICAgICAgIHJldHVybiBEYXRhVmlldy5wcm90b3R5cGUuZ2V0VWludDg7XG4gICAgICAgIH0gZWxzZSBpZiAoYml0c1BlclNhbXBsZSA8PSAxNikge1xuICAgICAgICAgIHJldHVybiBEYXRhVmlldy5wcm90b3R5cGUuZ2V0VWludDE2O1xuICAgICAgICB9IGVsc2UgaWYgKGJpdHNQZXJTYW1wbGUgPD0gMzIpIHtcbiAgICAgICAgICByZXR1cm4gRGF0YVZpZXcucHJvdG90eXBlLmdldFVpbnQzMjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjogLy8gdHdvcyBjb21wbGVtZW50IHNpZ25lZCBpbnRlZ2VyIGRhdGFcbiAgICAgICAgaWYgKGJpdHNQZXJTYW1wbGUgPD0gOCkge1xuICAgICAgICAgIHJldHVybiBEYXRhVmlldy5wcm90b3R5cGUuZ2V0SW50ODtcbiAgICAgICAgfSBlbHNlIGlmIChiaXRzUGVyU2FtcGxlIDw9IDE2KSB7XG4gICAgICAgICAgcmV0dXJuIERhdGFWaWV3LnByb3RvdHlwZS5nZXRJbnQxNjtcbiAgICAgICAgfSBlbHNlIGlmIChiaXRzUGVyU2FtcGxlIDw9IDMyKSB7XG4gICAgICAgICAgcmV0dXJuIERhdGFWaWV3LnByb3RvdHlwZS5nZXRJbnQzMjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgc3dpdGNoIChiaXRzUGVyU2FtcGxlKSB7XG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAob2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldEZsb2F0MTYodGhpcywgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgcmV0dXJuIERhdGFWaWV3LnByb3RvdHlwZS5nZXRGbG9hdDMyO1xuICAgICAgICAgIGNhc2UgNjQ6XG4gICAgICAgICAgICByZXR1cm4gRGF0YVZpZXcucHJvdG90eXBlLmdldEZsb2F0NjQ7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRocm93IEVycm9yKCdVbnN1cHBvcnRlZCBkYXRhIGZvcm1hdC9iaXRzUGVyU2FtcGxlJyk7XG4gIH1cblxuICBnZXRTYW1wbGVGb3JtYXQoc2FtcGxlSW5kZXggPSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsZURpcmVjdG9yeS5TYW1wbGVGb3JtYXRcbiAgICAgID8gdGhpcy5maWxlRGlyZWN0b3J5LlNhbXBsZUZvcm1hdFtzYW1wbGVJbmRleF0gOiAxO1xuICB9XG5cbiAgZ2V0Qml0c1BlclNhbXBsZShzYW1wbGVJbmRleCA9IDApIHtcbiAgICByZXR1cm4gdGhpcy5maWxlRGlyZWN0b3J5LkJpdHNQZXJTYW1wbGVbc2FtcGxlSW5kZXhdO1xuICB9XG5cbiAgZ2V0QXJyYXlGb3JTYW1wbGUoc2FtcGxlSW5kZXgsIHNpemUpIHtcbiAgICBjb25zdCBmb3JtYXQgPSB0aGlzLmdldFNhbXBsZUZvcm1hdChzYW1wbGVJbmRleCk7XG4gICAgY29uc3QgYml0c1BlclNhbXBsZSA9IHRoaXMuZ2V0Qml0c1BlclNhbXBsZShzYW1wbGVJbmRleCk7XG4gICAgcmV0dXJuIGFycmF5Rm9yVHlwZShmb3JtYXQsIGJpdHNQZXJTYW1wbGUsIHNpemUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRlY29kZWQgc3RyaXAgb3IgdGlsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHggdGhlIHN0cmlwIG9yIHRpbGUgeC1vZmZzZXRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkgdGhlIHRpbGUgeS1vZmZzZXQgKDAgZm9yIHN0cmlwcGVkIGltYWdlcylcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNhbXBsZSB0aGUgc2FtcGxlIHRvIGdldCBmb3Igc2VwYXJhdGVkIHNhbXBsZXNcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2dlb3RpZmZcIikuUG9vbHxpbXBvcnQoXCIuL2dlb3RpZmZcIikuQmFzZURlY29kZXJ9IHBvb2xPckRlY29kZXIgdGhlIGRlY29kZXIgb3IgZGVjb2RlciBwb29sXG4gICAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IFtzaWduYWxdIEFuIEFib3J0U2lnbmFsIHRoYXQgbWF5IGJlIHNpZ25hbGxlZCBpZiB0aGUgcmVxdWVzdCBpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBiZSBhYm9ydGVkXG4gICAqIEByZXR1cm5zIHtQcm9taXNlLjxBcnJheUJ1ZmZlcj59XG4gICAqL1xuICBhc3luYyBnZXRUaWxlT3JTdHJpcCh4LCB5LCBzYW1wbGUsIHBvb2xPckRlY29kZXIsIHNpZ25hbCkge1xuICAgIGNvbnN0IG51bVRpbGVzUGVyUm93ID0gTWF0aC5jZWlsKHRoaXMuZ2V0V2lkdGgoKSAvIHRoaXMuZ2V0VGlsZVdpZHRoKCkpO1xuICAgIGNvbnN0IG51bVRpbGVzUGVyQ29sID0gTWF0aC5jZWlsKHRoaXMuZ2V0SGVpZ2h0KCkgLyB0aGlzLmdldFRpbGVIZWlnaHQoKSk7XG4gICAgbGV0IGluZGV4O1xuICAgIGNvbnN0IHsgdGlsZXMgfSA9IHRoaXM7XG4gICAgaWYgKHRoaXMucGxhbmFyQ29uZmlndXJhdGlvbiA9PT0gMSkge1xuICAgICAgaW5kZXggPSAoeSAqIG51bVRpbGVzUGVyUm93KSArIHg7XG4gICAgfSBlbHNlIGlmICh0aGlzLnBsYW5hckNvbmZpZ3VyYXRpb24gPT09IDIpIHtcbiAgICAgIGluZGV4ID0gKHNhbXBsZSAqIG51bVRpbGVzUGVyUm93ICogbnVtVGlsZXNQZXJDb2wpICsgKHkgKiBudW1UaWxlc1BlclJvdykgKyB4O1xuICAgIH1cblxuICAgIGxldCBvZmZzZXQ7XG4gICAgbGV0IGJ5dGVDb3VudDtcbiAgICBpZiAodGhpcy5pc1RpbGVkKSB7XG4gICAgICBvZmZzZXQgPSB0aGlzLmZpbGVEaXJlY3RvcnkuVGlsZU9mZnNldHNbaW5kZXhdO1xuICAgICAgYnl0ZUNvdW50ID0gdGhpcy5maWxlRGlyZWN0b3J5LlRpbGVCeXRlQ291bnRzW2luZGV4XTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0ID0gdGhpcy5maWxlRGlyZWN0b3J5LlN0cmlwT2Zmc2V0c1tpbmRleF07XG4gICAgICBieXRlQ291bnQgPSB0aGlzLmZpbGVEaXJlY3RvcnkuU3RyaXBCeXRlQ291bnRzW2luZGV4XTtcbiAgICB9XG4gICAgY29uc3Qgc2xpY2UgPSAoYXdhaXQgdGhpcy5zb3VyY2UuZmV0Y2goW3sgb2Zmc2V0LCBsZW5ndGg6IGJ5dGVDb3VudCB9XSwgc2lnbmFsKSlbMF07XG5cbiAgICBsZXQgcmVxdWVzdDtcbiAgICBpZiAodGlsZXMgPT09IG51bGwgfHwgIXRpbGVzW2luZGV4XSkge1xuICAgIC8vIHJlc29sdmUgZWFjaCByZXF1ZXN0IGJ5IHBvdGVudGlhbGx5IGFwcGx5aW5nIGFycmF5IG5vcm1hbGl6YXRpb25cbiAgICAgIHJlcXVlc3QgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICBsZXQgZGF0YSA9IGF3YWl0IHBvb2xPckRlY29kZXIuZGVjb2RlKHRoaXMuZmlsZURpcmVjdG9yeSwgc2xpY2UpO1xuICAgICAgICBjb25zdCBzYW1wbGVGb3JtYXQgPSB0aGlzLmdldFNhbXBsZUZvcm1hdCgpO1xuICAgICAgICBjb25zdCBiaXRzUGVyU2FtcGxlID0gdGhpcy5nZXRCaXRzUGVyU2FtcGxlKCk7XG4gICAgICAgIGlmIChuZWVkc05vcm1hbGl6YXRpb24oc2FtcGxlRm9ybWF0LCBiaXRzUGVyU2FtcGxlKSkge1xuICAgICAgICAgIGRhdGEgPSBub3JtYWxpemVBcnJheShcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBzYW1wbGVGb3JtYXQsXG4gICAgICAgICAgICB0aGlzLnBsYW5hckNvbmZpZ3VyYXRpb24sXG4gICAgICAgICAgICB0aGlzLmdldFNhbXBsZXNQZXJQaXhlbCgpLFxuICAgICAgICAgICAgYml0c1BlclNhbXBsZSxcbiAgICAgICAgICAgIHRoaXMuZ2V0VGlsZVdpZHRoKCksXG4gICAgICAgICAgICB0aGlzLmdldEJsb2NrSGVpZ2h0KHkpLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9KSgpO1xuXG4gICAgICAvLyBzZXQgdGhlIGNhY2hlXG4gICAgICBpZiAodGlsZXMgIT09IG51bGwpIHtcbiAgICAgICAgdGlsZXNbaW5kZXhdID0gcmVxdWVzdDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZ2V0IGZyb20gdGhlIGNhY2hlXG4gICAgICByZXF1ZXN0ID0gdGlsZXNbaW5kZXhdO1xuICAgIH1cblxuICAgIC8vIGNhY2hlIHRoZSB0aWxlIHJlcXVlc3RcbiAgICByZXR1cm4geyB4LCB5LCBzYW1wbGUsIGRhdGE6IGF3YWl0IHJlcXVlc3QgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCByZWFkIGZ1bmN0aW9uLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBpbWFnZVdpbmRvdyBUaGUgaW1hZ2Ugd2luZG93IGluIHBpeGVsIGNvb3JkaW5hdGVzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNhbXBsZXMgVGhlIHNlbGVjdGVkIHNhbXBsZXMgKDAtYmFzZWQgaW5kaWNlcylcbiAgICogQHBhcmFtIHtUeXBlZEFycmF5fFR5cGVkQXJyYXlbXX0gdmFsdWVBcnJheXMgVGhlIGFycmF5KHMpIHRvIHdyaXRlIGludG9cbiAgICogQHBhcmFtIHtCb29sZWFufSBpbnRlcmxlYXZlIFdoZXRoZXIgb3Igbm90IHRvIHdyaXRlIGluIGFuIGludGVybGVhdmVkIG1hbm5lclxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vZ2VvdGlmZlwiKS5Qb29sfEFic3RyYWN0RGVjb2Rlcn0gcG9vbE9yRGVjb2RlciB0aGUgZGVjb2RlciBvciBkZWNvZGVyIHBvb2xcbiAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIHRoZSB3aWR0aCBvZiB3aW5kb3cgdG8gYmUgcmVhZCBpbnRvXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgdGhlIGhlaWdodCBvZiB3aW5kb3cgdG8gYmUgcmVhZCBpbnRvXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXNhbXBsZU1ldGhvZCB0aGUgcmVzYW1wbGluZyBtZXRob2QgdG8gYmUgdXNlZCB3aGVuIGludGVycG9sYXRpbmdcbiAgICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gW3NpZ25hbF0gQW4gQWJvcnRTaWduYWwgdGhhdCBtYXkgYmUgc2lnbmFsbGVkIGlmIHRoZSByZXF1ZXN0IGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGJlIGFib3J0ZWRcbiAgICogQHJldHVybnMge1Byb21pc2U8UmVhZFJhc3RlclJlc3VsdD59XG4gICAqL1xuICBhc3luYyBfcmVhZFJhc3RlcihpbWFnZVdpbmRvdywgc2FtcGxlcywgdmFsdWVBcnJheXMsIGludGVybGVhdmUsIHBvb2xPckRlY29kZXIsIHdpZHRoLFxuICAgIGhlaWdodCwgcmVzYW1wbGVNZXRob2QsIHNpZ25hbCkge1xuICAgIGNvbnN0IHRpbGVXaWR0aCA9IHRoaXMuZ2V0VGlsZVdpZHRoKCk7XG4gICAgY29uc3QgdGlsZUhlaWdodCA9IHRoaXMuZ2V0VGlsZUhlaWdodCgpO1xuICAgIGNvbnN0IGltYWdlV2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XG4gICAgY29uc3QgaW1hZ2VIZWlnaHQgPSB0aGlzLmdldEhlaWdodCgpO1xuXG4gICAgY29uc3QgbWluWFRpbGUgPSBNYXRoLm1heChNYXRoLmZsb29yKGltYWdlV2luZG93WzBdIC8gdGlsZVdpZHRoKSwgMCk7XG4gICAgY29uc3QgbWF4WFRpbGUgPSBNYXRoLm1pbihcbiAgICAgIE1hdGguY2VpbChpbWFnZVdpbmRvd1syXSAvIHRpbGVXaWR0aCksXG4gICAgICBNYXRoLmNlaWwoaW1hZ2VXaWR0aCAvIHRpbGVXaWR0aCksXG4gICAgKTtcbiAgICBjb25zdCBtaW5ZVGlsZSA9IE1hdGgubWF4KE1hdGguZmxvb3IoaW1hZ2VXaW5kb3dbMV0gLyB0aWxlSGVpZ2h0KSwgMCk7XG4gICAgY29uc3QgbWF4WVRpbGUgPSBNYXRoLm1pbihcbiAgICAgIE1hdGguY2VpbChpbWFnZVdpbmRvd1szXSAvIHRpbGVIZWlnaHQpLFxuICAgICAgTWF0aC5jZWlsKGltYWdlSGVpZ2h0IC8gdGlsZUhlaWdodCksXG4gICAgKTtcbiAgICBjb25zdCB3aW5kb3dXaWR0aCA9IGltYWdlV2luZG93WzJdIC0gaW1hZ2VXaW5kb3dbMF07XG5cbiAgICBsZXQgYnl0ZXNQZXJQaXhlbCA9IHRoaXMuZ2V0Qnl0ZXNQZXJQaXhlbCgpO1xuXG4gICAgY29uc3Qgc3JjU2FtcGxlT2Zmc2V0cyA9IFtdO1xuICAgIGNvbnN0IHNhbXBsZVJlYWRlcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmICh0aGlzLnBsYW5hckNvbmZpZ3VyYXRpb24gPT09IDEpIHtcbiAgICAgICAgc3JjU2FtcGxlT2Zmc2V0cy5wdXNoKHN1bSh0aGlzLmZpbGVEaXJlY3RvcnkuQml0c1BlclNhbXBsZSwgMCwgc2FtcGxlc1tpXSkgLyA4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNyY1NhbXBsZU9mZnNldHMucHVzaCgwKTtcbiAgICAgIH1cbiAgICAgIHNhbXBsZVJlYWRlcnMucHVzaCh0aGlzLmdldFJlYWRlckZvclNhbXBsZShzYW1wbGVzW2ldKSk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICBjb25zdCB7IGxpdHRsZUVuZGlhbiB9ID0gdGhpcztcblxuICAgIGZvciAobGV0IHlUaWxlID0gbWluWVRpbGU7IHlUaWxlIDwgbWF4WVRpbGU7ICsreVRpbGUpIHtcbiAgICAgIGZvciAobGV0IHhUaWxlID0gbWluWFRpbGU7IHhUaWxlIDwgbWF4WFRpbGU7ICsreFRpbGUpIHtcbiAgICAgICAgbGV0IGdldFByb21pc2U7XG4gICAgICAgIGlmICh0aGlzLnBsYW5hckNvbmZpZ3VyYXRpb24gPT09IDEpIHtcbiAgICAgICAgICBnZXRQcm9taXNlID0gdGhpcy5nZXRUaWxlT3JTdHJpcCh4VGlsZSwgeVRpbGUsIDAsIHBvb2xPckRlY29kZXIsIHNpZ25hbCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgc2FtcGxlSW5kZXggPSAwOyBzYW1wbGVJbmRleCA8IHNhbXBsZXMubGVuZ3RoOyArK3NhbXBsZUluZGV4KSB7XG4gICAgICAgICAgY29uc3Qgc2kgPSBzYW1wbGVJbmRleDtcbiAgICAgICAgICBjb25zdCBzYW1wbGUgPSBzYW1wbGVzW3NhbXBsZUluZGV4XTtcbiAgICAgICAgICBpZiAodGhpcy5wbGFuYXJDb25maWd1cmF0aW9uID09PSAyKSB7XG4gICAgICAgICAgICBieXRlc1BlclBpeGVsID0gdGhpcy5nZXRTYW1wbGVCeXRlU2l6ZShzYW1wbGUpO1xuICAgICAgICAgICAgZ2V0UHJvbWlzZSA9IHRoaXMuZ2V0VGlsZU9yU3RyaXAoeFRpbGUsIHlUaWxlLCBzYW1wbGUsIHBvb2xPckRlY29kZXIsIHNpZ25hbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBnZXRQcm9taXNlLnRoZW4oKHRpbGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRpbGUuZGF0YTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgICAgICAgICBjb25zdCBibG9ja0hlaWdodCA9IHRoaXMuZ2V0QmxvY2tIZWlnaHQodGlsZS55KTtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0TGluZSA9IHRpbGUueSAqIHRpbGVIZWlnaHQ7XG4gICAgICAgICAgICBjb25zdCBmaXJzdENvbCA9IHRpbGUueCAqIHRpbGVXaWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RMaW5lID0gZmlyc3RMaW5lICsgYmxvY2tIZWlnaHQ7XG4gICAgICAgICAgICBjb25zdCBsYXN0Q29sID0gKHRpbGUueCArIDEpICogdGlsZVdpZHRoO1xuICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gc2FtcGxlUmVhZGVyc1tzaV07XG5cbiAgICAgICAgICAgIGNvbnN0IHltYXggPSBNYXRoLm1pbihibG9ja0hlaWdodCwgYmxvY2tIZWlnaHQgLSAobGFzdExpbmUgLSBpbWFnZVdpbmRvd1szXSksIGltYWdlSGVpZ2h0IC0gZmlyc3RMaW5lKTtcbiAgICAgICAgICAgIGNvbnN0IHhtYXggPSBNYXRoLm1pbih0aWxlV2lkdGgsIHRpbGVXaWR0aCAtIChsYXN0Q29sIC0gaW1hZ2VXaW5kb3dbMl0pLCBpbWFnZVdpZHRoIC0gZmlyc3RDb2wpO1xuXG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gTWF0aC5tYXgoMCwgaW1hZ2VXaW5kb3dbMV0gLSBmaXJzdExpbmUpOyB5IDwgeW1heDsgKyt5KSB7XG4gICAgICAgICAgICAgIGZvciAobGV0IHggPSBNYXRoLm1heCgwLCBpbWFnZVdpbmRvd1swXSAtIGZpcnN0Q29sKTsgeCA8IHhtYXg7ICsreCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBpeGVsT2Zmc2V0ID0gKCh5ICogdGlsZVdpZHRoKSArIHgpICogYnl0ZXNQZXJQaXhlbDtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJlYWRlci5jYWxsKFxuICAgICAgICAgICAgICAgICAgZGF0YVZpZXcsIHBpeGVsT2Zmc2V0ICsgc3JjU2FtcGxlT2Zmc2V0c1tzaV0sIGxpdHRsZUVuZGlhbixcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGxldCB3aW5kb3dDb29yZGluYXRlO1xuICAgICAgICAgICAgICAgIGlmIChpbnRlcmxlYXZlKSB7XG4gICAgICAgICAgICAgICAgICB3aW5kb3dDb29yZGluYXRlID0gKCh5ICsgZmlyc3RMaW5lIC0gaW1hZ2VXaW5kb3dbMV0pICogd2luZG93V2lkdGggKiBzYW1wbGVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgKyAoKHggKyBmaXJzdENvbCAtIGltYWdlV2luZG93WzBdKSAqIHNhbXBsZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICArIHNpO1xuICAgICAgICAgICAgICAgICAgdmFsdWVBcnJheXNbd2luZG93Q29vcmRpbmF0ZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgd2luZG93Q29vcmRpbmF0ZSA9IChcbiAgICAgICAgICAgICAgICAgICAgKHkgKyBmaXJzdExpbmUgLSBpbWFnZVdpbmRvd1sxXSkgKiB3aW5kb3dXaWR0aFxuICAgICAgICAgICAgICAgICAgKSArIHggKyBmaXJzdENvbCAtIGltYWdlV2luZG93WzBdO1xuICAgICAgICAgICAgICAgICAgdmFsdWVBcnJheXNbc2ldW3dpbmRvd0Nvb3JkaW5hdGVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG5cbiAgICBpZiAoKHdpZHRoICYmIChpbWFnZVdpbmRvd1syXSAtIGltYWdlV2luZG93WzBdKSAhPT0gd2lkdGgpXG4gICAgICAgIHx8IChoZWlnaHQgJiYgKGltYWdlV2luZG93WzNdIC0gaW1hZ2VXaW5kb3dbMV0pICE9PSBoZWlnaHQpKSB7XG4gICAgICBsZXQgcmVzYW1wbGVkO1xuICAgICAgaWYgKGludGVybGVhdmUpIHtcbiAgICAgICAgcmVzYW1wbGVkID0gcmVzYW1wbGVJbnRlcmxlYXZlZChcbiAgICAgICAgICB2YWx1ZUFycmF5cyxcbiAgICAgICAgICBpbWFnZVdpbmRvd1syXSAtIGltYWdlV2luZG93WzBdLFxuICAgICAgICAgIGltYWdlV2luZG93WzNdIC0gaW1hZ2VXaW5kb3dbMV0sXG4gICAgICAgICAgd2lkdGgsIGhlaWdodCxcbiAgICAgICAgICBzYW1wbGVzLmxlbmd0aCxcbiAgICAgICAgICByZXNhbXBsZU1ldGhvZCxcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc2FtcGxlZCA9IHJlc2FtcGxlKFxuICAgICAgICAgIHZhbHVlQXJyYXlzLFxuICAgICAgICAgIGltYWdlV2luZG93WzJdIC0gaW1hZ2VXaW5kb3dbMF0sXG4gICAgICAgICAgaW1hZ2VXaW5kb3dbM10gLSBpbWFnZVdpbmRvd1sxXSxcbiAgICAgICAgICB3aWR0aCwgaGVpZ2h0LFxuICAgICAgICAgIHJlc2FtcGxlTWV0aG9kLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmVzYW1wbGVkLndpZHRoID0gd2lkdGg7XG4gICAgICByZXNhbXBsZWQuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgcmV0dXJuIHJlc2FtcGxlZDtcbiAgICB9XG5cbiAgICB2YWx1ZUFycmF5cy53aWR0aCA9IHdpZHRoIHx8IGltYWdlV2luZG93WzJdIC0gaW1hZ2VXaW5kb3dbMF07XG4gICAgdmFsdWVBcnJheXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IGltYWdlV2luZG93WzNdIC0gaW1hZ2VXaW5kb3dbMV07XG5cbiAgICByZXR1cm4gdmFsdWVBcnJheXM7XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgcmFzdGVyIGRhdGEgZnJvbSB0aGUgaW1hZ2UuIFRoaXMgZnVuY3Rpb24gcmVhZHMgYWxsIHNlbGVjdGVkIHNhbXBsZXNcbiAgICogaW50byBzZXBhcmF0ZSBhcnJheXMgb2YgdGhlIGNvcnJlY3QgdHlwZSBmb3IgdGhhdCBzYW1wbGUgb3IgaW50byBhIHNpbmdsZVxuICAgKiBjb21iaW5lZCBhcnJheSB3aGVuIGBpbnRlcmxlYXZlYCBpcyBzZXQuIFdoZW4gcHJvdmlkZWQsIG9ubHkgYSBzdWJzZXRcbiAgICogb2YgdGhlIHJhc3RlciBpcyByZWFkIGZvciBlYWNoIHNhbXBsZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFkUmFzdGVyT3B0aW9uc30gW29wdGlvbnM9e31dIG9wdGlvbmFsIHBhcmFtZXRlcnNcbiAgICogQHJldHVybnMge1Byb21pc2U8UmVhZFJhc3RlclJlc3VsdD59IHRoZSBkZWNvZGVkIGFycmF5cyBhcyBhIHByb21pc2VcbiAgICovXG4gIGFzeW5jIHJlYWRSYXN0ZXJzKHtcbiAgICB3aW5kb3c6IHduZCwgc2FtcGxlcyA9IFtdLCBpbnRlcmxlYXZlLCBwb29sID0gbnVsbCxcbiAgICB3aWR0aCwgaGVpZ2h0LCByZXNhbXBsZU1ldGhvZCwgZmlsbFZhbHVlLCBzaWduYWwsXG4gIH0gPSB7fSkge1xuICAgIGNvbnN0IGltYWdlV2luZG93ID0gd25kIHx8IFswLCAwLCB0aGlzLmdldFdpZHRoKCksIHRoaXMuZ2V0SGVpZ2h0KCldO1xuXG4gICAgLy8gY2hlY2sgcGFyYW1ldGVyc1xuICAgIGlmIChpbWFnZVdpbmRvd1swXSA+IGltYWdlV2luZG93WzJdIHx8IGltYWdlV2luZG93WzFdID4gaW1hZ2VXaW5kb3dbM10pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdWJzZXRzJyk7XG4gICAgfVxuXG4gICAgY29uc3QgaW1hZ2VXaW5kb3dXaWR0aCA9IGltYWdlV2luZG93WzJdIC0gaW1hZ2VXaW5kb3dbMF07XG4gICAgY29uc3QgaW1hZ2VXaW5kb3dIZWlnaHQgPSBpbWFnZVdpbmRvd1szXSAtIGltYWdlV2luZG93WzFdO1xuICAgIGNvbnN0IG51bVBpeGVscyA9IGltYWdlV2luZG93V2lkdGggKiBpbWFnZVdpbmRvd0hlaWdodDtcbiAgICBjb25zdCBzYW1wbGVzUGVyUGl4ZWwgPSB0aGlzLmdldFNhbXBsZXNQZXJQaXhlbCgpO1xuXG4gICAgaWYgKCFzYW1wbGVzIHx8ICFzYW1wbGVzLmxlbmd0aCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzUGVyUGl4ZWw7ICsraSkge1xuICAgICAgICBzYW1wbGVzLnB1c2goaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2FtcGxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoc2FtcGxlc1tpXSA+PSBzYW1wbGVzUGVyUGl4ZWwpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFJhbmdlRXJyb3IoYEludmFsaWQgc2FtcGxlIGluZGV4ICcke3NhbXBsZXNbaV19Jy5gKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHZhbHVlQXJyYXlzO1xuICAgIGlmIChpbnRlcmxlYXZlKSB7XG4gICAgICBjb25zdCBmb3JtYXQgPSB0aGlzLmZpbGVEaXJlY3RvcnkuU2FtcGxlRm9ybWF0XG4gICAgICAgID8gTWF0aC5tYXguYXBwbHkobnVsbCwgdGhpcy5maWxlRGlyZWN0b3J5LlNhbXBsZUZvcm1hdCkgOiAxO1xuICAgICAgY29uc3QgYml0c1BlclNhbXBsZSA9IE1hdGgubWF4LmFwcGx5KG51bGwsIHRoaXMuZmlsZURpcmVjdG9yeS5CaXRzUGVyU2FtcGxlKTtcbiAgICAgIHZhbHVlQXJyYXlzID0gYXJyYXlGb3JUeXBlKGZvcm1hdCwgYml0c1BlclNhbXBsZSwgbnVtUGl4ZWxzICogc2FtcGxlcy5sZW5ndGgpO1xuICAgICAgaWYgKGZpbGxWYWx1ZSkge1xuICAgICAgICB2YWx1ZUFycmF5cy5maWxsKGZpbGxWYWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlQXJyYXlzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgdmFsdWVBcnJheSA9IHRoaXMuZ2V0QXJyYXlGb3JTYW1wbGUoc2FtcGxlc1tpXSwgbnVtUGl4ZWxzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmlsbFZhbHVlKSAmJiBpIDwgZmlsbFZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgIHZhbHVlQXJyYXkuZmlsbChmaWxsVmFsdWVbaV0pO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGxWYWx1ZSAmJiAhQXJyYXkuaXNBcnJheShmaWxsVmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWVBcnJheS5maWxsKGZpbGxWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVBcnJheXMucHVzaCh2YWx1ZUFycmF5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwb29sT3JEZWNvZGVyID0gcG9vbCB8fCBhd2FpdCBnZXREZWNvZGVyKHRoaXMuZmlsZURpcmVjdG9yeSk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9yZWFkUmFzdGVyKFxuICAgICAgaW1hZ2VXaW5kb3csIHNhbXBsZXMsIHZhbHVlQXJyYXlzLCBpbnRlcmxlYXZlLCBwb29sT3JEZWNvZGVyLCB3aWR0aCwgaGVpZ2h0LCByZXNhbXBsZU1ldGhvZCwgc2lnbmFsLFxuICAgICk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyByYXN0ZXIgZGF0YSBmcm9tIHRoZSBpbWFnZSBhcyBSR0IuIFRoZSByZXN1bHQgaXMgYWx3YXlzIGFuXG4gICAqIGludGVybGVhdmVkIHR5cGVkIGFycmF5LlxuICAgKiBDb2xvcnNwYWNlcyBvdGhlciB0aGFuIFJHQiB3aWxsIGJlIHRyYW5zZm9ybWVkIHRvIFJHQiwgY29sb3IgbWFwcyBleHBhbmRlZC5cbiAgICogV2hlbiBubyBvdGhlciBtZXRob2QgaXMgYXBwbGljYWJsZSwgdGhlIGZpcnN0IHNhbXBsZSBpcyB1c2VkIHRvIHByb2R1Y2UgYVxuICAgKiBncmF5c2NhbGUgaW1hZ2UuXG4gICAqIFdoZW4gcHJvdmlkZWQsIG9ubHkgYSBzdWJzZXQgb2YgdGhlIHJhc3RlciBpcyByZWFkIGZvciBlYWNoIHNhbXBsZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25hbCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW29wdGlvbnMud2luZG93XSB0aGUgc3Vic2V0IHRvIHJlYWQgZGF0YSBmcm9tIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pbnRlcmxlYXZlPXRydWVdIHdoZXRoZXIgdGhlIGRhdGEgc2hhbGwgYmUgcmVhZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIG9uZSBzaW5nbGUgYXJyYXkgb3Igc2VwYXJhdGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheXMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9nZW90aWZmXCIpLlBvb2x9IFtvcHRpb25zLnBvb2w9bnVsbF0gVGhlIG9wdGlvbmFsIGRlY29kZXIgcG9vbCB0byB1c2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy53aWR0aF0gVGhlIGRlc2lyZWQgd2lkdGggb2YgdGhlIG91dHB1dC4gV2hlbiB0aGUgd2lkdGggaXMgbm8gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2FtZSBhcyB0aGUgaW1hZ2VzLCByZXNhbXBsaW5nIHdpbGwgYmUgcGVyZm9ybWVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuaGVpZ2h0XSBUaGUgZGVzaXJlZCBoZWlnaHQgb2YgdGhlIG91dHB1dC4gV2hlbiB0aGUgd2lkdGggaXMgbm8gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhbWUgYXMgdGhlIGltYWdlcywgcmVzYW1wbGluZyB3aWxsIGJlIHBlcmZvcm1lZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnJlc2FtcGxlTWV0aG9kPSduZWFyZXN0J10gVGhlIGRlc2lyZWQgcmVzYW1wbGluZyBtZXRob2QuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZW5hYmxlQWxwaGE9ZmFsc2VdIEVuYWJsZSByZWFkaW5nIGFscGhhIGNoYW5uZWwgaWYgcHJlc2VudC5cbiAgICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gW29wdGlvbnMuc2lnbmFsXSBBbiBBYm9ydFNpZ25hbCB0aGF0IG1heSBiZSBzaWduYWxsZWQgaWYgdGhlIHJlcXVlc3QgaXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBiZSBhYm9ydGVkXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFJlYWRSYXN0ZXJSZXN1bHQ+fSB0aGUgUkdCIGFycmF5IGFzIGEgUHJvbWlzZVxuICAgKi9cbiAgYXN5bmMgcmVhZFJHQih7IHdpbmRvdywgaW50ZXJsZWF2ZSA9IHRydWUsIHBvb2wgPSBudWxsLCB3aWR0aCwgaGVpZ2h0LFxuICAgIHJlc2FtcGxlTWV0aG9kLCBlbmFibGVBbHBoYSA9IGZhbHNlLCBzaWduYWwgfSA9IHt9KSB7XG4gICAgY29uc3QgaW1hZ2VXaW5kb3cgPSB3aW5kb3cgfHwgWzAsIDAsIHRoaXMuZ2V0V2lkdGgoKSwgdGhpcy5nZXRIZWlnaHQoKV07XG5cbiAgICAvLyBjaGVjayBwYXJhbWV0ZXJzXG4gICAgaWYgKGltYWdlV2luZG93WzBdID4gaW1hZ2VXaW5kb3dbMl0gfHwgaW1hZ2VXaW5kb3dbMV0gPiBpbWFnZVdpbmRvd1szXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN1YnNldHMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBwaSA9IHRoaXMuZmlsZURpcmVjdG9yeS5QaG90b21ldHJpY0ludGVycHJldGF0aW9uO1xuXG4gICAgaWYgKHBpID09PSBwaG90b21ldHJpY0ludGVycHJldGF0aW9ucy5SR0IpIHtcbiAgICAgIGxldCBzID0gWzAsIDEsIDJdO1xuICAgICAgaWYgKCghKHRoaXMuZmlsZURpcmVjdG9yeS5FeHRyYVNhbXBsZXMgPT09IEV4dHJhU2FtcGxlc1ZhbHVlcy5VbnNwZWNpZmllZCkpICYmIGVuYWJsZUFscGhhKSB7XG4gICAgICAgIHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpbGVEaXJlY3RvcnkuQml0c1BlclNhbXBsZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIHMucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucmVhZFJhc3RlcnMoe1xuICAgICAgICB3aW5kb3csXG4gICAgICAgIGludGVybGVhdmUsXG4gICAgICAgIHNhbXBsZXM6IHMsXG4gICAgICAgIHBvb2wsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHJlc2FtcGxlTWV0aG9kLFxuICAgICAgICBzaWduYWwsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBsZXQgc2FtcGxlcztcbiAgICBzd2l0Y2ggKHBpKSB7XG4gICAgICBjYXNlIHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb25zLldoaXRlSXNaZXJvOlxuICAgICAgY2FzZSBwaG90b21ldHJpY0ludGVycHJldGF0aW9ucy5CbGFja0lzWmVybzpcbiAgICAgIGNhc2UgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMuUGFsZXR0ZTpcbiAgICAgICAgc2FtcGxlcyA9IFswXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb25zLkNNWUs6XG4gICAgICAgIHNhbXBsZXMgPSBbMCwgMSwgMiwgM107XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBwaG90b21ldHJpY0ludGVycHJldGF0aW9ucy5ZQ2JDcjpcbiAgICAgIGNhc2UgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMuQ0lFTGFiOlxuICAgICAgICBzYW1wbGVzID0gWzAsIDEsIDJdO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBvciB1bnN1cHBvcnRlZCBwaG90b21ldHJpYyBpbnRlcnByZXRhdGlvbi4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdWJPcHRpb25zID0ge1xuICAgICAgd2luZG93OiBpbWFnZVdpbmRvdyxcbiAgICAgIGludGVybGVhdmU6IHRydWUsXG4gICAgICBzYW1wbGVzLFxuICAgICAgcG9vbCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgcmVzYW1wbGVNZXRob2QsXG4gICAgICBzaWduYWwsXG4gICAgfTtcbiAgICBjb25zdCB7IGZpbGVEaXJlY3RvcnkgfSA9IHRoaXM7XG4gICAgY29uc3QgcmFzdGVyID0gYXdhaXQgdGhpcy5yZWFkUmFzdGVycyhzdWJPcHRpb25zKTtcblxuICAgIGNvbnN0IG1heCA9IDIgKiogdGhpcy5maWxlRGlyZWN0b3J5LkJpdHNQZXJTYW1wbGVbMF07XG4gICAgbGV0IGRhdGE7XG4gICAgc3dpdGNoIChwaSkge1xuICAgICAgY2FzZSBwaG90b21ldHJpY0ludGVycHJldGF0aW9ucy5XaGl0ZUlzWmVybzpcbiAgICAgICAgZGF0YSA9IGZyb21XaGl0ZUlzWmVybyhyYXN0ZXIsIG1heCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBwaG90b21ldHJpY0ludGVycHJldGF0aW9ucy5CbGFja0lzWmVybzpcbiAgICAgICAgZGF0YSA9IGZyb21CbGFja0lzWmVybyhyYXN0ZXIsIG1heCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBwaG90b21ldHJpY0ludGVycHJldGF0aW9ucy5QYWxldHRlOlxuICAgICAgICBkYXRhID0gZnJvbVBhbGV0dGUocmFzdGVyLCBmaWxlRGlyZWN0b3J5LkNvbG9yTWFwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb25zLkNNWUs6XG4gICAgICAgIGRhdGEgPSBmcm9tQ01ZSyhyYXN0ZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMuWUNiQ3I6XG4gICAgICAgIGRhdGEgPSBmcm9tWUNiQ3IocmFzdGVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb25zLkNJRUxhYjpcbiAgICAgICAgZGF0YSA9IGZyb21DSUVMYWIocmFzdGVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHBob3RvbWV0cmljIGludGVycHJldGF0aW9uLicpO1xuICAgIH1cblxuICAgIC8vIGlmIG5vbi1pbnRlcmxlYXZlZCBkYXRhIGlzIHJlcXVlc3RlZCwgd2UgbXVzdCBzcGxpdCB0aGUgY2hhbm5lbHNcbiAgICAvLyBpbnRvIHRoZWlyIHJlc3BlY3RpdmUgYXJyYXlzXG4gICAgaWYgKCFpbnRlcmxlYXZlKSB7XG4gICAgICBjb25zdCByZWQgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCAvIDMpO1xuICAgICAgY29uc3QgZ3JlZW4gPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCAvIDMpO1xuICAgICAgY29uc3QgYmx1ZSA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoIC8gMyk7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSAzLCArK2opIHtcbiAgICAgICAgcmVkW2pdID0gZGF0YVtpXTtcbiAgICAgICAgZ3JlZW5bal0gPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgYmx1ZVtqXSA9IGRhdGFbaSArIDJdO1xuICAgICAgfVxuICAgICAgZGF0YSA9IFtyZWQsIGdyZWVuLCBibHVlXTtcbiAgICB9XG5cbiAgICBkYXRhLndpZHRoID0gcmFzdGVyLndpZHRoO1xuICAgIGRhdGEuaGVpZ2h0ID0gcmFzdGVyLmhlaWdodDtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHRpZXBvaW50cy5cbiAgICogQHJldHVybnMge09iamVjdFtdfVxuICAgKi9cbiAgZ2V0VGllUG9pbnRzKCkge1xuICAgIGlmICghdGhpcy5maWxlRGlyZWN0b3J5Lk1vZGVsVGllcG9pbnQpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCB0aWVQb2ludHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmlsZURpcmVjdG9yeS5Nb2RlbFRpZXBvaW50Lmxlbmd0aDsgaSArPSA2KSB7XG4gICAgICB0aWVQb2ludHMucHVzaCh7XG4gICAgICAgIGk6IHRoaXMuZmlsZURpcmVjdG9yeS5Nb2RlbFRpZXBvaW50W2ldLFxuICAgICAgICBqOiB0aGlzLmZpbGVEaXJlY3RvcnkuTW9kZWxUaWVwb2ludFtpICsgMV0sXG4gICAgICAgIGs6IHRoaXMuZmlsZURpcmVjdG9yeS5Nb2RlbFRpZXBvaW50W2kgKyAyXSxcbiAgICAgICAgeDogdGhpcy5maWxlRGlyZWN0b3J5Lk1vZGVsVGllcG9pbnRbaSArIDNdLFxuICAgICAgICB5OiB0aGlzLmZpbGVEaXJlY3RvcnkuTW9kZWxUaWVwb2ludFtpICsgNF0sXG4gICAgICAgIHo6IHRoaXMuZmlsZURpcmVjdG9yeS5Nb2RlbFRpZXBvaW50W2kgKyA1XSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGllUG9pbnRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBhcnNlZCBHREFMIG1ldGFkYXRhIGl0ZW1zLlxuICAgKlxuICAgKiBJZiBzYW1wbGUgaXMgcGFzc2VkIHRvIG51bGwsIGRhdGFzZXQtbGV2ZWwgbWV0YWRhdGEgd2lsbCBiZSByZXR1cm5lZC5cbiAgICogT3RoZXJ3aXNlIG9ubHkgbWV0YWRhdGEgc3BlY2lmaWMgdG8gdGhlIHByb3ZpZGVkIHNhbXBsZSB3aWxsIGJlIHJldHVybmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NhbXBsZT1udWxsXSBUaGUgc2FtcGxlIGluZGV4LlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0R0RBTE1ldGFkYXRhKHNhbXBsZSA9IG51bGwpIHtcbiAgICBjb25zdCBtZXRhZGF0YSA9IHt9O1xuICAgIGlmICghdGhpcy5maWxlRGlyZWN0b3J5LkdEQUxfTUVUQURBVEEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzdHJpbmcgPSB0aGlzLmZpbGVEaXJlY3RvcnkuR0RBTF9NRVRBREFUQTtcblxuICAgIGxldCBpdGVtcyA9IGZpbmRUYWdzQnlOYW1lKHN0cmluZywgJ0l0ZW0nKTtcblxuICAgIGlmIChzYW1wbGUgPT09IG51bGwpIHtcbiAgICAgIGl0ZW1zID0gaXRlbXMuZmlsdGVyKChpdGVtKSA9PiBnZXRBdHRyaWJ1dGUoaXRlbSwgJ3NhbXBsZScpID09PSB1bmRlZmluZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpdGVtcyA9IGl0ZW1zLmZpbHRlcigoaXRlbSkgPT4gTnVtYmVyKGdldEF0dHJpYnV0ZShpdGVtLCAnc2FtcGxlJykpID09PSBzYW1wbGUpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgIG1ldGFkYXRhW2dldEF0dHJpYnV0ZShpdGVtLCAnbmFtZScpXSA9IGl0ZW0uaW5uZXI7XG4gICAgfVxuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBHREFMIG5vZGF0YSB2YWx1ZVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfG51bGx9XG4gICAqL1xuICBnZXRHREFMTm9EYXRhKCkge1xuICAgIGlmICghdGhpcy5maWxlRGlyZWN0b3J5LkdEQUxfTk9EQVRBKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc3RyaW5nID0gdGhpcy5maWxlRGlyZWN0b3J5LkdEQUxfTk9EQVRBO1xuICAgIHJldHVybiBOdW1iZXIoc3RyaW5nLnN1YnN0cmluZygwLCBzdHJpbmcubGVuZ3RoIC0gMSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGltYWdlIG9yaWdpbiBhcyBhIFhZWi12ZWN0b3IuIFdoZW4gdGhlIGltYWdlIGhhcyBubyBhZmZpbmVcbiAgICogdHJhbnNmb3JtYXRpb24sIHRoZW4gYW4gZXhjZXB0aW9uIGlzIHRocm93bi5cbiAgICogQHJldHVybnMge0FycmF5PG51bWJlcj59IFRoZSBvcmlnaW4gYXMgYSB2ZWN0b3JcbiAgICovXG4gIGdldE9yaWdpbigpIHtcbiAgICBjb25zdCB0aWVQb2ludHMgPSB0aGlzLmZpbGVEaXJlY3RvcnkuTW9kZWxUaWVwb2ludDtcbiAgICBjb25zdCBtb2RlbFRyYW5zZm9ybWF0aW9uID0gdGhpcy5maWxlRGlyZWN0b3J5Lk1vZGVsVHJhbnNmb3JtYXRpb247XG4gICAgaWYgKHRpZVBvaW50cyAmJiB0aWVQb2ludHMubGVuZ3RoID09PSA2KSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB0aWVQb2ludHNbM10sXG4gICAgICAgIHRpZVBvaW50c1s0XSxcbiAgICAgICAgdGllUG9pbnRzWzVdLFxuICAgICAgXTtcbiAgICB9XG4gICAgaWYgKG1vZGVsVHJhbnNmb3JtYXRpb24pIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIG1vZGVsVHJhbnNmb3JtYXRpb25bM10sXG4gICAgICAgIG1vZGVsVHJhbnNmb3JtYXRpb25bN10sXG4gICAgICAgIG1vZGVsVHJhbnNmb3JtYXRpb25bMTFdLFxuICAgICAgXTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgaW1hZ2UgZG9lcyBub3QgaGF2ZSBhbiBhZmZpbmUgdHJhbnNmb3JtYXRpb24uJyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW1hZ2UgcmVzb2x1dGlvbiBhcyBhIFhZWi12ZWN0b3IuIFdoZW4gdGhlIGltYWdlIGhhcyBubyBhZmZpbmVcbiAgICogdHJhbnNmb3JtYXRpb24sIHRoZW4gYW4gZXhjZXB0aW9uIGlzIHRocm93bi5cbiAgICogQHBhcmFtIHtHZW9USUZGSW1hZ2V9IFtyZWZlcmVuY2VJbWFnZT1udWxsXSBBIHJlZmVyZW5jZSBpbWFnZSB0byBjYWxjdWxhdGUgdGhlIHJlc29sdXRpb24gZnJvbVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIGNhc2VzIHdoZW4gdGhlIGN1cnJlbnQgaW1hZ2UgZG9lcyBub3QgaGF2ZSB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZCB0YWdzIG9uIGl0cyBvd24uXG4gICAqIEByZXR1cm5zIHtBcnJheTxudW1iZXI+fSBUaGUgcmVzb2x1dGlvbiBhcyBhIHZlY3RvclxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvbihyZWZlcmVuY2VJbWFnZSA9IG51bGwpIHtcbiAgICBjb25zdCBtb2RlbFBpeGVsU2NhbGUgPSB0aGlzLmZpbGVEaXJlY3RvcnkuTW9kZWxQaXhlbFNjYWxlO1xuICAgIGNvbnN0IG1vZGVsVHJhbnNmb3JtYXRpb24gPSB0aGlzLmZpbGVEaXJlY3RvcnkuTW9kZWxUcmFuc2Zvcm1hdGlvbjtcblxuICAgIGlmIChtb2RlbFBpeGVsU2NhbGUpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIG1vZGVsUGl4ZWxTY2FsZVswXSxcbiAgICAgICAgLW1vZGVsUGl4ZWxTY2FsZVsxXSxcbiAgICAgICAgbW9kZWxQaXhlbFNjYWxlWzJdLFxuICAgICAgXTtcbiAgICB9XG4gICAgaWYgKG1vZGVsVHJhbnNmb3JtYXRpb24pIHtcbiAgICAgIGlmIChtb2RlbFRyYW5zZm9ybWF0aW9uWzFdID09PSAwICYmIG1vZGVsVHJhbnNmb3JtYXRpb25bNF0gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBtb2RlbFRyYW5zZm9ybWF0aW9uWzBdLFxuICAgICAgICAgIC1tb2RlbFRyYW5zZm9ybWF0aW9uWzVdLFxuICAgICAgICAgIG1vZGVsVHJhbnNmb3JtYXRpb25bMTBdLFxuICAgICAgICBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgTWF0aC5zcXJ0KChtb2RlbFRyYW5zZm9ybWF0aW9uWzBdICogbW9kZWxUcmFuc2Zvcm1hdGlvblswXSlcbiAgICAgICAgICArIChtb2RlbFRyYW5zZm9ybWF0aW9uWzRdICogbW9kZWxUcmFuc2Zvcm1hdGlvbls0XSkpLFxuICAgICAgICAtTWF0aC5zcXJ0KChtb2RlbFRyYW5zZm9ybWF0aW9uWzFdICogbW9kZWxUcmFuc2Zvcm1hdGlvblsxXSlcbiAgICAgICAgICArIChtb2RlbFRyYW5zZm9ybWF0aW9uWzVdICogbW9kZWxUcmFuc2Zvcm1hdGlvbls1XSkpLFxuICAgICAgICBtb2RlbFRyYW5zZm9ybWF0aW9uWzEwXV07XG4gICAgfVxuXG4gICAgaWYgKHJlZmVyZW5jZUltYWdlKSB7XG4gICAgICBjb25zdCBbcmVmUmVzWCwgcmVmUmVzWSwgcmVmUmVzWl0gPSByZWZlcmVuY2VJbWFnZS5nZXRSZXNvbHV0aW9uKCk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICByZWZSZXNYICogcmVmZXJlbmNlSW1hZ2UuZ2V0V2lkdGgoKSAvIHRoaXMuZ2V0V2lkdGgoKSxcbiAgICAgICAgcmVmUmVzWSAqIHJlZmVyZW5jZUltYWdlLmdldEhlaWdodCgpIC8gdGhpcy5nZXRIZWlnaHQoKSxcbiAgICAgICAgcmVmUmVzWiAqIHJlZmVyZW5jZUltYWdlLmdldFdpZHRoKCkgLyB0aGlzLmdldFdpZHRoKCksXG4gICAgICBdO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGltYWdlIGRvZXMgbm90IGhhdmUgYW4gYWZmaW5lIHRyYW5zZm9ybWF0aW9uLicpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHBpeGVscyBvZiB0aGUgaW1hZ2UgZGVwaWN0IGFuIGFyZWEgKG9yIHBvaW50KS5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIHBpeGVscyBhcmUgYSBwb2ludFxuICAgKi9cbiAgcGl4ZWxJc0FyZWEoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2VvS2V5cy5HVFJhc3RlclR5cGVHZW9LZXkgPT09IDE7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW1hZ2UgYm91bmRpbmcgYm94IGFzIGFuIGFycmF5IG9mIDQgdmFsdWVzOiBtaW4teCwgbWluLXksXG4gICAqIG1heC14IGFuZCBtYXgteS4gV2hlbiB0aGUgaW1hZ2UgaGFzIG5vIGFmZmluZSB0cmFuc2Zvcm1hdGlvbiwgdGhlbiBhblxuICAgKiBleGNlcHRpb24gaXMgdGhyb3duLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt0aWxlZ3JpZD1mYWxzZV0gSWYgdHJ1ZSByZXR1cm4gZXh0ZW50IGZvciBhIHRpbGVncmlkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRob3V0IGFkanVzdG1lbnQgZm9yIE1vZGVsVHJhbnNmb3JtYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheTxudW1iZXI+fSBUaGUgYm91bmRpbmcgYm94XG4gICAqL1xuICBnZXRCb3VuZGluZ0JveCh0aWxlZ3JpZCA9IGZhbHNlKSB7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKTtcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcblxuICAgIGlmICh0aGlzLmZpbGVEaXJlY3RvcnkuTW9kZWxUcmFuc2Zvcm1hdGlvbiAmJiAhdGlsZWdyaWQpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgY29uc3QgW2EsIGIsIGMsIGQsIGUsIGYsIGcsIGhdID0gdGhpcy5maWxlRGlyZWN0b3J5Lk1vZGVsVHJhbnNmb3JtYXRpb247XG5cbiAgICAgIGNvbnN0IGNvcm5lcnMgPSBbXG4gICAgICAgIFswLCAwXSxcbiAgICAgICAgWzAsIGhlaWdodF0sXG4gICAgICAgIFt3aWR0aCwgMF0sXG4gICAgICAgIFt3aWR0aCwgaGVpZ2h0XSxcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IHByb2plY3RlZCA9IGNvcm5lcnMubWFwKChbSSwgSl0pID0+IFtcbiAgICAgICAgZCArIChhICogSSkgKyAoYiAqIEopLFxuICAgICAgICBoICsgKGUgKiBJKSArIChmICogSiksXG4gICAgICBdKTtcblxuICAgICAgY29uc3QgeHMgPSBwcm9qZWN0ZWQubWFwKChwdCkgPT4gcHRbMF0pO1xuICAgICAgY29uc3QgeXMgPSBwcm9qZWN0ZWQubWFwKChwdCkgPT4gcHRbMV0pO1xuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBNYXRoLm1pbiguLi54cyksXG4gICAgICAgIE1hdGgubWluKC4uLnlzKSxcbiAgICAgICAgTWF0aC5tYXgoLi4ueHMpLFxuICAgICAgICBNYXRoLm1heCguLi55cyksXG4gICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvcmlnaW4gPSB0aGlzLmdldE9yaWdpbigpO1xuICAgICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbigpO1xuXG4gICAgICBjb25zdCB4MSA9IG9yaWdpblswXTtcbiAgICAgIGNvbnN0IHkxID0gb3JpZ2luWzFdO1xuXG4gICAgICBjb25zdCB4MiA9IHgxICsgKHJlc29sdXRpb25bMF0gKiB3aWR0aCk7XG4gICAgICBjb25zdCB5MiA9IHkxICsgKHJlc29sdXRpb25bMV0gKiBoZWlnaHQpO1xuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBNYXRoLm1pbih4MSwgeDIpLFxuICAgICAgICBNYXRoLm1pbih5MSwgeTIpLFxuICAgICAgICBNYXRoLm1heCh4MSwgeDIpLFxuICAgICAgICBNYXRoLm1heCh5MSwgeTIpLFxuICAgICAgXTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgR2VvVElGRkltYWdlO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/geotiffimage.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/geotiffwriter.js":
/*!***********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/geotiffwriter.js ***!
  \***********************************************************/
/*! exports provided: writeGeotiff */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"writeGeotiff\", function() { return writeGeotiff; });\n/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globals.js */ \"./node_modules/geotiff/dist-module/globals.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/geotiff/dist-module/utils.js\");\n/*\n  Some parts of this file are based on UTIF.js,\n  which was released under the MIT License.\n  You can view that here:\n  https://github.com/photopea/UTIF.js/blob/master/LICENSE\n*/\n\n\n\nconst tagName2Code = Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"invert\"])(_globals_js__WEBPACK_IMPORTED_MODULE_0__[\"fieldTagNames\"]);\nconst geoKeyName2Code = Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"invert\"])(_globals_js__WEBPACK_IMPORTED_MODULE_0__[\"geoKeyNames\"]);\nconst name2code = {};\nObject(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assign\"])(name2code, tagName2Code);\nObject(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"assign\"])(name2code, geoKeyName2Code);\nconst typeName2byte = Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"invert\"])(_globals_js__WEBPACK_IMPORTED_MODULE_0__[\"fieldTypeNames\"]);\n\n// config variables\nconst numBytesInIfd = 1000;\n\nconst _binBE = {\n  nextZero: (data, o) => {\n    let oincr = o;\n    while (data[oincr] !== 0) {\n      oincr++;\n    }\n    return oincr;\n  },\n  readUshort: (buff, p) => {\n    return (buff[p] << 8) | buff[p + 1];\n  },\n  readShort: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 1];\n    a[1] = buff[p + 0];\n    return _binBE.i16[0];\n  },\n  readInt: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.i32[0];\n  },\n  readUint: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.ui32[0];\n  },\n  readASCII: (buff, p, l) => {\n    return l.map((i) => String.fromCharCode(buff[p + i])).join('');\n  },\n  readFloat: (buff, p) => {\n    const a = _binBE.ui8;\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"times\"])(4, (i) => {\n      a[i] = buff[p + 3 - i];\n    });\n    return _binBE.fl32[0];\n  },\n  readDouble: (buff, p) => {\n    const a = _binBE.ui8;\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"times\"])(8, (i) => {\n      a[i] = buff[p + 7 - i];\n    });\n    return _binBE.fl64[0];\n  },\n  writeUshort: (buff, p, n) => {\n    buff[p] = (n >> 8) & 255;\n    buff[p + 1] = n & 255;\n  },\n  writeUint: (buff, p, n) => {\n    buff[p] = (n >> 24) & 255;\n    buff[p + 1] = (n >> 16) & 255;\n    buff[p + 2] = (n >> 8) & 255;\n    buff[p + 3] = (n >> 0) & 255;\n  },\n  writeASCII: (buff, p, s) => {\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"times\"])(s.length, (i) => {\n      buff[p + i] = s.charCodeAt(i);\n    });\n  },\n  ui8: new Uint8Array(8),\n};\n\n_binBE.fl64 = new Float64Array(_binBE.ui8.buffer);\n\n_binBE.writeDouble = (buff, p, n) => {\n  _binBE.fl64[0] = n;\n  Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"times\"])(8, (i) => {\n    buff[p + i] = _binBE.ui8[7 - i];\n  });\n};\n\nconst _writeIFD = (bin, data, _offset, ifd) => {\n  let offset = _offset;\n\n  const keys = Object.keys(ifd).filter((key) => {\n    return key !== undefined && key !== null && key !== 'undefined';\n  });\n\n  bin.writeUshort(data, offset, keys.length);\n  offset += 2;\n\n  let eoff = offset + (12 * keys.length) + 4;\n\n  for (const key of keys) {\n    let tag = null;\n    if (typeof key === 'number') {\n      tag = key;\n    } else if (typeof key === 'string') {\n      tag = parseInt(key, 10);\n    }\n\n    const typeName = _globals_js__WEBPACK_IMPORTED_MODULE_0__[\"fieldTagTypes\"][tag];\n    const typeNum = typeName2byte[typeName];\n\n    if (typeName == null || typeName === undefined || typeof typeName === 'undefined') {\n      throw new Error(`unknown type of tag: ${tag}`);\n    }\n\n    let val = ifd[key];\n\n    if (val === undefined) {\n      throw new Error(`failed to get value for key ${key}`);\n    }\n\n    // ASCIIZ format with trailing 0 character\n    // http://www.fileformat.info/format/tiff/corion.htm\n    // https://stackoverflow.com/questions/7783044/whats-the-difference-between-asciiz-vs-ascii\n    if (typeName === 'ASCII' && typeof val === 'string' && Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"endsWith\"])(val, '\\u0000') === false) {\n      val += '\\u0000';\n    }\n\n    const num = val.length;\n\n    bin.writeUshort(data, offset, tag);\n    offset += 2;\n\n    bin.writeUshort(data, offset, typeNum);\n    offset += 2;\n\n    bin.writeUint(data, offset, num);\n    offset += 4;\n\n    let dlen = [-1, 1, 1, 2, 4, 8, 0, 0, 0, 0, 0, 0, 8][typeNum] * num;\n    let toff = offset;\n\n    if (dlen > 4) {\n      bin.writeUint(data, offset, eoff);\n      toff = eoff;\n    }\n\n    if (typeName === 'ASCII') {\n      bin.writeASCII(data, toff, val);\n    } else if (typeName === 'SHORT') {\n      Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"times\"])(num, (i) => {\n        bin.writeUshort(data, toff + (2 * i), val[i]);\n      });\n    } else if (typeName === 'LONG') {\n      Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"times\"])(num, (i) => {\n        bin.writeUint(data, toff + (4 * i), val[i]);\n      });\n    } else if (typeName === 'RATIONAL') {\n      Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"times\"])(num, (i) => {\n        bin.writeUint(data, toff + (8 * i), Math.round(val[i] * 10000));\n        bin.writeUint(data, toff + (8 * i) + 4, 10000);\n      });\n    } else if (typeName === 'DOUBLE') {\n      Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"times\"])(num, (i) => {\n        bin.writeDouble(data, toff + (8 * i), val[i]);\n      });\n    }\n\n    if (dlen > 4) {\n      dlen += (dlen & 1);\n      eoff += dlen;\n    }\n\n    offset += 4;\n  }\n\n  return [offset, eoff];\n};\n\nconst encodeIfds = (ifds) => {\n  const data = new Uint8Array(numBytesInIfd);\n  let offset = 4;\n  const bin = _binBE;\n\n  // set big-endian byte-order\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[0] = 77;\n  data[1] = 77;\n\n  // set format-version number\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[3] = 42;\n\n  let ifdo = 8;\n\n  bin.writeUint(data, offset, ifdo);\n\n  offset += 4;\n\n  ifds.forEach((ifd, i) => {\n    const noffs = _writeIFD(bin, data, ifdo, ifd);\n    ifdo = noffs[1];\n    if (i < ifds.length - 1) {\n      bin.writeUint(data, noffs[0], ifdo);\n    }\n  });\n\n  if (data.slice) {\n    return data.slice(0, ifdo).buffer;\n  }\n\n  // node hasn't implemented slice on Uint8Array yet\n  const result = new Uint8Array(ifdo);\n  for (let i = 0; i < ifdo; i++) {\n    result[i] = data[i];\n  }\n  return result.buffer;\n};\n\nconst encodeImage = (values, width, height, metadata) => {\n  if (height === undefined || height === null) {\n    throw new Error(`you passed into encodeImage a width of type ${height}`);\n  }\n\n  if (width === undefined || width === null) {\n    throw new Error(`you passed into encodeImage a width of type ${width}`);\n  }\n\n  const ifd = {\n    256: [width], // ImageWidth\n    257: [height], // ImageLength\n    273: [numBytesInIfd], // strips offset\n    278: [height], // RowsPerStrip\n    305: 'geotiff.js', // no array for ASCII(Z)\n  };\n\n  if (metadata) {\n    for (const i in metadata) {\n      if (metadata.hasOwnProperty(i)) {\n        ifd[i] = metadata[i];\n      }\n    }\n  }\n\n  const prfx = new Uint8Array(encodeIfds([ifd]));\n\n  const img = new Uint8Array(values);\n\n  const samplesPerPixel = ifd[277];\n\n  const data = new Uint8Array(numBytesInIfd + (width * height * samplesPerPixel));\n  Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"times\"])(prfx.length, (i) => {\n    data[i] = prfx[i];\n  });\n  Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"forEach\"])(img, (value, i) => {\n    data[numBytesInIfd + i] = value;\n  });\n\n  return data.buffer;\n};\n\nconst convertToTids = (input) => {\n  const result = {};\n  for (const key in input) {\n    if (key !== 'StripOffsets') {\n      if (!name2code[key]) {\n        console.error(key, 'not in name2code:', Object.keys(name2code));\n      }\n      result[name2code[key]] = input[key];\n    }\n  }\n  return result;\n};\n\nconst toArray = (input) => {\n  if (Array.isArray(input)) {\n    return input;\n  }\n  return [input];\n};\n\nconst metadataDefaults = [\n  ['Compression', 1], // no compression\n  ['PlanarConfiguration', 1],\n  ['ExtraSamples', 0],\n];\n\nfunction writeGeotiff(data, metadata) {\n  const isFlattened = typeof data[0] === 'number';\n\n  let height;\n  let numBands;\n  let width;\n  let flattenedValues;\n\n  if (isFlattened) {\n    height = metadata.height || metadata.ImageLength;\n    width = metadata.width || metadata.ImageWidth;\n    numBands = data.length / (height * width);\n    flattenedValues = data;\n  } else {\n    numBands = data.length;\n    height = data[0].length;\n    width = data[0][0].length;\n    flattenedValues = [];\n    Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"times\"])(height, (rowIndex) => {\n      Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"times\"])(width, (columnIndex) => {\n        Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"times\"])(numBands, (bandIndex) => {\n          flattenedValues.push(data[bandIndex][rowIndex][columnIndex]);\n        });\n      });\n    });\n  }\n\n  metadata.ImageLength = height;\n  delete metadata.height;\n  metadata.ImageWidth = width;\n  delete metadata.width;\n\n  // consult https://www.loc.gov/preservation/digital/formats/content/tiff_tags.shtml\n\n  if (!metadata.BitsPerSample) {\n    metadata.BitsPerSample = Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"times\"])(numBands, () => 8);\n  }\n\n  metadataDefaults.forEach((tag) => {\n    const key = tag[0];\n    if (!metadata[key]) {\n      const value = tag[1];\n      metadata[key] = value;\n    }\n  });\n\n  // The color space of the image data.\n  // 1=black is zero and 2=RGB.\n  if (!metadata.PhotometricInterpretation) {\n    metadata.PhotometricInterpretation = metadata.BitsPerSample.length === 3 ? 2 : 1;\n  }\n\n  // The number of components per pixel.\n  if (!metadata.SamplesPerPixel) {\n    metadata.SamplesPerPixel = [numBands];\n  }\n\n  if (!metadata.StripByteCounts) {\n    // we are only writing one strip\n    metadata.StripByteCounts = [numBands * height * width];\n  }\n\n  if (!metadata.ModelPixelScale) {\n    // assumes raster takes up exactly the whole globe\n    metadata.ModelPixelScale = [360 / width, 180 / height, 0];\n  }\n\n  if (!metadata.SampleFormat) {\n    metadata.SampleFormat = Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"times\"])(numBands, () => 1);\n  }\n\n  // if didn't pass in projection information, assume the popular 4326 \"geographic projection\"\n  if (!metadata.hasOwnProperty('GeographicTypeGeoKey') && !metadata.hasOwnProperty('ProjectedCSTypeGeoKey')) {\n    metadata.GeographicTypeGeoKey = 4326;\n    metadata.ModelTiepoint = [0, 0, 0, -180, 90, 0]; // raster fits whole globe\n    metadata.GeogCitationGeoKey = 'WGS 84';\n    metadata.GTModelTypeGeoKey = 2;\n  }\n\n  const geoKeys = Object.keys(metadata)\n    .filter((key) => Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__[\"endsWith\"])(key, 'GeoKey'))\n    .sort((a, b) => name2code[a] - name2code[b]);\n\n  if (!metadata.GeoAsciiParams) {\n    let geoAsciiParams = '';\n    geoKeys.forEach((name) => {\n      const code = Number(name2code[name]);\n      const tagType = _globals_js__WEBPACK_IMPORTED_MODULE_0__[\"fieldTagTypes\"][code];\n      if (tagType === 'ASCII') {\n        geoAsciiParams += `${metadata[name].toString()}\\u0000`;\n      }\n    });\n    if (geoAsciiParams.length > 0) {\n      metadata.GeoAsciiParams = geoAsciiParams;\n    }\n  }\n\n  if (!metadata.GeoKeyDirectory) {\n    const NumberOfKeys = geoKeys.length;\n\n    const GeoKeyDirectory = [1, 1, 0, NumberOfKeys];\n    geoKeys.forEach((geoKey) => {\n      const KeyID = Number(name2code[geoKey]);\n      GeoKeyDirectory.push(KeyID);\n\n      let Count;\n      let TIFFTagLocation;\n      let valueOffset;\n      if (_globals_js__WEBPACK_IMPORTED_MODULE_0__[\"fieldTagTypes\"][KeyID] === 'SHORT') {\n        Count = 1;\n        TIFFTagLocation = 0;\n        valueOffset = metadata[geoKey];\n      } else if (geoKey === 'GeogCitationGeoKey') {\n        Count = metadata.GeoAsciiParams.length;\n        TIFFTagLocation = Number(name2code.GeoAsciiParams);\n        valueOffset = 0;\n      } else {\n        console.log(`[geotiff.js] couldn't get TIFFTagLocation for ${geoKey}`);\n      }\n      GeoKeyDirectory.push(TIFFTagLocation);\n      GeoKeyDirectory.push(Count);\n      GeoKeyDirectory.push(valueOffset);\n    });\n    metadata.GeoKeyDirectory = GeoKeyDirectory;\n  }\n\n  // delete GeoKeys from metadata, because stored in GeoKeyDirectory tag\n  for (const geoKey of geoKeys) {\n    if (metadata.hasOwnProperty(geoKey)) {\n      delete metadata[geoKey];\n    }\n  }\n\n  [\n    'Compression',\n    'ExtraSamples',\n    'GeographicTypeGeoKey',\n    'GTModelTypeGeoKey',\n    'GTRasterTypeGeoKey',\n    'ImageLength', // synonym of ImageHeight\n    'ImageWidth',\n    'Orientation',\n    'PhotometricInterpretation',\n    'ProjectedCSTypeGeoKey',\n    'PlanarConfiguration',\n    'ResolutionUnit',\n    'SamplesPerPixel',\n    'XPosition',\n    'YPosition',\n    'RowsPerStrip',\n  ].forEach((name) => {\n    if (metadata[name]) {\n      metadata[name] = toArray(metadata[name]);\n    }\n  });\n\n  const encodedMetadata = convertToTids(metadata);\n\n  const outputImage = encodeImage(flattenedValues, width, height, encodedMetadata);\n\n  return outputImage;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9nZW90aWZmd3JpdGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvZ2VvdGlmZndyaXRlci5qcz9hMWYxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gIFNvbWUgcGFydHMgb2YgdGhpcyBmaWxlIGFyZSBiYXNlZCBvbiBVVElGLmpzLFxuICB3aGljaCB3YXMgcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICBZb3UgY2FuIHZpZXcgdGhhdCBoZXJlOlxuICBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9wZWEvVVRJRi5qcy9ibG9iL21hc3Rlci9MSUNFTlNFXG4qL1xuaW1wb3J0IHsgZmllbGRUYWdOYW1lcywgZmllbGRUYWdUeXBlcywgZmllbGRUeXBlTmFtZXMsIGdlb0tleU5hbWVzIH0gZnJvbSAnLi9nbG9iYWxzLmpzJztcbmltcG9ydCB7IGFzc2lnbiwgZW5kc1dpdGgsIGZvckVhY2gsIGludmVydCwgdGltZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcblxuY29uc3QgdGFnTmFtZTJDb2RlID0gaW52ZXJ0KGZpZWxkVGFnTmFtZXMpO1xuY29uc3QgZ2VvS2V5TmFtZTJDb2RlID0gaW52ZXJ0KGdlb0tleU5hbWVzKTtcbmNvbnN0IG5hbWUyY29kZSA9IHt9O1xuYXNzaWduKG5hbWUyY29kZSwgdGFnTmFtZTJDb2RlKTtcbmFzc2lnbihuYW1lMmNvZGUsIGdlb0tleU5hbWUyQ29kZSk7XG5jb25zdCB0eXBlTmFtZTJieXRlID0gaW52ZXJ0KGZpZWxkVHlwZU5hbWVzKTtcblxuLy8gY29uZmlnIHZhcmlhYmxlc1xuY29uc3QgbnVtQnl0ZXNJbklmZCA9IDEwMDA7XG5cbmNvbnN0IF9iaW5CRSA9IHtcbiAgbmV4dFplcm86IChkYXRhLCBvKSA9PiB7XG4gICAgbGV0IG9pbmNyID0gbztcbiAgICB3aGlsZSAoZGF0YVtvaW5jcl0gIT09IDApIHtcbiAgICAgIG9pbmNyKys7XG4gICAgfVxuICAgIHJldHVybiBvaW5jcjtcbiAgfSxcbiAgcmVhZFVzaG9ydDogKGJ1ZmYsIHApID0+IHtcbiAgICByZXR1cm4gKGJ1ZmZbcF0gPDwgOCkgfCBidWZmW3AgKyAxXTtcbiAgfSxcbiAgcmVhZFNob3J0OiAoYnVmZiwgcCkgPT4ge1xuICAgIGNvbnN0IGEgPSBfYmluQkUudWk4O1xuICAgIGFbMF0gPSBidWZmW3AgKyAxXTtcbiAgICBhWzFdID0gYnVmZltwICsgMF07XG4gICAgcmV0dXJuIF9iaW5CRS5pMTZbMF07XG4gIH0sXG4gIHJlYWRJbnQ6IChidWZmLCBwKSA9PiB7XG4gICAgY29uc3QgYSA9IF9iaW5CRS51aTg7XG4gICAgYVswXSA9IGJ1ZmZbcCArIDNdO1xuICAgIGFbMV0gPSBidWZmW3AgKyAyXTtcbiAgICBhWzJdID0gYnVmZltwICsgMV07XG4gICAgYVszXSA9IGJ1ZmZbcCArIDBdO1xuICAgIHJldHVybiBfYmluQkUuaTMyWzBdO1xuICB9LFxuICByZWFkVWludDogKGJ1ZmYsIHApID0+IHtcbiAgICBjb25zdCBhID0gX2JpbkJFLnVpODtcbiAgICBhWzBdID0gYnVmZltwICsgM107XG4gICAgYVsxXSA9IGJ1ZmZbcCArIDJdO1xuICAgIGFbMl0gPSBidWZmW3AgKyAxXTtcbiAgICBhWzNdID0gYnVmZltwICsgMF07XG4gICAgcmV0dXJuIF9iaW5CRS51aTMyWzBdO1xuICB9LFxuICByZWFkQVNDSUk6IChidWZmLCBwLCBsKSA9PiB7XG4gICAgcmV0dXJuIGwubWFwKChpKSA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZmZbcCArIGldKSkuam9pbignJyk7XG4gIH0sXG4gIHJlYWRGbG9hdDogKGJ1ZmYsIHApID0+IHtcbiAgICBjb25zdCBhID0gX2JpbkJFLnVpODtcbiAgICB0aW1lcyg0LCAoaSkgPT4ge1xuICAgICAgYVtpXSA9IGJ1ZmZbcCArIDMgLSBpXTtcbiAgICB9KTtcbiAgICByZXR1cm4gX2JpbkJFLmZsMzJbMF07XG4gIH0sXG4gIHJlYWREb3VibGU6IChidWZmLCBwKSA9PiB7XG4gICAgY29uc3QgYSA9IF9iaW5CRS51aTg7XG4gICAgdGltZXMoOCwgKGkpID0+IHtcbiAgICAgIGFbaV0gPSBidWZmW3AgKyA3IC0gaV07XG4gICAgfSk7XG4gICAgcmV0dXJuIF9iaW5CRS5mbDY0WzBdO1xuICB9LFxuICB3cml0ZVVzaG9ydDogKGJ1ZmYsIHAsIG4pID0+IHtcbiAgICBidWZmW3BdID0gKG4gPj4gOCkgJiAyNTU7XG4gICAgYnVmZltwICsgMV0gPSBuICYgMjU1O1xuICB9LFxuICB3cml0ZVVpbnQ6IChidWZmLCBwLCBuKSA9PiB7XG4gICAgYnVmZltwXSA9IChuID4+IDI0KSAmIDI1NTtcbiAgICBidWZmW3AgKyAxXSA9IChuID4+IDE2KSAmIDI1NTtcbiAgICBidWZmW3AgKyAyXSA9IChuID4+IDgpICYgMjU1O1xuICAgIGJ1ZmZbcCArIDNdID0gKG4gPj4gMCkgJiAyNTU7XG4gIH0sXG4gIHdyaXRlQVNDSUk6IChidWZmLCBwLCBzKSA9PiB7XG4gICAgdGltZXMocy5sZW5ndGgsIChpKSA9PiB7XG4gICAgICBidWZmW3AgKyBpXSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICB9KTtcbiAgfSxcbiAgdWk4OiBuZXcgVWludDhBcnJheSg4KSxcbn07XG5cbl9iaW5CRS5mbDY0ID0gbmV3IEZsb2F0NjRBcnJheShfYmluQkUudWk4LmJ1ZmZlcik7XG5cbl9iaW5CRS53cml0ZURvdWJsZSA9IChidWZmLCBwLCBuKSA9PiB7XG4gIF9iaW5CRS5mbDY0WzBdID0gbjtcbiAgdGltZXMoOCwgKGkpID0+IHtcbiAgICBidWZmW3AgKyBpXSA9IF9iaW5CRS51aThbNyAtIGldO1xuICB9KTtcbn07XG5cbmNvbnN0IF93cml0ZUlGRCA9IChiaW4sIGRhdGEsIF9vZmZzZXQsIGlmZCkgPT4ge1xuICBsZXQgb2Zmc2V0ID0gX29mZnNldDtcblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaWZkKS5maWx0ZXIoKGtleSkgPT4ge1xuICAgIHJldHVybiBrZXkgIT09IHVuZGVmaW5lZCAmJiBrZXkgIT09IG51bGwgJiYga2V5ICE9PSAndW5kZWZpbmVkJztcbiAgfSk7XG5cbiAgYmluLndyaXRlVXNob3J0KGRhdGEsIG9mZnNldCwga2V5cy5sZW5ndGgpO1xuICBvZmZzZXQgKz0gMjtcblxuICBsZXQgZW9mZiA9IG9mZnNldCArICgxMiAqIGtleXMubGVuZ3RoKSArIDQ7XG5cbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGxldCB0YWcgPSBudWxsO1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnbnVtYmVyJykge1xuICAgICAgdGFnID0ga2V5O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRhZyA9IHBhcnNlSW50KGtleSwgMTApO1xuICAgIH1cblxuICAgIGNvbnN0IHR5cGVOYW1lID0gZmllbGRUYWdUeXBlc1t0YWddO1xuICAgIGNvbnN0IHR5cGVOdW0gPSB0eXBlTmFtZTJieXRlW3R5cGVOYW1lXTtcblxuICAgIGlmICh0eXBlTmFtZSA9PSBudWxsIHx8IHR5cGVOYW1lID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGVOYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHR5cGUgb2YgdGFnOiAke3RhZ31gKTtcbiAgICB9XG5cbiAgICBsZXQgdmFsID0gaWZkW2tleV07XG5cbiAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgZmFpbGVkIHRvIGdldCB2YWx1ZSBmb3Iga2V5ICR7a2V5fWApO1xuICAgIH1cblxuICAgIC8vIEFTQ0lJWiBmb3JtYXQgd2l0aCB0cmFpbGluZyAwIGNoYXJhY3RlclxuICAgIC8vIGh0dHA6Ly93d3cuZmlsZWZvcm1hdC5pbmZvL2Zvcm1hdC90aWZmL2Nvcmlvbi5odG1cbiAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83NzgzMDQ0L3doYXRzLXRoZS1kaWZmZXJlbmNlLWJldHdlZW4tYXNjaWl6LXZzLWFzY2lpXG4gICAgaWYgKHR5cGVOYW1lID09PSAnQVNDSUknICYmIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnICYmIGVuZHNXaXRoKHZhbCwgJ1xcdTAwMDAnKSA9PT0gZmFsc2UpIHtcbiAgICAgIHZhbCArPSAnXFx1MDAwMCc7XG4gICAgfVxuXG4gICAgY29uc3QgbnVtID0gdmFsLmxlbmd0aDtcblxuICAgIGJpbi53cml0ZVVzaG9ydChkYXRhLCBvZmZzZXQsIHRhZyk7XG4gICAgb2Zmc2V0ICs9IDI7XG5cbiAgICBiaW4ud3JpdGVVc2hvcnQoZGF0YSwgb2Zmc2V0LCB0eXBlTnVtKTtcbiAgICBvZmZzZXQgKz0gMjtcblxuICAgIGJpbi53cml0ZVVpbnQoZGF0YSwgb2Zmc2V0LCBudW0pO1xuICAgIG9mZnNldCArPSA0O1xuXG4gICAgbGV0IGRsZW4gPSBbLTEsIDEsIDEsIDIsIDQsIDgsIDAsIDAsIDAsIDAsIDAsIDAsIDhdW3R5cGVOdW1dICogbnVtO1xuICAgIGxldCB0b2ZmID0gb2Zmc2V0O1xuXG4gICAgaWYgKGRsZW4gPiA0KSB7XG4gICAgICBiaW4ud3JpdGVVaW50KGRhdGEsIG9mZnNldCwgZW9mZik7XG4gICAgICB0b2ZmID0gZW9mZjtcbiAgICB9XG5cbiAgICBpZiAodHlwZU5hbWUgPT09ICdBU0NJSScpIHtcbiAgICAgIGJpbi53cml0ZUFTQ0lJKGRhdGEsIHRvZmYsIHZhbCk7XG4gICAgfSBlbHNlIGlmICh0eXBlTmFtZSA9PT0gJ1NIT1JUJykge1xuICAgICAgdGltZXMobnVtLCAoaSkgPT4ge1xuICAgICAgICBiaW4ud3JpdGVVc2hvcnQoZGF0YSwgdG9mZiArICgyICogaSksIHZhbFtpXSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVOYW1lID09PSAnTE9ORycpIHtcbiAgICAgIHRpbWVzKG51bSwgKGkpID0+IHtcbiAgICAgICAgYmluLndyaXRlVWludChkYXRhLCB0b2ZmICsgKDQgKiBpKSwgdmFsW2ldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZU5hbWUgPT09ICdSQVRJT05BTCcpIHtcbiAgICAgIHRpbWVzKG51bSwgKGkpID0+IHtcbiAgICAgICAgYmluLndyaXRlVWludChkYXRhLCB0b2ZmICsgKDggKiBpKSwgTWF0aC5yb3VuZCh2YWxbaV0gKiAxMDAwMCkpO1xuICAgICAgICBiaW4ud3JpdGVVaW50KGRhdGEsIHRvZmYgKyAoOCAqIGkpICsgNCwgMTAwMDApO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlTmFtZSA9PT0gJ0RPVUJMRScpIHtcbiAgICAgIHRpbWVzKG51bSwgKGkpID0+IHtcbiAgICAgICAgYmluLndyaXRlRG91YmxlKGRhdGEsIHRvZmYgKyAoOCAqIGkpLCB2YWxbaV0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGRsZW4gPiA0KSB7XG4gICAgICBkbGVuICs9IChkbGVuICYgMSk7XG4gICAgICBlb2ZmICs9IGRsZW47XG4gICAgfVxuXG4gICAgb2Zmc2V0ICs9IDQ7XG4gIH1cblxuICByZXR1cm4gW29mZnNldCwgZW9mZl07XG59O1xuXG5jb25zdCBlbmNvZGVJZmRzID0gKGlmZHMpID0+IHtcbiAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KG51bUJ5dGVzSW5JZmQpO1xuICBsZXQgb2Zmc2V0ID0gNDtcbiAgY29uc3QgYmluID0gX2JpbkJFO1xuXG4gIC8vIHNldCBiaWctZW5kaWFuIGJ5dGUtb3JkZXJcbiAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVElGRiNCeXRlX29yZGVyXG4gIGRhdGFbMF0gPSA3NztcbiAgZGF0YVsxXSA9IDc3O1xuXG4gIC8vIHNldCBmb3JtYXQtdmVyc2lvbiBudW1iZXJcbiAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVElGRiNCeXRlX29yZGVyXG4gIGRhdGFbM10gPSA0MjtcblxuICBsZXQgaWZkbyA9IDg7XG5cbiAgYmluLndyaXRlVWludChkYXRhLCBvZmZzZXQsIGlmZG8pO1xuXG4gIG9mZnNldCArPSA0O1xuXG4gIGlmZHMuZm9yRWFjaCgoaWZkLCBpKSA9PiB7XG4gICAgY29uc3Qgbm9mZnMgPSBfd3JpdGVJRkQoYmluLCBkYXRhLCBpZmRvLCBpZmQpO1xuICAgIGlmZG8gPSBub2Zmc1sxXTtcbiAgICBpZiAoaSA8IGlmZHMubGVuZ3RoIC0gMSkge1xuICAgICAgYmluLndyaXRlVWludChkYXRhLCBub2Zmc1swXSwgaWZkbyk7XG4gICAgfVxuICB9KTtcblxuICBpZiAoZGF0YS5zbGljZSkge1xuICAgIHJldHVybiBkYXRhLnNsaWNlKDAsIGlmZG8pLmJ1ZmZlcjtcbiAgfVxuXG4gIC8vIG5vZGUgaGFzbid0IGltcGxlbWVudGVkIHNsaWNlIG9uIFVpbnQ4QXJyYXkgeWV0XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGlmZG8pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlmZG87IGkrKykge1xuICAgIHJlc3VsdFtpXSA9IGRhdGFbaV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5idWZmZXI7XG59O1xuXG5jb25zdCBlbmNvZGVJbWFnZSA9ICh2YWx1ZXMsIHdpZHRoLCBoZWlnaHQsIG1ldGFkYXRhKSA9PiB7XG4gIGlmIChoZWlnaHQgPT09IHVuZGVmaW5lZCB8fCBoZWlnaHQgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHlvdSBwYXNzZWQgaW50byBlbmNvZGVJbWFnZSBhIHdpZHRoIG9mIHR5cGUgJHtoZWlnaHR9YCk7XG4gIH1cblxuICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCB8fCB3aWR0aCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgeW91IHBhc3NlZCBpbnRvIGVuY29kZUltYWdlIGEgd2lkdGggb2YgdHlwZSAke3dpZHRofWApO1xuICB9XG5cbiAgY29uc3QgaWZkID0ge1xuICAgIDI1NjogW3dpZHRoXSwgLy8gSW1hZ2VXaWR0aFxuICAgIDI1NzogW2hlaWdodF0sIC8vIEltYWdlTGVuZ3RoXG4gICAgMjczOiBbbnVtQnl0ZXNJbklmZF0sIC8vIHN0cmlwcyBvZmZzZXRcbiAgICAyNzg6IFtoZWlnaHRdLCAvLyBSb3dzUGVyU3RyaXBcbiAgICAzMDU6ICdnZW90aWZmLmpzJywgLy8gbm8gYXJyYXkgZm9yIEFTQ0lJKFopXG4gIH07XG5cbiAgaWYgKG1ldGFkYXRhKSB7XG4gICAgZm9yIChjb25zdCBpIGluIG1ldGFkYXRhKSB7XG4gICAgICBpZiAobWV0YWRhdGEuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgaWZkW2ldID0gbWV0YWRhdGFbaV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgcHJmeCA9IG5ldyBVaW50OEFycmF5KGVuY29kZUlmZHMoW2lmZF0pKTtcblxuICBjb25zdCBpbWcgPSBuZXcgVWludDhBcnJheSh2YWx1ZXMpO1xuXG4gIGNvbnN0IHNhbXBsZXNQZXJQaXhlbCA9IGlmZFsyNzddO1xuXG4gIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShudW1CeXRlc0luSWZkICsgKHdpZHRoICogaGVpZ2h0ICogc2FtcGxlc1BlclBpeGVsKSk7XG4gIHRpbWVzKHByZngubGVuZ3RoLCAoaSkgPT4ge1xuICAgIGRhdGFbaV0gPSBwcmZ4W2ldO1xuICB9KTtcbiAgZm9yRWFjaChpbWcsICh2YWx1ZSwgaSkgPT4ge1xuICAgIGRhdGFbbnVtQnl0ZXNJbklmZCArIGldID0gdmFsdWU7XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhLmJ1ZmZlcjtcbn07XG5cbmNvbnN0IGNvbnZlcnRUb1RpZHMgPSAoaW5wdXQpID0+IHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIGlucHV0KSB7XG4gICAgaWYgKGtleSAhPT0gJ1N0cmlwT2Zmc2V0cycpIHtcbiAgICAgIGlmICghbmFtZTJjb2RlW2tleV0pIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihrZXksICdub3QgaW4gbmFtZTJjb2RlOicsIE9iamVjdC5rZXlzKG5hbWUyY29kZSkpO1xuICAgICAgfVxuICAgICAgcmVzdWx0W25hbWUyY29kZVtrZXldXSA9IGlucHV0W2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5jb25zdCB0b0FycmF5ID0gKGlucHV0KSA9PiB7XG4gIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgIHJldHVybiBpbnB1dDtcbiAgfVxuICByZXR1cm4gW2lucHV0XTtcbn07XG5cbmNvbnN0IG1ldGFkYXRhRGVmYXVsdHMgPSBbXG4gIFsnQ29tcHJlc3Npb24nLCAxXSwgLy8gbm8gY29tcHJlc3Npb25cbiAgWydQbGFuYXJDb25maWd1cmF0aW9uJywgMV0sXG4gIFsnRXh0cmFTYW1wbGVzJywgMF0sXG5dO1xuXG5leHBvcnQgZnVuY3Rpb24gd3JpdGVHZW90aWZmKGRhdGEsIG1ldGFkYXRhKSB7XG4gIGNvbnN0IGlzRmxhdHRlbmVkID0gdHlwZW9mIGRhdGFbMF0gPT09ICdudW1iZXInO1xuXG4gIGxldCBoZWlnaHQ7XG4gIGxldCBudW1CYW5kcztcbiAgbGV0IHdpZHRoO1xuICBsZXQgZmxhdHRlbmVkVmFsdWVzO1xuXG4gIGlmIChpc0ZsYXR0ZW5lZCkge1xuICAgIGhlaWdodCA9IG1ldGFkYXRhLmhlaWdodCB8fCBtZXRhZGF0YS5JbWFnZUxlbmd0aDtcbiAgICB3aWR0aCA9IG1ldGFkYXRhLndpZHRoIHx8IG1ldGFkYXRhLkltYWdlV2lkdGg7XG4gICAgbnVtQmFuZHMgPSBkYXRhLmxlbmd0aCAvIChoZWlnaHQgKiB3aWR0aCk7XG4gICAgZmxhdHRlbmVkVmFsdWVzID0gZGF0YTtcbiAgfSBlbHNlIHtcbiAgICBudW1CYW5kcyA9IGRhdGEubGVuZ3RoO1xuICAgIGhlaWdodCA9IGRhdGFbMF0ubGVuZ3RoO1xuICAgIHdpZHRoID0gZGF0YVswXVswXS5sZW5ndGg7XG4gICAgZmxhdHRlbmVkVmFsdWVzID0gW107XG4gICAgdGltZXMoaGVpZ2h0LCAocm93SW5kZXgpID0+IHtcbiAgICAgIHRpbWVzKHdpZHRoLCAoY29sdW1uSW5kZXgpID0+IHtcbiAgICAgICAgdGltZXMobnVtQmFuZHMsIChiYW5kSW5kZXgpID0+IHtcbiAgICAgICAgICBmbGF0dGVuZWRWYWx1ZXMucHVzaChkYXRhW2JhbmRJbmRleF1bcm93SW5kZXhdW2NvbHVtbkluZGV4XSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBtZXRhZGF0YS5JbWFnZUxlbmd0aCA9IGhlaWdodDtcbiAgZGVsZXRlIG1ldGFkYXRhLmhlaWdodDtcbiAgbWV0YWRhdGEuSW1hZ2VXaWR0aCA9IHdpZHRoO1xuICBkZWxldGUgbWV0YWRhdGEud2lkdGg7XG5cbiAgLy8gY29uc3VsdCBodHRwczovL3d3dy5sb2MuZ292L3ByZXNlcnZhdGlvbi9kaWdpdGFsL2Zvcm1hdHMvY29udGVudC90aWZmX3RhZ3Muc2h0bWxcblxuICBpZiAoIW1ldGFkYXRhLkJpdHNQZXJTYW1wbGUpIHtcbiAgICBtZXRhZGF0YS5CaXRzUGVyU2FtcGxlID0gdGltZXMobnVtQmFuZHMsICgpID0+IDgpO1xuICB9XG5cbiAgbWV0YWRhdGFEZWZhdWx0cy5mb3JFYWNoKCh0YWcpID0+IHtcbiAgICBjb25zdCBrZXkgPSB0YWdbMF07XG4gICAgaWYgKCFtZXRhZGF0YVtrZXldKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRhZ1sxXTtcbiAgICAgIG1ldGFkYXRhW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFRoZSBjb2xvciBzcGFjZSBvZiB0aGUgaW1hZ2UgZGF0YS5cbiAgLy8gMT1ibGFjayBpcyB6ZXJvIGFuZCAyPVJHQi5cbiAgaWYgKCFtZXRhZGF0YS5QaG90b21ldHJpY0ludGVycHJldGF0aW9uKSB7XG4gICAgbWV0YWRhdGEuUGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbiA9IG1ldGFkYXRhLkJpdHNQZXJTYW1wbGUubGVuZ3RoID09PSAzID8gMiA6IDE7XG4gIH1cblxuICAvLyBUaGUgbnVtYmVyIG9mIGNvbXBvbmVudHMgcGVyIHBpeGVsLlxuICBpZiAoIW1ldGFkYXRhLlNhbXBsZXNQZXJQaXhlbCkge1xuICAgIG1ldGFkYXRhLlNhbXBsZXNQZXJQaXhlbCA9IFtudW1CYW5kc107XG4gIH1cblxuICBpZiAoIW1ldGFkYXRhLlN0cmlwQnl0ZUNvdW50cykge1xuICAgIC8vIHdlIGFyZSBvbmx5IHdyaXRpbmcgb25lIHN0cmlwXG4gICAgbWV0YWRhdGEuU3RyaXBCeXRlQ291bnRzID0gW251bUJhbmRzICogaGVpZ2h0ICogd2lkdGhdO1xuICB9XG5cbiAgaWYgKCFtZXRhZGF0YS5Nb2RlbFBpeGVsU2NhbGUpIHtcbiAgICAvLyBhc3N1bWVzIHJhc3RlciB0YWtlcyB1cCBleGFjdGx5IHRoZSB3aG9sZSBnbG9iZVxuICAgIG1ldGFkYXRhLk1vZGVsUGl4ZWxTY2FsZSA9IFszNjAgLyB3aWR0aCwgMTgwIC8gaGVpZ2h0LCAwXTtcbiAgfVxuXG4gIGlmICghbWV0YWRhdGEuU2FtcGxlRm9ybWF0KSB7XG4gICAgbWV0YWRhdGEuU2FtcGxlRm9ybWF0ID0gdGltZXMobnVtQmFuZHMsICgpID0+IDEpO1xuICB9XG5cbiAgLy8gaWYgZGlkbid0IHBhc3MgaW4gcHJvamVjdGlvbiBpbmZvcm1hdGlvbiwgYXNzdW1lIHRoZSBwb3B1bGFyIDQzMjYgXCJnZW9ncmFwaGljIHByb2plY3Rpb25cIlxuICBpZiAoIW1ldGFkYXRhLmhhc093blByb3BlcnR5KCdHZW9ncmFwaGljVHlwZUdlb0tleScpICYmICFtZXRhZGF0YS5oYXNPd25Qcm9wZXJ0eSgnUHJvamVjdGVkQ1NUeXBlR2VvS2V5JykpIHtcbiAgICBtZXRhZGF0YS5HZW9ncmFwaGljVHlwZUdlb0tleSA9IDQzMjY7XG4gICAgbWV0YWRhdGEuTW9kZWxUaWVwb2ludCA9IFswLCAwLCAwLCAtMTgwLCA5MCwgMF07IC8vIHJhc3RlciBmaXRzIHdob2xlIGdsb2JlXG4gICAgbWV0YWRhdGEuR2VvZ0NpdGF0aW9uR2VvS2V5ID0gJ1dHUyA4NCc7XG4gICAgbWV0YWRhdGEuR1RNb2RlbFR5cGVHZW9LZXkgPSAyO1xuICB9XG5cbiAgY29uc3QgZ2VvS2V5cyA9IE9iamVjdC5rZXlzKG1ldGFkYXRhKVxuICAgIC5maWx0ZXIoKGtleSkgPT4gZW5kc1dpdGgoa2V5LCAnR2VvS2V5JykpXG4gICAgLnNvcnQoKGEsIGIpID0+IG5hbWUyY29kZVthXSAtIG5hbWUyY29kZVtiXSk7XG5cbiAgaWYgKCFtZXRhZGF0YS5HZW9Bc2NpaVBhcmFtcykge1xuICAgIGxldCBnZW9Bc2NpaVBhcmFtcyA9ICcnO1xuICAgIGdlb0tleXMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgY29uc3QgY29kZSA9IE51bWJlcihuYW1lMmNvZGVbbmFtZV0pO1xuICAgICAgY29uc3QgdGFnVHlwZSA9IGZpZWxkVGFnVHlwZXNbY29kZV07XG4gICAgICBpZiAodGFnVHlwZSA9PT0gJ0FTQ0lJJykge1xuICAgICAgICBnZW9Bc2NpaVBhcmFtcyArPSBgJHttZXRhZGF0YVtuYW1lXS50b1N0cmluZygpfVxcdTAwMDBgO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChnZW9Bc2NpaVBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICBtZXRhZGF0YS5HZW9Bc2NpaVBhcmFtcyA9IGdlb0FzY2lpUGFyYW1zO1xuICAgIH1cbiAgfVxuXG4gIGlmICghbWV0YWRhdGEuR2VvS2V5RGlyZWN0b3J5KSB7XG4gICAgY29uc3QgTnVtYmVyT2ZLZXlzID0gZ2VvS2V5cy5sZW5ndGg7XG5cbiAgICBjb25zdCBHZW9LZXlEaXJlY3RvcnkgPSBbMSwgMSwgMCwgTnVtYmVyT2ZLZXlzXTtcbiAgICBnZW9LZXlzLmZvckVhY2goKGdlb0tleSkgPT4ge1xuICAgICAgY29uc3QgS2V5SUQgPSBOdW1iZXIobmFtZTJjb2RlW2dlb0tleV0pO1xuICAgICAgR2VvS2V5RGlyZWN0b3J5LnB1c2goS2V5SUQpO1xuXG4gICAgICBsZXQgQ291bnQ7XG4gICAgICBsZXQgVElGRlRhZ0xvY2F0aW9uO1xuICAgICAgbGV0IHZhbHVlT2Zmc2V0O1xuICAgICAgaWYgKGZpZWxkVGFnVHlwZXNbS2V5SURdID09PSAnU0hPUlQnKSB7XG4gICAgICAgIENvdW50ID0gMTtcbiAgICAgICAgVElGRlRhZ0xvY2F0aW9uID0gMDtcbiAgICAgICAgdmFsdWVPZmZzZXQgPSBtZXRhZGF0YVtnZW9LZXldO1xuICAgICAgfSBlbHNlIGlmIChnZW9LZXkgPT09ICdHZW9nQ2l0YXRpb25HZW9LZXknKSB7XG4gICAgICAgIENvdW50ID0gbWV0YWRhdGEuR2VvQXNjaWlQYXJhbXMubGVuZ3RoO1xuICAgICAgICBUSUZGVGFnTG9jYXRpb24gPSBOdW1iZXIobmFtZTJjb2RlLkdlb0FzY2lpUGFyYW1zKTtcbiAgICAgICAgdmFsdWVPZmZzZXQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coYFtnZW90aWZmLmpzXSBjb3VsZG4ndCBnZXQgVElGRlRhZ0xvY2F0aW9uIGZvciAke2dlb0tleX1gKTtcbiAgICAgIH1cbiAgICAgIEdlb0tleURpcmVjdG9yeS5wdXNoKFRJRkZUYWdMb2NhdGlvbik7XG4gICAgICBHZW9LZXlEaXJlY3RvcnkucHVzaChDb3VudCk7XG4gICAgICBHZW9LZXlEaXJlY3RvcnkucHVzaCh2YWx1ZU9mZnNldCk7XG4gICAgfSk7XG4gICAgbWV0YWRhdGEuR2VvS2V5RGlyZWN0b3J5ID0gR2VvS2V5RGlyZWN0b3J5O1xuICB9XG5cbiAgLy8gZGVsZXRlIEdlb0tleXMgZnJvbSBtZXRhZGF0YSwgYmVjYXVzZSBzdG9yZWQgaW4gR2VvS2V5RGlyZWN0b3J5IHRhZ1xuICBmb3IgKGNvbnN0IGdlb0tleSBvZiBnZW9LZXlzKSB7XG4gICAgaWYgKG1ldGFkYXRhLmhhc093blByb3BlcnR5KGdlb0tleSkpIHtcbiAgICAgIGRlbGV0ZSBtZXRhZGF0YVtnZW9LZXldO1xuICAgIH1cbiAgfVxuXG4gIFtcbiAgICAnQ29tcHJlc3Npb24nLFxuICAgICdFeHRyYVNhbXBsZXMnLFxuICAgICdHZW9ncmFwaGljVHlwZUdlb0tleScsXG4gICAgJ0dUTW9kZWxUeXBlR2VvS2V5JyxcbiAgICAnR1RSYXN0ZXJUeXBlR2VvS2V5JyxcbiAgICAnSW1hZ2VMZW5ndGgnLCAvLyBzeW5vbnltIG9mIEltYWdlSGVpZ2h0XG4gICAgJ0ltYWdlV2lkdGgnLFxuICAgICdPcmllbnRhdGlvbicsXG4gICAgJ1Bob3RvbWV0cmljSW50ZXJwcmV0YXRpb24nLFxuICAgICdQcm9qZWN0ZWRDU1R5cGVHZW9LZXknLFxuICAgICdQbGFuYXJDb25maWd1cmF0aW9uJyxcbiAgICAnUmVzb2x1dGlvblVuaXQnLFxuICAgICdTYW1wbGVzUGVyUGl4ZWwnLFxuICAgICdYUG9zaXRpb24nLFxuICAgICdZUG9zaXRpb24nLFxuICAgICdSb3dzUGVyU3RyaXAnLFxuICBdLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICBpZiAobWV0YWRhdGFbbmFtZV0pIHtcbiAgICAgIG1ldGFkYXRhW25hbWVdID0gdG9BcnJheShtZXRhZGF0YVtuYW1lXSk7XG4gICAgfVxuICB9KTtcblxuICBjb25zdCBlbmNvZGVkTWV0YWRhdGEgPSBjb252ZXJ0VG9UaWRzKG1ldGFkYXRhKTtcblxuICBjb25zdCBvdXRwdXRJbWFnZSA9IGVuY29kZUltYWdlKGZsYXR0ZW5lZFZhbHVlcywgd2lkdGgsIGhlaWdodCwgZW5jb2RlZE1ldGFkYXRhKTtcblxuICByZXR1cm4gb3V0cHV0SW1hZ2U7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/geotiffwriter.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/globals.js":
/*!*****************************************************!*\
  !*** ./node_modules/geotiff/dist-module/globals.js ***!
  \*****************************************************/
/*! exports provided: fieldTagNames, fieldTags, fieldTagTypes, arrayFields, fieldTypeNames, fieldTypes, photometricInterpretations, ExtraSamplesValues, LercParameters, LercAddCompression, geoKeyNames, geoKeys */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fieldTagNames\", function() { return fieldTagNames; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fieldTags\", function() { return fieldTags; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fieldTagTypes\", function() { return fieldTagTypes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"arrayFields\", function() { return arrayFields; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fieldTypeNames\", function() { return fieldTypeNames; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fieldTypes\", function() { return fieldTypes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"photometricInterpretations\", function() { return photometricInterpretations; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ExtraSamplesValues\", function() { return ExtraSamplesValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LercParameters\", function() { return LercParameters; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LercAddCompression\", function() { return LercAddCompression; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"geoKeyNames\", function() { return geoKeyNames; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"geoKeys\", function() { return geoKeys; });\nconst fieldTagNames = {\n  // TIFF Baseline\n  0x013B: 'Artist',\n  0x0102: 'BitsPerSample',\n  0x0109: 'CellLength',\n  0x0108: 'CellWidth',\n  0x0140: 'ColorMap',\n  0x0103: 'Compression',\n  0x8298: 'Copyright',\n  0x0132: 'DateTime',\n  0x0152: 'ExtraSamples',\n  0x010A: 'FillOrder',\n  0x0121: 'FreeByteCounts',\n  0x0120: 'FreeOffsets',\n  0x0123: 'GrayResponseCurve',\n  0x0122: 'GrayResponseUnit',\n  0x013C: 'HostComputer',\n  0x010E: 'ImageDescription',\n  0x0101: 'ImageLength',\n  0x0100: 'ImageWidth',\n  0x010F: 'Make',\n  0x0119: 'MaxSampleValue',\n  0x0118: 'MinSampleValue',\n  0x0110: 'Model',\n  0x00FE: 'NewSubfileType',\n  0x0112: 'Orientation',\n  0x0106: 'PhotometricInterpretation',\n  0x011C: 'PlanarConfiguration',\n  0x0128: 'ResolutionUnit',\n  0x0116: 'RowsPerStrip',\n  0x0115: 'SamplesPerPixel',\n  0x0131: 'Software',\n  0x0117: 'StripByteCounts',\n  0x0111: 'StripOffsets',\n  0x00FF: 'SubfileType',\n  0x0107: 'Threshholding',\n  0x011A: 'XResolution',\n  0x011B: 'YResolution',\n\n  // TIFF Extended\n  0x0146: 'BadFaxLines',\n  0x0147: 'CleanFaxData',\n  0x0157: 'ClipPath',\n  0x0148: 'ConsecutiveBadFaxLines',\n  0x01B1: 'Decode',\n  0x01B2: 'DefaultImageColor',\n  0x010D: 'DocumentName',\n  0x0150: 'DotRange',\n  0x0141: 'HalftoneHints',\n  0x015A: 'Indexed',\n  0x015B: 'JPEGTables',\n  0x011D: 'PageName',\n  0x0129: 'PageNumber',\n  0x013D: 'Predictor',\n  0x013F: 'PrimaryChromaticities',\n  0x0214: 'ReferenceBlackWhite',\n  0x0153: 'SampleFormat',\n  0x0154: 'SMinSampleValue',\n  0x0155: 'SMaxSampleValue',\n  0x022F: 'StripRowCounts',\n  0x014A: 'SubIFDs',\n  0x0124: 'T4Options',\n  0x0125: 'T6Options',\n  0x0145: 'TileByteCounts',\n  0x0143: 'TileLength',\n  0x0144: 'TileOffsets',\n  0x0142: 'TileWidth',\n  0x012D: 'TransferFunction',\n  0x013E: 'WhitePoint',\n  0x0158: 'XClipPathUnits',\n  0x011E: 'XPosition',\n  0x0211: 'YCbCrCoefficients',\n  0x0213: 'YCbCrPositioning',\n  0x0212: 'YCbCrSubSampling',\n  0x0159: 'YClipPathUnits',\n  0x011F: 'YPosition',\n\n  // EXIF\n  0x9202: 'ApertureValue',\n  0xA001: 'ColorSpace',\n  0x9004: 'DateTimeDigitized',\n  0x9003: 'DateTimeOriginal',\n  0x8769: 'Exif IFD',\n  0x9000: 'ExifVersion',\n  0x829A: 'ExposureTime',\n  0xA300: 'FileSource',\n  0x9209: 'Flash',\n  0xA000: 'FlashpixVersion',\n  0x829D: 'FNumber',\n  0xA420: 'ImageUniqueID',\n  0x9208: 'LightSource',\n  0x927C: 'MakerNote',\n  0x9201: 'ShutterSpeedValue',\n  0x9286: 'UserComment',\n\n  // IPTC\n  0x83BB: 'IPTC',\n\n  // ICC\n  0x8773: 'ICC Profile',\n\n  // XMP\n  0x02BC: 'XMP',\n\n  // GDAL\n  0xA480: 'GDAL_METADATA',\n  0xA481: 'GDAL_NODATA',\n\n  // Photoshop\n  0x8649: 'Photoshop',\n\n  // GeoTiff\n  0x830E: 'ModelPixelScale',\n  0x8482: 'ModelTiepoint',\n  0x85D8: 'ModelTransformation',\n  0x87AF: 'GeoKeyDirectory',\n  0x87B0: 'GeoDoubleParams',\n  0x87B1: 'GeoAsciiParams',\n\n  // LERC\n  0xC5F2: 'LercParameters',\n};\n\nconst fieldTags = {};\nfor (const key in fieldTagNames) {\n  if (fieldTagNames.hasOwnProperty(key)) {\n    fieldTags[fieldTagNames[key]] = parseInt(key, 10);\n  }\n}\n\nconst fieldTagTypes = {\n  256: 'SHORT',\n  257: 'SHORT',\n  258: 'SHORT',\n  259: 'SHORT',\n  262: 'SHORT',\n  273: 'LONG',\n  274: 'SHORT',\n  277: 'SHORT',\n  278: 'LONG',\n  279: 'LONG',\n  282: 'RATIONAL',\n  283: 'RATIONAL',\n  284: 'SHORT',\n  286: 'SHORT',\n  287: 'RATIONAL',\n  296: 'SHORT',\n  297: 'SHORT',\n  305: 'ASCII',\n  306: 'ASCII',\n  338: 'SHORT',\n  339: 'SHORT',\n  513: 'LONG',\n  514: 'LONG',\n  1024: 'SHORT',\n  1025: 'SHORT',\n  2048: 'SHORT',\n  2049: 'ASCII',\n  3072: 'SHORT',\n  3073: 'ASCII',\n  33550: 'DOUBLE',\n  33922: 'DOUBLE',\n  34264: 'DOUBLE',\n  34665: 'LONG',\n  34735: 'SHORT',\n  34736: 'DOUBLE',\n  34737: 'ASCII',\n  42113: 'ASCII',\n};\n\nconst arrayFields = [\n  fieldTags.BitsPerSample,\n  fieldTags.ExtraSamples,\n  fieldTags.SampleFormat,\n  fieldTags.StripByteCounts,\n  fieldTags.StripOffsets,\n  fieldTags.StripRowCounts,\n  fieldTags.TileByteCounts,\n  fieldTags.TileOffsets,\n  fieldTags.SubIFDs,\n];\n\nconst fieldTypeNames = {\n  0x0001: 'BYTE',\n  0x0002: 'ASCII',\n  0x0003: 'SHORT',\n  0x0004: 'LONG',\n  0x0005: 'RATIONAL',\n  0x0006: 'SBYTE',\n  0x0007: 'UNDEFINED',\n  0x0008: 'SSHORT',\n  0x0009: 'SLONG',\n  0x000A: 'SRATIONAL',\n  0x000B: 'FLOAT',\n  0x000C: 'DOUBLE',\n  // IFD offset, suggested by https://owl.phy.queensu.ca/~phil/exiftool/standards.html\n  0x000D: 'IFD',\n  // introduced by BigTIFF\n  0x0010: 'LONG8',\n  0x0011: 'SLONG8',\n  0x0012: 'IFD8',\n};\n\nconst fieldTypes = {};\nfor (const key in fieldTypeNames) {\n  if (fieldTypeNames.hasOwnProperty(key)) {\n    fieldTypes[fieldTypeNames[key]] = parseInt(key, 10);\n  }\n}\n\nconst photometricInterpretations = {\n  WhiteIsZero: 0,\n  BlackIsZero: 1,\n  RGB: 2,\n  Palette: 3,\n  TransparencyMask: 4,\n  CMYK: 5,\n  YCbCr: 6,\n\n  CIELab: 8,\n  ICCLab: 9,\n};\n\nconst ExtraSamplesValues = {\n  Unspecified: 0,\n  Assocalpha: 1,\n  Unassalpha: 2,\n};\n\nconst LercParameters = {\n  Version: 0,\n  AddCompression: 1,\n};\n\nconst LercAddCompression = {\n  None: 0,\n  Deflate: 1,\n  Zstandard: 2,\n};\n\nconst geoKeyNames = {\n  1024: 'GTModelTypeGeoKey',\n  1025: 'GTRasterTypeGeoKey',\n  1026: 'GTCitationGeoKey',\n  2048: 'GeographicTypeGeoKey',\n  2049: 'GeogCitationGeoKey',\n  2050: 'GeogGeodeticDatumGeoKey',\n  2051: 'GeogPrimeMeridianGeoKey',\n  2052: 'GeogLinearUnitsGeoKey',\n  2053: 'GeogLinearUnitSizeGeoKey',\n  2054: 'GeogAngularUnitsGeoKey',\n  2055: 'GeogAngularUnitSizeGeoKey',\n  2056: 'GeogEllipsoidGeoKey',\n  2057: 'GeogSemiMajorAxisGeoKey',\n  2058: 'GeogSemiMinorAxisGeoKey',\n  2059: 'GeogInvFlatteningGeoKey',\n  2060: 'GeogAzimuthUnitsGeoKey',\n  2061: 'GeogPrimeMeridianLongGeoKey',\n  2062: 'GeogTOWGS84GeoKey',\n  3072: 'ProjectedCSTypeGeoKey',\n  3073: 'PCSCitationGeoKey',\n  3074: 'ProjectionGeoKey',\n  3075: 'ProjCoordTransGeoKey',\n  3076: 'ProjLinearUnitsGeoKey',\n  3077: 'ProjLinearUnitSizeGeoKey',\n  3078: 'ProjStdParallel1GeoKey',\n  3079: 'ProjStdParallel2GeoKey',\n  3080: 'ProjNatOriginLongGeoKey',\n  3081: 'ProjNatOriginLatGeoKey',\n  3082: 'ProjFalseEastingGeoKey',\n  3083: 'ProjFalseNorthingGeoKey',\n  3084: 'ProjFalseOriginLongGeoKey',\n  3085: 'ProjFalseOriginLatGeoKey',\n  3086: 'ProjFalseOriginEastingGeoKey',\n  3087: 'ProjFalseOriginNorthingGeoKey',\n  3088: 'ProjCenterLongGeoKey',\n  3089: 'ProjCenterLatGeoKey',\n  3090: 'ProjCenterEastingGeoKey',\n  3091: 'ProjCenterNorthingGeoKey',\n  3092: 'ProjScaleAtNatOriginGeoKey',\n  3093: 'ProjScaleAtCenterGeoKey',\n  3094: 'ProjAzimuthAngleGeoKey',\n  3095: 'ProjStraightVertPoleLongGeoKey',\n  3096: 'ProjRectifiedGridAngleGeoKey',\n  4096: 'VerticalCSTypeGeoKey',\n  4097: 'VerticalCitationGeoKey',\n  4098: 'VerticalDatumGeoKey',\n  4099: 'VerticalUnitsGeoKey',\n};\n\nconst geoKeys = {};\nfor (const key in geoKeyNames) {\n  if (geoKeyNames.hasOwnProperty(key)) {\n    geoKeys[geoKeyNames[key]] = parseInt(key, 10);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9nbG9iYWxzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvZ2xvYmFscy5qcz9hYmE2Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBmaWVsZFRhZ05hbWVzID0ge1xuICAvLyBUSUZGIEJhc2VsaW5lXG4gIDB4MDEzQjogJ0FydGlzdCcsXG4gIDB4MDEwMjogJ0JpdHNQZXJTYW1wbGUnLFxuICAweDAxMDk6ICdDZWxsTGVuZ3RoJyxcbiAgMHgwMTA4OiAnQ2VsbFdpZHRoJyxcbiAgMHgwMTQwOiAnQ29sb3JNYXAnLFxuICAweDAxMDM6ICdDb21wcmVzc2lvbicsXG4gIDB4ODI5ODogJ0NvcHlyaWdodCcsXG4gIDB4MDEzMjogJ0RhdGVUaW1lJyxcbiAgMHgwMTUyOiAnRXh0cmFTYW1wbGVzJyxcbiAgMHgwMTBBOiAnRmlsbE9yZGVyJyxcbiAgMHgwMTIxOiAnRnJlZUJ5dGVDb3VudHMnLFxuICAweDAxMjA6ICdGcmVlT2Zmc2V0cycsXG4gIDB4MDEyMzogJ0dyYXlSZXNwb25zZUN1cnZlJyxcbiAgMHgwMTIyOiAnR3JheVJlc3BvbnNlVW5pdCcsXG4gIDB4MDEzQzogJ0hvc3RDb21wdXRlcicsXG4gIDB4MDEwRTogJ0ltYWdlRGVzY3JpcHRpb24nLFxuICAweDAxMDE6ICdJbWFnZUxlbmd0aCcsXG4gIDB4MDEwMDogJ0ltYWdlV2lkdGgnLFxuICAweDAxMEY6ICdNYWtlJyxcbiAgMHgwMTE5OiAnTWF4U2FtcGxlVmFsdWUnLFxuICAweDAxMTg6ICdNaW5TYW1wbGVWYWx1ZScsXG4gIDB4MDExMDogJ01vZGVsJyxcbiAgMHgwMEZFOiAnTmV3U3ViZmlsZVR5cGUnLFxuICAweDAxMTI6ICdPcmllbnRhdGlvbicsXG4gIDB4MDEwNjogJ1Bob3RvbWV0cmljSW50ZXJwcmV0YXRpb24nLFxuICAweDAxMUM6ICdQbGFuYXJDb25maWd1cmF0aW9uJyxcbiAgMHgwMTI4OiAnUmVzb2x1dGlvblVuaXQnLFxuICAweDAxMTY6ICdSb3dzUGVyU3RyaXAnLFxuICAweDAxMTU6ICdTYW1wbGVzUGVyUGl4ZWwnLFxuICAweDAxMzE6ICdTb2Z0d2FyZScsXG4gIDB4MDExNzogJ1N0cmlwQnl0ZUNvdW50cycsXG4gIDB4MDExMTogJ1N0cmlwT2Zmc2V0cycsXG4gIDB4MDBGRjogJ1N1YmZpbGVUeXBlJyxcbiAgMHgwMTA3OiAnVGhyZXNoaG9sZGluZycsXG4gIDB4MDExQTogJ1hSZXNvbHV0aW9uJyxcbiAgMHgwMTFCOiAnWVJlc29sdXRpb24nLFxuXG4gIC8vIFRJRkYgRXh0ZW5kZWRcbiAgMHgwMTQ2OiAnQmFkRmF4TGluZXMnLFxuICAweDAxNDc6ICdDbGVhbkZheERhdGEnLFxuICAweDAxNTc6ICdDbGlwUGF0aCcsXG4gIDB4MDE0ODogJ0NvbnNlY3V0aXZlQmFkRmF4TGluZXMnLFxuICAweDAxQjE6ICdEZWNvZGUnLFxuICAweDAxQjI6ICdEZWZhdWx0SW1hZ2VDb2xvcicsXG4gIDB4MDEwRDogJ0RvY3VtZW50TmFtZScsXG4gIDB4MDE1MDogJ0RvdFJhbmdlJyxcbiAgMHgwMTQxOiAnSGFsZnRvbmVIaW50cycsXG4gIDB4MDE1QTogJ0luZGV4ZWQnLFxuICAweDAxNUI6ICdKUEVHVGFibGVzJyxcbiAgMHgwMTFEOiAnUGFnZU5hbWUnLFxuICAweDAxMjk6ICdQYWdlTnVtYmVyJyxcbiAgMHgwMTNEOiAnUHJlZGljdG9yJyxcbiAgMHgwMTNGOiAnUHJpbWFyeUNocm9tYXRpY2l0aWVzJyxcbiAgMHgwMjE0OiAnUmVmZXJlbmNlQmxhY2tXaGl0ZScsXG4gIDB4MDE1MzogJ1NhbXBsZUZvcm1hdCcsXG4gIDB4MDE1NDogJ1NNaW5TYW1wbGVWYWx1ZScsXG4gIDB4MDE1NTogJ1NNYXhTYW1wbGVWYWx1ZScsXG4gIDB4MDIyRjogJ1N0cmlwUm93Q291bnRzJyxcbiAgMHgwMTRBOiAnU3ViSUZEcycsXG4gIDB4MDEyNDogJ1Q0T3B0aW9ucycsXG4gIDB4MDEyNTogJ1Q2T3B0aW9ucycsXG4gIDB4MDE0NTogJ1RpbGVCeXRlQ291bnRzJyxcbiAgMHgwMTQzOiAnVGlsZUxlbmd0aCcsXG4gIDB4MDE0NDogJ1RpbGVPZmZzZXRzJyxcbiAgMHgwMTQyOiAnVGlsZVdpZHRoJyxcbiAgMHgwMTJEOiAnVHJhbnNmZXJGdW5jdGlvbicsXG4gIDB4MDEzRTogJ1doaXRlUG9pbnQnLFxuICAweDAxNTg6ICdYQ2xpcFBhdGhVbml0cycsXG4gIDB4MDExRTogJ1hQb3NpdGlvbicsXG4gIDB4MDIxMTogJ1lDYkNyQ29lZmZpY2llbnRzJyxcbiAgMHgwMjEzOiAnWUNiQ3JQb3NpdGlvbmluZycsXG4gIDB4MDIxMjogJ1lDYkNyU3ViU2FtcGxpbmcnLFxuICAweDAxNTk6ICdZQ2xpcFBhdGhVbml0cycsXG4gIDB4MDExRjogJ1lQb3NpdGlvbicsXG5cbiAgLy8gRVhJRlxuICAweDkyMDI6ICdBcGVydHVyZVZhbHVlJyxcbiAgMHhBMDAxOiAnQ29sb3JTcGFjZScsXG4gIDB4OTAwNDogJ0RhdGVUaW1lRGlnaXRpemVkJyxcbiAgMHg5MDAzOiAnRGF0ZVRpbWVPcmlnaW5hbCcsXG4gIDB4ODc2OTogJ0V4aWYgSUZEJyxcbiAgMHg5MDAwOiAnRXhpZlZlcnNpb24nLFxuICAweDgyOUE6ICdFeHBvc3VyZVRpbWUnLFxuICAweEEzMDA6ICdGaWxlU291cmNlJyxcbiAgMHg5MjA5OiAnRmxhc2gnLFxuICAweEEwMDA6ICdGbGFzaHBpeFZlcnNpb24nLFxuICAweDgyOUQ6ICdGTnVtYmVyJyxcbiAgMHhBNDIwOiAnSW1hZ2VVbmlxdWVJRCcsXG4gIDB4OTIwODogJ0xpZ2h0U291cmNlJyxcbiAgMHg5MjdDOiAnTWFrZXJOb3RlJyxcbiAgMHg5MjAxOiAnU2h1dHRlclNwZWVkVmFsdWUnLFxuICAweDkyODY6ICdVc2VyQ29tbWVudCcsXG5cbiAgLy8gSVBUQ1xuICAweDgzQkI6ICdJUFRDJyxcblxuICAvLyBJQ0NcbiAgMHg4NzczOiAnSUNDIFByb2ZpbGUnLFxuXG4gIC8vIFhNUFxuICAweDAyQkM6ICdYTVAnLFxuXG4gIC8vIEdEQUxcbiAgMHhBNDgwOiAnR0RBTF9NRVRBREFUQScsXG4gIDB4QTQ4MTogJ0dEQUxfTk9EQVRBJyxcblxuICAvLyBQaG90b3Nob3BcbiAgMHg4NjQ5OiAnUGhvdG9zaG9wJyxcblxuICAvLyBHZW9UaWZmXG4gIDB4ODMwRTogJ01vZGVsUGl4ZWxTY2FsZScsXG4gIDB4ODQ4MjogJ01vZGVsVGllcG9pbnQnLFxuICAweDg1RDg6ICdNb2RlbFRyYW5zZm9ybWF0aW9uJyxcbiAgMHg4N0FGOiAnR2VvS2V5RGlyZWN0b3J5JyxcbiAgMHg4N0IwOiAnR2VvRG91YmxlUGFyYW1zJyxcbiAgMHg4N0IxOiAnR2VvQXNjaWlQYXJhbXMnLFxuXG4gIC8vIExFUkNcbiAgMHhDNUYyOiAnTGVyY1BhcmFtZXRlcnMnLFxufTtcblxuZXhwb3J0IGNvbnN0IGZpZWxkVGFncyA9IHt9O1xuZm9yIChjb25zdCBrZXkgaW4gZmllbGRUYWdOYW1lcykge1xuICBpZiAoZmllbGRUYWdOYW1lcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgZmllbGRUYWdzW2ZpZWxkVGFnTmFtZXNba2V5XV0gPSBwYXJzZUludChrZXksIDEwKTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZmllbGRUYWdUeXBlcyA9IHtcbiAgMjU2OiAnU0hPUlQnLFxuICAyNTc6ICdTSE9SVCcsXG4gIDI1ODogJ1NIT1JUJyxcbiAgMjU5OiAnU0hPUlQnLFxuICAyNjI6ICdTSE9SVCcsXG4gIDI3MzogJ0xPTkcnLFxuICAyNzQ6ICdTSE9SVCcsXG4gIDI3NzogJ1NIT1JUJyxcbiAgMjc4OiAnTE9ORycsXG4gIDI3OTogJ0xPTkcnLFxuICAyODI6ICdSQVRJT05BTCcsXG4gIDI4MzogJ1JBVElPTkFMJyxcbiAgMjg0OiAnU0hPUlQnLFxuICAyODY6ICdTSE9SVCcsXG4gIDI4NzogJ1JBVElPTkFMJyxcbiAgMjk2OiAnU0hPUlQnLFxuICAyOTc6ICdTSE9SVCcsXG4gIDMwNTogJ0FTQ0lJJyxcbiAgMzA2OiAnQVNDSUknLFxuICAzMzg6ICdTSE9SVCcsXG4gIDMzOTogJ1NIT1JUJyxcbiAgNTEzOiAnTE9ORycsXG4gIDUxNDogJ0xPTkcnLFxuICAxMDI0OiAnU0hPUlQnLFxuICAxMDI1OiAnU0hPUlQnLFxuICAyMDQ4OiAnU0hPUlQnLFxuICAyMDQ5OiAnQVNDSUknLFxuICAzMDcyOiAnU0hPUlQnLFxuICAzMDczOiAnQVNDSUknLFxuICAzMzU1MDogJ0RPVUJMRScsXG4gIDMzOTIyOiAnRE9VQkxFJyxcbiAgMzQyNjQ6ICdET1VCTEUnLFxuICAzNDY2NTogJ0xPTkcnLFxuICAzNDczNTogJ1NIT1JUJyxcbiAgMzQ3MzY6ICdET1VCTEUnLFxuICAzNDczNzogJ0FTQ0lJJyxcbiAgNDIxMTM6ICdBU0NJSScsXG59O1xuXG5leHBvcnQgY29uc3QgYXJyYXlGaWVsZHMgPSBbXG4gIGZpZWxkVGFncy5CaXRzUGVyU2FtcGxlLFxuICBmaWVsZFRhZ3MuRXh0cmFTYW1wbGVzLFxuICBmaWVsZFRhZ3MuU2FtcGxlRm9ybWF0LFxuICBmaWVsZFRhZ3MuU3RyaXBCeXRlQ291bnRzLFxuICBmaWVsZFRhZ3MuU3RyaXBPZmZzZXRzLFxuICBmaWVsZFRhZ3MuU3RyaXBSb3dDb3VudHMsXG4gIGZpZWxkVGFncy5UaWxlQnl0ZUNvdW50cyxcbiAgZmllbGRUYWdzLlRpbGVPZmZzZXRzLFxuICBmaWVsZFRhZ3MuU3ViSUZEcyxcbl07XG5cbmV4cG9ydCBjb25zdCBmaWVsZFR5cGVOYW1lcyA9IHtcbiAgMHgwMDAxOiAnQllURScsXG4gIDB4MDAwMjogJ0FTQ0lJJyxcbiAgMHgwMDAzOiAnU0hPUlQnLFxuICAweDAwMDQ6ICdMT05HJyxcbiAgMHgwMDA1OiAnUkFUSU9OQUwnLFxuICAweDAwMDY6ICdTQllURScsXG4gIDB4MDAwNzogJ1VOREVGSU5FRCcsXG4gIDB4MDAwODogJ1NTSE9SVCcsXG4gIDB4MDAwOTogJ1NMT05HJyxcbiAgMHgwMDBBOiAnU1JBVElPTkFMJyxcbiAgMHgwMDBCOiAnRkxPQVQnLFxuICAweDAwMEM6ICdET1VCTEUnLFxuICAvLyBJRkQgb2Zmc2V0LCBzdWdnZXN0ZWQgYnkgaHR0cHM6Ly9vd2wucGh5LnF1ZWVuc3UuY2EvfnBoaWwvZXhpZnRvb2wvc3RhbmRhcmRzLmh0bWxcbiAgMHgwMDBEOiAnSUZEJyxcbiAgLy8gaW50cm9kdWNlZCBieSBCaWdUSUZGXG4gIDB4MDAxMDogJ0xPTkc4JyxcbiAgMHgwMDExOiAnU0xPTkc4JyxcbiAgMHgwMDEyOiAnSUZEOCcsXG59O1xuXG5leHBvcnQgY29uc3QgZmllbGRUeXBlcyA9IHt9O1xuZm9yIChjb25zdCBrZXkgaW4gZmllbGRUeXBlTmFtZXMpIHtcbiAgaWYgKGZpZWxkVHlwZU5hbWVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICBmaWVsZFR5cGVzW2ZpZWxkVHlwZU5hbWVzW2tleV1dID0gcGFyc2VJbnQoa2V5LCAxMCk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb25zID0ge1xuICBXaGl0ZUlzWmVybzogMCxcbiAgQmxhY2tJc1plcm86IDEsXG4gIFJHQjogMixcbiAgUGFsZXR0ZTogMyxcbiAgVHJhbnNwYXJlbmN5TWFzazogNCxcbiAgQ01ZSzogNSxcbiAgWUNiQ3I6IDYsXG5cbiAgQ0lFTGFiOiA4LFxuICBJQ0NMYWI6IDksXG59O1xuXG5leHBvcnQgY29uc3QgRXh0cmFTYW1wbGVzVmFsdWVzID0ge1xuICBVbnNwZWNpZmllZDogMCxcbiAgQXNzb2NhbHBoYTogMSxcbiAgVW5hc3NhbHBoYTogMixcbn07XG5cbmV4cG9ydCBjb25zdCBMZXJjUGFyYW1ldGVycyA9IHtcbiAgVmVyc2lvbjogMCxcbiAgQWRkQ29tcHJlc3Npb246IDEsXG59O1xuXG5leHBvcnQgY29uc3QgTGVyY0FkZENvbXByZXNzaW9uID0ge1xuICBOb25lOiAwLFxuICBEZWZsYXRlOiAxLFxuICBac3RhbmRhcmQ6IDIsXG59O1xuXG5leHBvcnQgY29uc3QgZ2VvS2V5TmFtZXMgPSB7XG4gIDEwMjQ6ICdHVE1vZGVsVHlwZUdlb0tleScsXG4gIDEwMjU6ICdHVFJhc3RlclR5cGVHZW9LZXknLFxuICAxMDI2OiAnR1RDaXRhdGlvbkdlb0tleScsXG4gIDIwNDg6ICdHZW9ncmFwaGljVHlwZUdlb0tleScsXG4gIDIwNDk6ICdHZW9nQ2l0YXRpb25HZW9LZXknLFxuICAyMDUwOiAnR2VvZ0dlb2RldGljRGF0dW1HZW9LZXknLFxuICAyMDUxOiAnR2VvZ1ByaW1lTWVyaWRpYW5HZW9LZXknLFxuICAyMDUyOiAnR2VvZ0xpbmVhclVuaXRzR2VvS2V5JyxcbiAgMjA1MzogJ0dlb2dMaW5lYXJVbml0U2l6ZUdlb0tleScsXG4gIDIwNTQ6ICdHZW9nQW5ndWxhclVuaXRzR2VvS2V5JyxcbiAgMjA1NTogJ0dlb2dBbmd1bGFyVW5pdFNpemVHZW9LZXknLFxuICAyMDU2OiAnR2VvZ0VsbGlwc29pZEdlb0tleScsXG4gIDIwNTc6ICdHZW9nU2VtaU1ham9yQXhpc0dlb0tleScsXG4gIDIwNTg6ICdHZW9nU2VtaU1pbm9yQXhpc0dlb0tleScsXG4gIDIwNTk6ICdHZW9nSW52RmxhdHRlbmluZ0dlb0tleScsXG4gIDIwNjA6ICdHZW9nQXppbXV0aFVuaXRzR2VvS2V5JyxcbiAgMjA2MTogJ0dlb2dQcmltZU1lcmlkaWFuTG9uZ0dlb0tleScsXG4gIDIwNjI6ICdHZW9nVE9XR1M4NEdlb0tleScsXG4gIDMwNzI6ICdQcm9qZWN0ZWRDU1R5cGVHZW9LZXknLFxuICAzMDczOiAnUENTQ2l0YXRpb25HZW9LZXknLFxuICAzMDc0OiAnUHJvamVjdGlvbkdlb0tleScsXG4gIDMwNzU6ICdQcm9qQ29vcmRUcmFuc0dlb0tleScsXG4gIDMwNzY6ICdQcm9qTGluZWFyVW5pdHNHZW9LZXknLFxuICAzMDc3OiAnUHJvakxpbmVhclVuaXRTaXplR2VvS2V5JyxcbiAgMzA3ODogJ1Byb2pTdGRQYXJhbGxlbDFHZW9LZXknLFxuICAzMDc5OiAnUHJvalN0ZFBhcmFsbGVsMkdlb0tleScsXG4gIDMwODA6ICdQcm9qTmF0T3JpZ2luTG9uZ0dlb0tleScsXG4gIDMwODE6ICdQcm9qTmF0T3JpZ2luTGF0R2VvS2V5JyxcbiAgMzA4MjogJ1Byb2pGYWxzZUVhc3RpbmdHZW9LZXknLFxuICAzMDgzOiAnUHJvakZhbHNlTm9ydGhpbmdHZW9LZXknLFxuICAzMDg0OiAnUHJvakZhbHNlT3JpZ2luTG9uZ0dlb0tleScsXG4gIDMwODU6ICdQcm9qRmFsc2VPcmlnaW5MYXRHZW9LZXknLFxuICAzMDg2OiAnUHJvakZhbHNlT3JpZ2luRWFzdGluZ0dlb0tleScsXG4gIDMwODc6ICdQcm9qRmFsc2VPcmlnaW5Ob3J0aGluZ0dlb0tleScsXG4gIDMwODg6ICdQcm9qQ2VudGVyTG9uZ0dlb0tleScsXG4gIDMwODk6ICdQcm9qQ2VudGVyTGF0R2VvS2V5JyxcbiAgMzA5MDogJ1Byb2pDZW50ZXJFYXN0aW5nR2VvS2V5JyxcbiAgMzA5MTogJ1Byb2pDZW50ZXJOb3J0aGluZ0dlb0tleScsXG4gIDMwOTI6ICdQcm9qU2NhbGVBdE5hdE9yaWdpbkdlb0tleScsXG4gIDMwOTM6ICdQcm9qU2NhbGVBdENlbnRlckdlb0tleScsXG4gIDMwOTQ6ICdQcm9qQXppbXV0aEFuZ2xlR2VvS2V5JyxcbiAgMzA5NTogJ1Byb2pTdHJhaWdodFZlcnRQb2xlTG9uZ0dlb0tleScsXG4gIDMwOTY6ICdQcm9qUmVjdGlmaWVkR3JpZEFuZ2xlR2VvS2V5JyxcbiAgNDA5NjogJ1ZlcnRpY2FsQ1NUeXBlR2VvS2V5JyxcbiAgNDA5NzogJ1ZlcnRpY2FsQ2l0YXRpb25HZW9LZXknLFxuICA0MDk4OiAnVmVydGljYWxEYXR1bUdlb0tleScsXG4gIDQwOTk6ICdWZXJ0aWNhbFVuaXRzR2VvS2V5Jyxcbn07XG5cbmV4cG9ydCBjb25zdCBnZW9LZXlzID0ge307XG5mb3IgKGNvbnN0IGtleSBpbiBnZW9LZXlOYW1lcykge1xuICBpZiAoZ2VvS2V5TmFtZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgIGdlb0tleXNbZ2VvS2V5TmFtZXNba2V5XV0gPSBwYXJzZUludChrZXksIDEwKTtcbiAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/globals.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/logging.js":
/*!*****************************************************!*\
  !*** ./node_modules/geotiff/dist-module/logging.js ***!
  \*****************************************************/
/*! exports provided: setLogger, debug, log, info, warn, error, time, timeEnd */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setLogger\", function() { return setLogger; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"debug\", function() { return debug; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"log\", function() { return log; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"info\", function() { return info; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"warn\", function() { return warn; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"error\", function() { return error; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"time\", function() { return time; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"timeEnd\", function() { return timeEnd; });\n/**\n * A no-op logger\n */\nclass DummyLogger {\n  log() {}\n\n  debug() {}\n\n  info() {}\n\n  warn() {}\n\n  error() {}\n\n  time() {}\n\n  timeEnd() {}\n}\n\nlet LOGGER = new DummyLogger();\n\n/**\n *\n * @param {object} logger the new logger. e.g `console`\n */\nfunction setLogger(logger = new DummyLogger()) {\n  LOGGER = logger;\n}\n\nfunction debug(...args) {\n  return LOGGER.debug(...args);\n}\n\nfunction log(...args) {\n  return LOGGER.log(...args);\n}\n\nfunction info(...args) {\n  return LOGGER.info(...args);\n}\n\nfunction warn(...args) {\n  return LOGGER.warn(...args);\n}\n\nfunction error(...args) {\n  return LOGGER.error(...args);\n}\n\nfunction time(...args) {\n  return LOGGER.time(...args);\n}\n\nfunction timeEnd(...args) {\n  return LOGGER.timeEnd(...args);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9sb2dnaW5nLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvbG9nZ2luZy5qcz82NDNhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQSBuby1vcCBsb2dnZXJcbiAqL1xuY2xhc3MgRHVtbXlMb2dnZXIge1xuICBsb2coKSB7fVxuXG4gIGRlYnVnKCkge31cblxuICBpbmZvKCkge31cblxuICB3YXJuKCkge31cblxuICBlcnJvcigpIHt9XG5cbiAgdGltZSgpIHt9XG5cbiAgdGltZUVuZCgpIHt9XG59XG5cbmxldCBMT0dHRVIgPSBuZXcgRHVtbXlMb2dnZXIoKTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGxvZ2dlciB0aGUgbmV3IGxvZ2dlci4gZS5nIGBjb25zb2xlYFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0TG9nZ2VyKGxvZ2dlciA9IG5ldyBEdW1teUxvZ2dlcigpKSB7XG4gIExPR0dFUiA9IGxvZ2dlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlYnVnKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIExPR0dFUi5kZWJ1ZyguLi5hcmdzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvZyguLi5hcmdzKSB7XG4gIHJldHVybiBMT0dHRVIubG9nKC4uLmFyZ3MpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5mbyguLi5hcmdzKSB7XG4gIHJldHVybiBMT0dHRVIuaW5mbyguLi5hcmdzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdhcm4oLi4uYXJncykge1xuICByZXR1cm4gTE9HR0VSLndhcm4oLi4uYXJncyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcnJvciguLi5hcmdzKSB7XG4gIHJldHVybiBMT0dHRVIuZXJyb3IoLi4uYXJncyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aW1lKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIExPR0dFUi50aW1lKC4uLmFyZ3MpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGltZUVuZCguLi5hcmdzKSB7XG4gIHJldHVybiBMT0dHRVIudGltZUVuZCguLi5hcmdzKTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/logging.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/pool.js":
/*!**************************************************!*\
  !*** ./node_modules/geotiff/dist-module/pool.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _compression_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compression/index.js */ \"./node_modules/geotiff/dist-module/compression/index.js\");\n\n\nconst defaultPoolSize = typeof navigator !== 'undefined' ? (navigator.hardwareConcurrency || 2) : 2;\n\n/**\n * @module pool\n */\n\n/**\n * Pool for workers to decode chunks of the images.\n */\nclass Pool {\n  /**\n   * @constructor\n   * @param {Number} [size] The size of the pool. Defaults to the number of CPUs\n   *                      available. When this parameter is `null` or 0, then the\n   *                      decoding will be done in the main thread.\n   * @param {function(): Worker} [createWorker] A function that creates the decoder worker.\n   * Defaults to a worker with all decoders that ship with geotiff.js. The `createWorker()`\n   * function is expected to return a `Worker` compatible with Web Workers. For code that\n   * runs in Node, [web-worker](https://www.npmjs.com/package/web-worker) is a good choice.\n   *\n   * A worker that uses a custom lzw decoder would look like this `my-custom-worker.js` file:\n   * ```js\n   * import { addDecoder, getDecoder } from 'geotiff';\n   * addDecoder(5, () => import ('./my-custom-lzw').then((m) => m.default));\n   * self.addEventListener('message', async (e) => {\n   *   const { id, fileDirectory, buffer } = e.data;\n   *   const decoder = await getDecoder(fileDirectory);\n   *   const decoded = await decoder.decode(fileDirectory, buffer);\n   *   self.postMessage({ decoded, id }, [decoded]);\n   * });\n   * ```\n   * The way the above code is built into a worker by the `createWorker()` function\n   * depends on the used bundler. For most bundlers, something like this will work:\n   * ```js\n   * function createWorker() {\n   *   return new Worker(new URL('./my-custom-worker.js', import.meta.url));\n   * }\n   * ```\n   */\n  constructor(size = defaultPoolSize, createWorker) {\n    this.workers = null;\n    this._awaitingDecoder = null;\n    this.size = size;\n    this.messageId = 0;\n    if (size) {\n      this._awaitingDecoder = createWorker ? Promise.resolve(createWorker) : new Promise((resolve) => {\n        __webpack_require__.e(/*! import() */ 13).then(__webpack_require__.bind(null, /*! ./worker/decoder.js */ \"./node_modules/geotiff/dist-module/worker/decoder.js\")).then((module) => {\n          resolve(module.create);\n        });\n      });\n      this._awaitingDecoder.then((create) => {\n        this._awaitingDecoder = null;\n        this.workers = [];\n        for (let i = 0; i < size; i++) {\n          this.workers.push({ worker: create(), idle: true });\n        }\n      });\n    }\n  }\n\n  /**\n   * Decode the given block of bytes with the set compression method.\n   * @param {ArrayBuffer} buffer the array buffer of bytes to decode.\n   * @returns {Promise<ArrayBuffer>} the decoded result as a `Promise`\n   */\n  async decode(fileDirectory, buffer) {\n    if (this._awaitingDecoder) {\n      await this._awaitingDecoder;\n    }\n    return this.size === 0\n      ? Object(_compression_index_js__WEBPACK_IMPORTED_MODULE_0__[\"getDecoder\"])(fileDirectory).then((decoder) => decoder.decode(fileDirectory, buffer))\n      : new Promise((resolve) => {\n        const worker = this.workers.find((candidate) => candidate.idle)\n          || this.workers[Math.floor(Math.random() * this.size)];\n        worker.idle = false;\n        const id = this.messageId++;\n        const onMessage = (e) => {\n          if (e.data.id === id) {\n            worker.idle = true;\n            resolve(e.data.decoded);\n            worker.worker.removeEventListener('message', onMessage);\n          }\n        };\n        worker.worker.addEventListener('message', onMessage);\n        worker.worker.postMessage({ fileDirectory, buffer, id }, [buffer]);\n      });\n  }\n\n  destroy() {\n    if (this.workers) {\n      this.workers.forEach((worker) => {\n        worker.worker.terminate();\n      });\n      this.workers = null;\n    }\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Pool);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9wb29sLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvcG9vbC5qcz9hMDBmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldERlY29kZXIgfSBmcm9tICcuL2NvbXByZXNzaW9uL2luZGV4LmpzJztcblxuY29uc3QgZGVmYXVsdFBvb2xTaXplID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgPyAobmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3kgfHwgMikgOiAyO1xuXG4vKipcbiAqIEBtb2R1bGUgcG9vbFxuICovXG5cbi8qKlxuICogUG9vbCBmb3Igd29ya2VycyB0byBkZWNvZGUgY2h1bmtzIG9mIHRoZSBpbWFnZXMuXG4gKi9cbmNsYXNzIFBvb2wge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbc2l6ZV0gVGhlIHNpemUgb2YgdGhlIHBvb2wuIERlZmF1bHRzIHRvIHRoZSBudW1iZXIgb2YgQ1BVc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICBhdmFpbGFibGUuIFdoZW4gdGhpcyBwYXJhbWV0ZXIgaXMgYG51bGxgIG9yIDAsIHRoZW4gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgIGRlY29kaW5nIHdpbGwgYmUgZG9uZSBpbiB0aGUgbWFpbiB0aHJlYWQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogV29ya2VyfSBbY3JlYXRlV29ya2VyXSBBIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyB0aGUgZGVjb2RlciB3b3JrZXIuXG4gICAqIERlZmF1bHRzIHRvIGEgd29ya2VyIHdpdGggYWxsIGRlY29kZXJzIHRoYXQgc2hpcCB3aXRoIGdlb3RpZmYuanMuIFRoZSBgY3JlYXRlV29ya2VyKClgXG4gICAqIGZ1bmN0aW9uIGlzIGV4cGVjdGVkIHRvIHJldHVybiBhIGBXb3JrZXJgIGNvbXBhdGlibGUgd2l0aCBXZWIgV29ya2Vycy4gRm9yIGNvZGUgdGhhdFxuICAgKiBydW5zIGluIE5vZGUsIFt3ZWItd29ya2VyXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS93ZWItd29ya2VyKSBpcyBhIGdvb2QgY2hvaWNlLlxuICAgKlxuICAgKiBBIHdvcmtlciB0aGF0IHVzZXMgYSBjdXN0b20gbHp3IGRlY29kZXIgd291bGQgbG9vayBsaWtlIHRoaXMgYG15LWN1c3RvbS13b3JrZXIuanNgIGZpbGU6XG4gICAqIGBgYGpzXG4gICAqIGltcG9ydCB7IGFkZERlY29kZXIsIGdldERlY29kZXIgfSBmcm9tICdnZW90aWZmJztcbiAgICogYWRkRGVjb2Rlcig1LCAoKSA9PiBpbXBvcnQgKCcuL215LWN1c3RvbS1sencnKS50aGVuKChtKSA9PiBtLmRlZmF1bHQpKTtcbiAgICogc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgYXN5bmMgKGUpID0+IHtcbiAgICogICBjb25zdCB7IGlkLCBmaWxlRGlyZWN0b3J5LCBidWZmZXIgfSA9IGUuZGF0YTtcbiAgICogICBjb25zdCBkZWNvZGVyID0gYXdhaXQgZ2V0RGVjb2RlcihmaWxlRGlyZWN0b3J5KTtcbiAgICogICBjb25zdCBkZWNvZGVkID0gYXdhaXQgZGVjb2Rlci5kZWNvZGUoZmlsZURpcmVjdG9yeSwgYnVmZmVyKTtcbiAgICogICBzZWxmLnBvc3RNZXNzYWdlKHsgZGVjb2RlZCwgaWQgfSwgW2RlY29kZWRdKTtcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKiBUaGUgd2F5IHRoZSBhYm92ZSBjb2RlIGlzIGJ1aWx0IGludG8gYSB3b3JrZXIgYnkgdGhlIGBjcmVhdGVXb3JrZXIoKWAgZnVuY3Rpb25cbiAgICogZGVwZW5kcyBvbiB0aGUgdXNlZCBidW5kbGVyLiBGb3IgbW9zdCBidW5kbGVycywgc29tZXRoaW5nIGxpa2UgdGhpcyB3aWxsIHdvcms6XG4gICAqIGBgYGpzXG4gICAqIGZ1bmN0aW9uIGNyZWF0ZVdvcmtlcigpIHtcbiAgICogICByZXR1cm4gbmV3IFdvcmtlcihuZXcgVVJMKCcuL215LWN1c3RvbS13b3JrZXIuanMnLCBpbXBvcnQubWV0YS51cmwpKTtcbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNpemUgPSBkZWZhdWx0UG9vbFNpemUsIGNyZWF0ZVdvcmtlcikge1xuICAgIHRoaXMud29ya2VycyA9IG51bGw7XG4gICAgdGhpcy5fYXdhaXRpbmdEZWNvZGVyID0gbnVsbDtcbiAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIHRoaXMubWVzc2FnZUlkID0gMDtcbiAgICBpZiAoc2l6ZSkge1xuICAgICAgdGhpcy5fYXdhaXRpbmdEZWNvZGVyID0gY3JlYXRlV29ya2VyID8gUHJvbWlzZS5yZXNvbHZlKGNyZWF0ZVdvcmtlcikgOiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBpbXBvcnQoJy4vd29ya2VyL2RlY29kZXIuanMnKS50aGVuKChtb2R1bGUpID0+IHtcbiAgICAgICAgICByZXNvbHZlKG1vZHVsZS5jcmVhdGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fYXdhaXRpbmdEZWNvZGVyLnRoZW4oKGNyZWF0ZSkgPT4ge1xuICAgICAgICB0aGlzLl9hd2FpdGluZ0RlY29kZXIgPSBudWxsO1xuICAgICAgICB0aGlzLndvcmtlcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICB0aGlzLndvcmtlcnMucHVzaCh7IHdvcmtlcjogY3JlYXRlKCksIGlkbGU6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgdGhlIGdpdmVuIGJsb2NrIG9mIGJ5dGVzIHdpdGggdGhlIHNldCBjb21wcmVzc2lvbiBtZXRob2QuXG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZmZlciB0aGUgYXJyYXkgYnVmZmVyIG9mIGJ5dGVzIHRvIGRlY29kZS5cbiAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXlCdWZmZXI+fSB0aGUgZGVjb2RlZCByZXN1bHQgYXMgYSBgUHJvbWlzZWBcbiAgICovXG4gIGFzeW5jIGRlY29kZShmaWxlRGlyZWN0b3J5LCBidWZmZXIpIHtcbiAgICBpZiAodGhpcy5fYXdhaXRpbmdEZWNvZGVyKSB7XG4gICAgICBhd2FpdCB0aGlzLl9hd2FpdGluZ0RlY29kZXI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNpemUgPT09IDBcbiAgICAgID8gZ2V0RGVjb2RlcihmaWxlRGlyZWN0b3J5KS50aGVuKChkZWNvZGVyKSA9PiBkZWNvZGVyLmRlY29kZShmaWxlRGlyZWN0b3J5LCBidWZmZXIpKVxuICAgICAgOiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBjb25zdCB3b3JrZXIgPSB0aGlzLndvcmtlcnMuZmluZCgoY2FuZGlkYXRlKSA9PiBjYW5kaWRhdGUuaWRsZSlcbiAgICAgICAgICB8fCB0aGlzLndvcmtlcnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGhpcy5zaXplKV07XG4gICAgICAgIHdvcmtlci5pZGxlID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy5tZXNzYWdlSWQrKztcbiAgICAgICAgY29uc3Qgb25NZXNzYWdlID0gKGUpID0+IHtcbiAgICAgICAgICBpZiAoZS5kYXRhLmlkID09PSBpZCkge1xuICAgICAgICAgICAgd29ya2VyLmlkbGUgPSB0cnVlO1xuICAgICAgICAgICAgcmVzb2x2ZShlLmRhdGEuZGVjb2RlZCk7XG4gICAgICAgICAgICB3b3JrZXIud29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBvbk1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgd29ya2VyLndvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb25NZXNzYWdlKTtcbiAgICAgICAgd29ya2VyLndvcmtlci5wb3N0TWVzc2FnZSh7IGZpbGVEaXJlY3RvcnksIGJ1ZmZlciwgaWQgfSwgW2J1ZmZlcl0pO1xuICAgICAgfSk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLndvcmtlcnMpIHtcbiAgICAgIHRoaXMud29ya2Vycy5mb3JFYWNoKCh3b3JrZXIpID0+IHtcbiAgICAgICAgd29ya2VyLndvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy53b3JrZXJzID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUG9vbDtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/pool.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/predictor.js":
/*!*******************************************************!*\
  !*** ./node_modules/geotiff/dist-module/predictor.js ***!
  \*******************************************************/
/*! exports provided: applyPredictor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"applyPredictor\", function() { return applyPredictor; });\nfunction decodeRowAcc(row, stride) {\n  let length = row.length - stride;\n  let offset = 0;\n  do {\n    for (let i = stride; i > 0; i--) {\n      row[offset + stride] += row[offset];\n      offset++;\n    }\n\n    length -= stride;\n  } while (length > 0);\n}\n\nfunction decodeRowFloatingPoint(row, stride, bytesPerSample) {\n  let index = 0;\n  let count = row.length;\n  const wc = count / bytesPerSample;\n\n  while (count > stride) {\n    for (let i = stride; i > 0; --i) {\n      row[index + stride] += row[index];\n      ++index;\n    }\n    count -= stride;\n  }\n\n  const copy = row.slice();\n  for (let i = 0; i < wc; ++i) {\n    for (let b = 0; b < bytesPerSample; ++b) {\n      row[(bytesPerSample * i) + b] = copy[((bytesPerSample - b - 1) * wc) + i];\n    }\n  }\n}\n\nfunction applyPredictor(block, predictor, width, height, bitsPerSample,\n  planarConfiguration) {\n  if (!predictor || predictor === 1) {\n    return block;\n  }\n\n  for (let i = 0; i < bitsPerSample.length; ++i) {\n    if (bitsPerSample[i] % 8 !== 0) {\n      throw new Error('When decoding with predictor, only multiple of 8 bits are supported.');\n    }\n    if (bitsPerSample[i] !== bitsPerSample[0]) {\n      throw new Error('When decoding with predictor, all samples must have the same size.');\n    }\n  }\n\n  const bytesPerSample = bitsPerSample[0] / 8;\n  const stride = planarConfiguration === 2 ? 1 : bitsPerSample.length;\n\n  for (let i = 0; i < height; ++i) {\n    // Last strip will be truncated if height % stripHeight != 0\n    if (i * stride * width * bytesPerSample >= block.byteLength) {\n      break;\n    }\n    let row;\n    if (predictor === 2) { // horizontal prediction\n      switch (bitsPerSample[0]) {\n        case 8:\n          row = new Uint8Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n          );\n          break;\n        case 16:\n          row = new Uint16Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 2,\n          );\n          break;\n        case 32:\n          row = new Uint32Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 4,\n          );\n          break;\n        default:\n          throw new Error(`Predictor 2 not allowed with ${bitsPerSample[0]} bits per sample.`);\n      }\n      decodeRowAcc(row, stride, bytesPerSample);\n    } else if (predictor === 3) { // horizontal floating point\n      row = new Uint8Array(\n        block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n      );\n      decodeRowFloatingPoint(row, stride, bytesPerSample);\n    }\n  }\n  return block;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9wcmVkaWN0b3IuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9wcmVkaWN0b3IuanM/NWQ0NSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBkZWNvZGVSb3dBY2Mocm93LCBzdHJpZGUpIHtcbiAgbGV0IGxlbmd0aCA9IHJvdy5sZW5ndGggLSBzdHJpZGU7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBkbyB7XG4gICAgZm9yIChsZXQgaSA9IHN0cmlkZTsgaSA+IDA7IGktLSkge1xuICAgICAgcm93W29mZnNldCArIHN0cmlkZV0gKz0gcm93W29mZnNldF07XG4gICAgICBvZmZzZXQrKztcbiAgICB9XG5cbiAgICBsZW5ndGggLT0gc3RyaWRlO1xuICB9IHdoaWxlIChsZW5ndGggPiAwKTtcbn1cblxuZnVuY3Rpb24gZGVjb2RlUm93RmxvYXRpbmdQb2ludChyb3csIHN0cmlkZSwgYnl0ZXNQZXJTYW1wbGUpIHtcbiAgbGV0IGluZGV4ID0gMDtcbiAgbGV0IGNvdW50ID0gcm93Lmxlbmd0aDtcbiAgY29uc3Qgd2MgPSBjb3VudCAvIGJ5dGVzUGVyU2FtcGxlO1xuXG4gIHdoaWxlIChjb3VudCA+IHN0cmlkZSkge1xuICAgIGZvciAobGV0IGkgPSBzdHJpZGU7IGkgPiAwOyAtLWkpIHtcbiAgICAgIHJvd1tpbmRleCArIHN0cmlkZV0gKz0gcm93W2luZGV4XTtcbiAgICAgICsraW5kZXg7XG4gICAgfVxuICAgIGNvdW50IC09IHN0cmlkZTtcbiAgfVxuXG4gIGNvbnN0IGNvcHkgPSByb3cuc2xpY2UoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB3YzsgKytpKSB7XG4gICAgZm9yIChsZXQgYiA9IDA7IGIgPCBieXRlc1BlclNhbXBsZTsgKytiKSB7XG4gICAgICByb3dbKGJ5dGVzUGVyU2FtcGxlICogaSkgKyBiXSA9IGNvcHlbKChieXRlc1BlclNhbXBsZSAtIGIgLSAxKSAqIHdjKSArIGldO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlQcmVkaWN0b3IoYmxvY2ssIHByZWRpY3Rvciwgd2lkdGgsIGhlaWdodCwgYml0c1BlclNhbXBsZSxcbiAgcGxhbmFyQ29uZmlndXJhdGlvbikge1xuICBpZiAoIXByZWRpY3RvciB8fCBwcmVkaWN0b3IgPT09IDEpIHtcbiAgICByZXR1cm4gYmxvY2s7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJpdHNQZXJTYW1wbGUubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYml0c1BlclNhbXBsZVtpXSAlIDggIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2hlbiBkZWNvZGluZyB3aXRoIHByZWRpY3Rvciwgb25seSBtdWx0aXBsZSBvZiA4IGJpdHMgYXJlIHN1cHBvcnRlZC4nKTtcbiAgICB9XG4gICAgaWYgKGJpdHNQZXJTYW1wbGVbaV0gIT09IGJpdHNQZXJTYW1wbGVbMF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2hlbiBkZWNvZGluZyB3aXRoIHByZWRpY3RvciwgYWxsIHNhbXBsZXMgbXVzdCBoYXZlIHRoZSBzYW1lIHNpemUuJyk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgYnl0ZXNQZXJTYW1wbGUgPSBiaXRzUGVyU2FtcGxlWzBdIC8gODtcbiAgY29uc3Qgc3RyaWRlID0gcGxhbmFyQ29uZmlndXJhdGlvbiA9PT0gMiA/IDEgOiBiaXRzUGVyU2FtcGxlLmxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGhlaWdodDsgKytpKSB7XG4gICAgLy8gTGFzdCBzdHJpcCB3aWxsIGJlIHRydW5jYXRlZCBpZiBoZWlnaHQgJSBzdHJpcEhlaWdodCAhPSAwXG4gICAgaWYgKGkgKiBzdHJpZGUgKiB3aWR0aCAqIGJ5dGVzUGVyU2FtcGxlID49IGJsb2NrLmJ5dGVMZW5ndGgpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBsZXQgcm93O1xuICAgIGlmIChwcmVkaWN0b3IgPT09IDIpIHsgLy8gaG9yaXpvbnRhbCBwcmVkaWN0aW9uXG4gICAgICBzd2l0Y2ggKGJpdHNQZXJTYW1wbGVbMF0pIHtcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIHJvdyA9IG5ldyBVaW50OEFycmF5KFxuICAgICAgICAgICAgYmxvY2ssIGkgKiBzdHJpZGUgKiB3aWR0aCAqIGJ5dGVzUGVyU2FtcGxlLCBzdHJpZGUgKiB3aWR0aCAqIGJ5dGVzUGVyU2FtcGxlLFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgcm93ID0gbmV3IFVpbnQxNkFycmF5KFxuICAgICAgICAgICAgYmxvY2ssIGkgKiBzdHJpZGUgKiB3aWR0aCAqIGJ5dGVzUGVyU2FtcGxlLCBzdHJpZGUgKiB3aWR0aCAqIGJ5dGVzUGVyU2FtcGxlIC8gMixcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgIHJvdyA9IG5ldyBVaW50MzJBcnJheShcbiAgICAgICAgICAgIGJsb2NrLCBpICogc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSwgc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSAvIDQsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByZWRpY3RvciAyIG5vdCBhbGxvd2VkIHdpdGggJHtiaXRzUGVyU2FtcGxlWzBdfSBiaXRzIHBlciBzYW1wbGUuYCk7XG4gICAgICB9XG4gICAgICBkZWNvZGVSb3dBY2Mocm93LCBzdHJpZGUsIGJ5dGVzUGVyU2FtcGxlKTtcbiAgICB9IGVsc2UgaWYgKHByZWRpY3RvciA9PT0gMykgeyAvLyBob3Jpem9udGFsIGZsb2F0aW5nIHBvaW50XG4gICAgICByb3cgPSBuZXcgVWludDhBcnJheShcbiAgICAgICAgYmxvY2ssIGkgKiBzdHJpZGUgKiB3aWR0aCAqIGJ5dGVzUGVyU2FtcGxlLCBzdHJpZGUgKiB3aWR0aCAqIGJ5dGVzUGVyU2FtcGxlLFxuICAgICAgKTtcbiAgICAgIGRlY29kZVJvd0Zsb2F0aW5nUG9pbnQocm93LCBzdHJpZGUsIGJ5dGVzUGVyU2FtcGxlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJsb2NrO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/predictor.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/resample.js":
/*!******************************************************!*\
  !*** ./node_modules/geotiff/dist-module/resample.js ***!
  \******************************************************/
/*! exports provided: resampleNearest, resampleBilinear, resample, resampleNearestInterleaved, resampleBilinearInterleaved, resampleInterleaved */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"resampleNearest\", function() { return resampleNearest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"resampleBilinear\", function() { return resampleBilinear; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"resample\", function() { return resample; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"resampleNearestInterleaved\", function() { return resampleNearestInterleaved; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"resampleBilinearInterleaved\", function() { return resampleBilinearInterleaved; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"resampleInterleaved\", function() { return resampleInterleaved; });\n/**\n * @module resample\n */\n\nfunction copyNewSize(array, width, height, samplesPerPixel = 1) {\n  return new (Object.getPrototypeOf(array).constructor)(width * height * samplesPerPixel);\n}\n\n/**\n * Resample the input arrays using nearest neighbor value selection.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nfunction resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const cy = Math.min(Math.round(relY * y), inHeight - 1);\n      for (let x = 0; x < outWidth; ++x) {\n        const cx = Math.min(Math.round(relX * x), inWidth - 1);\n        const value = array[(cy * inWidth) + cx];\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n// simple linear interpolation, code from:\n// https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support\nfunction lerp(v0, v1, t) {\n  return ((1 - t) * v0) + (t * v1);\n}\n\n/**\n * Resample the input arrays using bilinear interpolation.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nfunction resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const rawY = relY * y;\n\n      const yl = Math.floor(rawY);\n      const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n      for (let x = 0; x < outWidth; ++x) {\n        const rawX = relX * x;\n        const tx = rawX % 1;\n\n        const xl = Math.floor(rawX);\n        const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n        const ll = array[(yl * inWidth) + xl];\n        const hl = array[(yl * inWidth) + xh];\n        const lh = array[(yh * inWidth) + xl];\n        const hh = array[(yh * inWidth) + xh];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n/**\n * Resample the input arrays using the selected resampling method.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray[]} The resampled rasters\n */\nfunction resample(valueArrays, inWidth, inHeight, outWidth, outHeight, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n\n/**\n * Resample the pixel interleaved input array using nearest neighbor value selection.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nfunction resampleNearestInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const cy = Math.min(Math.round(relY * y), inHeight - 1);\n    for (let x = 0; x < outWidth; ++x) {\n      const cx = Math.min(Math.round(relX * x), inWidth - 1);\n      for (let i = 0; i < samples; ++i) {\n        const value = valueArray[(cy * inWidth * samples) + (cx * samples) + i];\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using bilinear interpolation.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nfunction resampleBilinearInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const rawY = relY * y;\n\n    const yl = Math.floor(rawY);\n    const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n    for (let x = 0; x < outWidth; ++x) {\n      const rawX = relX * x;\n      const tx = rawX % 1;\n\n      const xl = Math.floor(rawX);\n      const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n      for (let i = 0; i < samples; ++i) {\n        const ll = valueArray[(yl * inWidth * samples) + (xl * samples) + i];\n        const hl = valueArray[(yl * inWidth * samples) + (xh * samples) + i];\n        const lh = valueArray[(yh * inWidth * samples) + (xl * samples) + i];\n        const hh = valueArray[(yh * inWidth * samples) + (xh * samples) + i];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using the selected resampling method.\n * @param {TypedArray} valueArray The input array to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                                 interleaved data\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray} The resampled rasters\n */\nfunction resampleInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearestInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinearInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9yZXNhbXBsZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3Jlc2FtcGxlLmpzPzdlMGMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIHJlc2FtcGxlXG4gKi9cblxuZnVuY3Rpb24gY29weU5ld1NpemUoYXJyYXksIHdpZHRoLCBoZWlnaHQsIHNhbXBsZXNQZXJQaXhlbCA9IDEpIHtcbiAgcmV0dXJuIG5ldyAoT2JqZWN0LmdldFByb3RvdHlwZU9mKGFycmF5KS5jb25zdHJ1Y3Rvcikod2lkdGggKiBoZWlnaHQgKiBzYW1wbGVzUGVyUGl4ZWwpO1xufVxuXG4vKipcbiAqIFJlc2FtcGxlIHRoZSBpbnB1dCBhcnJheXMgdXNpbmcgbmVhcmVzdCBuZWlnaGJvciB2YWx1ZSBzZWxlY3Rpb24uXG4gKiBAcGFyYW0ge1R5cGVkQXJyYXlbXX0gdmFsdWVBcnJheXMgVGhlIGlucHV0IGFycmF5cyB0byByZXNhbXBsZVxuICogQHBhcmFtIHtudW1iZXJ9IGluV2lkdGggVGhlIHdpZHRoIG9mIHRoZSBpbnB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gaW5IZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgaW5wdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IG91dFdpZHRoIFRoZSBkZXNpcmVkIHdpZHRoIG9mIHRoZSBvdXRwdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IG91dEhlaWdodCBUaGUgZGVzaXJlZCBoZWlnaHQgb2YgdGhlIG91dHB1dCByYXN0ZXJzXG4gKiBAcmV0dXJucyB7VHlwZWRBcnJheVtdfSBUaGUgcmVzYW1wbGVkIHJhc3RlcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2FtcGxlTmVhcmVzdCh2YWx1ZUFycmF5cywgaW5XaWR0aCwgaW5IZWlnaHQsIG91dFdpZHRoLCBvdXRIZWlnaHQpIHtcbiAgY29uc3QgcmVsWCA9IGluV2lkdGggLyBvdXRXaWR0aDtcbiAgY29uc3QgcmVsWSA9IGluSGVpZ2h0IC8gb3V0SGVpZ2h0O1xuICByZXR1cm4gdmFsdWVBcnJheXMubWFwKChhcnJheSkgPT4ge1xuICAgIGNvbnN0IG5ld0FycmF5ID0gY29weU5ld1NpemUoYXJyYXksIG91dFdpZHRoLCBvdXRIZWlnaHQpO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgb3V0SGVpZ2h0OyArK3kpIHtcbiAgICAgIGNvbnN0IGN5ID0gTWF0aC5taW4oTWF0aC5yb3VuZChyZWxZICogeSksIGluSGVpZ2h0IC0gMSk7XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG91dFdpZHRoOyArK3gpIHtcbiAgICAgICAgY29uc3QgY3ggPSBNYXRoLm1pbihNYXRoLnJvdW5kKHJlbFggKiB4KSwgaW5XaWR0aCAtIDEpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGFycmF5WyhjeSAqIGluV2lkdGgpICsgY3hdO1xuICAgICAgICBuZXdBcnJheVsoeSAqIG91dFdpZHRoKSArIHhdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdBcnJheTtcbiAgfSk7XG59XG5cbi8vIHNpbXBsZSBsaW5lYXIgaW50ZXJwb2xhdGlvbiwgY29kZSBmcm9tOlxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGluZWFyX2ludGVycG9sYXRpb24jUHJvZ3JhbW1pbmdfbGFuZ3VhZ2Vfc3VwcG9ydFxuZnVuY3Rpb24gbGVycCh2MCwgdjEsIHQpIHtcbiAgcmV0dXJuICgoMSAtIHQpICogdjApICsgKHQgKiB2MSk7XG59XG5cbi8qKlxuICogUmVzYW1wbGUgdGhlIGlucHV0IGFycmF5cyB1c2luZyBiaWxpbmVhciBpbnRlcnBvbGF0aW9uLlxuICogQHBhcmFtIHtUeXBlZEFycmF5W119IHZhbHVlQXJyYXlzIFRoZSBpbnB1dCBhcnJheXMgdG8gcmVzYW1wbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbldpZHRoIFRoZSB3aWR0aCBvZiB0aGUgaW5wdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IGluSGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIGlucHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRXaWR0aCBUaGUgZGVzaXJlZCB3aWR0aCBvZiB0aGUgb3V0cHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRIZWlnaHQgVGhlIGRlc2lyZWQgaGVpZ2h0IG9mIHRoZSBvdXRwdXQgcmFzdGVyc1xuICogQHJldHVybnMge1R5cGVkQXJyYXlbXX0gVGhlIHJlc2FtcGxlZCByYXN0ZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNhbXBsZUJpbGluZWFyKHZhbHVlQXJyYXlzLCBpbldpZHRoLCBpbkhlaWdodCwgb3V0V2lkdGgsIG91dEhlaWdodCkge1xuICBjb25zdCByZWxYID0gaW5XaWR0aCAvIG91dFdpZHRoO1xuICBjb25zdCByZWxZID0gaW5IZWlnaHQgLyBvdXRIZWlnaHQ7XG5cbiAgcmV0dXJuIHZhbHVlQXJyYXlzLm1hcCgoYXJyYXkpID0+IHtcbiAgICBjb25zdCBuZXdBcnJheSA9IGNvcHlOZXdTaXplKGFycmF5LCBvdXRXaWR0aCwgb3V0SGVpZ2h0KTtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IG91dEhlaWdodDsgKyt5KSB7XG4gICAgICBjb25zdCByYXdZID0gcmVsWSAqIHk7XG5cbiAgICAgIGNvbnN0IHlsID0gTWF0aC5mbG9vcihyYXdZKTtcbiAgICAgIGNvbnN0IHloID0gTWF0aC5taW4oTWF0aC5jZWlsKHJhd1kpLCAoaW5IZWlnaHQgLSAxKSk7XG5cbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgb3V0V2lkdGg7ICsreCkge1xuICAgICAgICBjb25zdCByYXdYID0gcmVsWCAqIHg7XG4gICAgICAgIGNvbnN0IHR4ID0gcmF3WCAlIDE7XG5cbiAgICAgICAgY29uc3QgeGwgPSBNYXRoLmZsb29yKHJhd1gpO1xuICAgICAgICBjb25zdCB4aCA9IE1hdGgubWluKE1hdGguY2VpbChyYXdYKSwgKGluV2lkdGggLSAxKSk7XG5cbiAgICAgICAgY29uc3QgbGwgPSBhcnJheVsoeWwgKiBpbldpZHRoKSArIHhsXTtcbiAgICAgICAgY29uc3QgaGwgPSBhcnJheVsoeWwgKiBpbldpZHRoKSArIHhoXTtcbiAgICAgICAgY29uc3QgbGggPSBhcnJheVsoeWggKiBpbldpZHRoKSArIHhsXTtcbiAgICAgICAgY29uc3QgaGggPSBhcnJheVsoeWggKiBpbldpZHRoKSArIHhoXTtcblxuICAgICAgICBjb25zdCB2YWx1ZSA9IGxlcnAoXG4gICAgICAgICAgbGVycChsbCwgaGwsIHR4KSxcbiAgICAgICAgICBsZXJwKGxoLCBoaCwgdHgpLFxuICAgICAgICAgIHJhd1kgJSAxLFxuICAgICAgICApO1xuICAgICAgICBuZXdBcnJheVsoeSAqIG91dFdpZHRoKSArIHhdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdBcnJheTtcbiAgfSk7XG59XG5cbi8qKlxuICogUmVzYW1wbGUgdGhlIGlucHV0IGFycmF5cyB1c2luZyB0aGUgc2VsZWN0ZWQgcmVzYW1wbGluZyBtZXRob2QuXG4gKiBAcGFyYW0ge1R5cGVkQXJyYXlbXX0gdmFsdWVBcnJheXMgVGhlIGlucHV0IGFycmF5cyB0byByZXNhbXBsZVxuICogQHBhcmFtIHtudW1iZXJ9IGluV2lkdGggVGhlIHdpZHRoIG9mIHRoZSBpbnB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gaW5IZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgaW5wdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IG91dFdpZHRoIFRoZSBkZXNpcmVkIHdpZHRoIG9mIHRoZSBvdXRwdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IG91dEhlaWdodCBUaGUgZGVzaXJlZCBoZWlnaHQgb2YgdGhlIG91dHB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge3N0cmluZ30gW21ldGhvZCA9ICduZWFyZXN0J10gVGhlIGRlc2lyZWQgcmVzYW1wbGluZyBtZXRob2RcbiAqIEByZXR1cm5zIHtUeXBlZEFycmF5W119IFRoZSByZXNhbXBsZWQgcmFzdGVyc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzYW1wbGUodmFsdWVBcnJheXMsIGluV2lkdGgsIGluSGVpZ2h0LCBvdXRXaWR0aCwgb3V0SGVpZ2h0LCBtZXRob2QgPSAnbmVhcmVzdCcpIHtcbiAgc3dpdGNoIChtZXRob2QudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ25lYXJlc3QnOlxuICAgICAgcmV0dXJuIHJlc2FtcGxlTmVhcmVzdCh2YWx1ZUFycmF5cywgaW5XaWR0aCwgaW5IZWlnaHQsIG91dFdpZHRoLCBvdXRIZWlnaHQpO1xuICAgIGNhc2UgJ2JpbGluZWFyJzpcbiAgICBjYXNlICdsaW5lYXInOlxuICAgICAgcmV0dXJuIHJlc2FtcGxlQmlsaW5lYXIodmFsdWVBcnJheXMsIGluV2lkdGgsIGluSGVpZ2h0LCBvdXRXaWR0aCwgb3V0SGVpZ2h0KTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCByZXNhbXBsaW5nIG1ldGhvZDogJyR7bWV0aG9kfSdgKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlc2FtcGxlIHRoZSBwaXhlbCBpbnRlcmxlYXZlZCBpbnB1dCBhcnJheSB1c2luZyBuZWFyZXN0IG5laWdoYm9yIHZhbHVlIHNlbGVjdGlvbi5cbiAqIEBwYXJhbSB7VHlwZWRBcnJheX0gdmFsdWVBcnJheXMgVGhlIGlucHV0IGFycmF5cyB0byByZXNhbXBsZVxuICogQHBhcmFtIHtudW1iZXJ9IGluV2lkdGggVGhlIHdpZHRoIG9mIHRoZSBpbnB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gaW5IZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgaW5wdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IG91dFdpZHRoIFRoZSBkZXNpcmVkIHdpZHRoIG9mIHRoZSBvdXRwdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IG91dEhlaWdodCBUaGUgZGVzaXJlZCBoZWlnaHQgb2YgdGhlIG91dHB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gc2FtcGxlcyBUaGUgbnVtYmVyIG9mIHNhbXBsZXMgcGVyIHBpeGVsIGZvciBwaXhlbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJsZWF2ZWQgZGF0YVxuICogQHJldHVybnMge1R5cGVkQXJyYXl9IFRoZSByZXNhbXBsZWQgcmFzdGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNhbXBsZU5lYXJlc3RJbnRlcmxlYXZlZChcbiAgdmFsdWVBcnJheSwgaW5XaWR0aCwgaW5IZWlnaHQsIG91dFdpZHRoLCBvdXRIZWlnaHQsIHNhbXBsZXMpIHtcbiAgY29uc3QgcmVsWCA9IGluV2lkdGggLyBvdXRXaWR0aDtcbiAgY29uc3QgcmVsWSA9IGluSGVpZ2h0IC8gb3V0SGVpZ2h0O1xuXG4gIGNvbnN0IG5ld0FycmF5ID0gY29weU5ld1NpemUodmFsdWVBcnJheSwgb3V0V2lkdGgsIG91dEhlaWdodCwgc2FtcGxlcyk7XG4gIGZvciAobGV0IHkgPSAwOyB5IDwgb3V0SGVpZ2h0OyArK3kpIHtcbiAgICBjb25zdCBjeSA9IE1hdGgubWluKE1hdGgucm91bmQocmVsWSAqIHkpLCBpbkhlaWdodCAtIDEpO1xuICAgIGZvciAobGV0IHggPSAwOyB4IDwgb3V0V2lkdGg7ICsreCkge1xuICAgICAgY29uc3QgY3ggPSBNYXRoLm1pbihNYXRoLnJvdW5kKHJlbFggKiB4KSwgaW5XaWR0aCAtIDEpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzOyArK2kpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZUFycmF5WyhjeSAqIGluV2lkdGggKiBzYW1wbGVzKSArIChjeCAqIHNhbXBsZXMpICsgaV07XG4gICAgICAgIG5ld0FycmF5Wyh5ICogb3V0V2lkdGggKiBzYW1wbGVzKSArICh4ICogc2FtcGxlcykgKyBpXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3QXJyYXk7XG59XG5cbi8qKlxuICogUmVzYW1wbGUgdGhlIHBpeGVsIGludGVybGVhdmVkIGlucHV0IGFycmF5IHVzaW5nIGJpbGluZWFyIGludGVycG9sYXRpb24uXG4gKiBAcGFyYW0ge1R5cGVkQXJyYXl9IHZhbHVlQXJyYXlzIFRoZSBpbnB1dCBhcnJheXMgdG8gcmVzYW1wbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbldpZHRoIFRoZSB3aWR0aCBvZiB0aGUgaW5wdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IGluSGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIGlucHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRXaWR0aCBUaGUgZGVzaXJlZCB3aWR0aCBvZiB0aGUgb3V0cHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRIZWlnaHQgVGhlIGRlc2lyZWQgaGVpZ2h0IG9mIHRoZSBvdXRwdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IHNhbXBsZXMgVGhlIG51bWJlciBvZiBzYW1wbGVzIHBlciBwaXhlbCBmb3IgcGl4ZWxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybGVhdmVkIGRhdGFcbiAqIEByZXR1cm5zIHtUeXBlZEFycmF5fSBUaGUgcmVzYW1wbGVkIHJhc3RlclxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzYW1wbGVCaWxpbmVhckludGVybGVhdmVkKFxuICB2YWx1ZUFycmF5LCBpbldpZHRoLCBpbkhlaWdodCwgb3V0V2lkdGgsIG91dEhlaWdodCwgc2FtcGxlcykge1xuICBjb25zdCByZWxYID0gaW5XaWR0aCAvIG91dFdpZHRoO1xuICBjb25zdCByZWxZID0gaW5IZWlnaHQgLyBvdXRIZWlnaHQ7XG4gIGNvbnN0IG5ld0FycmF5ID0gY29weU5ld1NpemUodmFsdWVBcnJheSwgb3V0V2lkdGgsIG91dEhlaWdodCwgc2FtcGxlcyk7XG4gIGZvciAobGV0IHkgPSAwOyB5IDwgb3V0SGVpZ2h0OyArK3kpIHtcbiAgICBjb25zdCByYXdZID0gcmVsWSAqIHk7XG5cbiAgICBjb25zdCB5bCA9IE1hdGguZmxvb3IocmF3WSk7XG4gICAgY29uc3QgeWggPSBNYXRoLm1pbihNYXRoLmNlaWwocmF3WSksIChpbkhlaWdodCAtIDEpKTtcblxuICAgIGZvciAobGV0IHggPSAwOyB4IDwgb3V0V2lkdGg7ICsreCkge1xuICAgICAgY29uc3QgcmF3WCA9IHJlbFggKiB4O1xuICAgICAgY29uc3QgdHggPSByYXdYICUgMTtcblxuICAgICAgY29uc3QgeGwgPSBNYXRoLmZsb29yKHJhd1gpO1xuICAgICAgY29uc3QgeGggPSBNYXRoLm1pbihNYXRoLmNlaWwocmF3WCksIChpbldpZHRoIC0gMSkpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZXM7ICsraSkge1xuICAgICAgICBjb25zdCBsbCA9IHZhbHVlQXJyYXlbKHlsICogaW5XaWR0aCAqIHNhbXBsZXMpICsgKHhsICogc2FtcGxlcykgKyBpXTtcbiAgICAgICAgY29uc3QgaGwgPSB2YWx1ZUFycmF5Wyh5bCAqIGluV2lkdGggKiBzYW1wbGVzKSArICh4aCAqIHNhbXBsZXMpICsgaV07XG4gICAgICAgIGNvbnN0IGxoID0gdmFsdWVBcnJheVsoeWggKiBpbldpZHRoICogc2FtcGxlcykgKyAoeGwgKiBzYW1wbGVzKSArIGldO1xuICAgICAgICBjb25zdCBoaCA9IHZhbHVlQXJyYXlbKHloICogaW5XaWR0aCAqIHNhbXBsZXMpICsgKHhoICogc2FtcGxlcykgKyBpXTtcblxuICAgICAgICBjb25zdCB2YWx1ZSA9IGxlcnAoXG4gICAgICAgICAgbGVycChsbCwgaGwsIHR4KSxcbiAgICAgICAgICBsZXJwKGxoLCBoaCwgdHgpLFxuICAgICAgICAgIHJhd1kgJSAxLFxuICAgICAgICApO1xuICAgICAgICBuZXdBcnJheVsoeSAqIG91dFdpZHRoICogc2FtcGxlcykgKyAoeCAqIHNhbXBsZXMpICsgaV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld0FycmF5O1xufVxuXG4vKipcbiAqIFJlc2FtcGxlIHRoZSBwaXhlbCBpbnRlcmxlYXZlZCBpbnB1dCBhcnJheSB1c2luZyB0aGUgc2VsZWN0ZWQgcmVzYW1wbGluZyBtZXRob2QuXG4gKiBAcGFyYW0ge1R5cGVkQXJyYXl9IHZhbHVlQXJyYXkgVGhlIGlucHV0IGFycmF5IHRvIHJlc2FtcGxlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5XaWR0aCBUaGUgd2lkdGggb2YgdGhlIGlucHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbkhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBpbnB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gb3V0V2lkdGggVGhlIGRlc2lyZWQgd2lkdGggb2YgdGhlIG91dHB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gb3V0SGVpZ2h0IFRoZSBkZXNpcmVkIGhlaWdodCBvZiB0aGUgb3V0cHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBzYW1wbGVzIFRoZSBudW1iZXIgb2Ygc2FtcGxlcyBwZXIgcGl4ZWwgZm9yIHBpeGVsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybGVhdmVkIGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbWV0aG9kID0gJ25lYXJlc3QnXSBUaGUgZGVzaXJlZCByZXNhbXBsaW5nIG1ldGhvZFxuICogQHJldHVybnMge1R5cGVkQXJyYXl9IFRoZSByZXNhbXBsZWQgcmFzdGVyc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzYW1wbGVJbnRlcmxlYXZlZCh2YWx1ZUFycmF5LCBpbldpZHRoLCBpbkhlaWdodCwgb3V0V2lkdGgsIG91dEhlaWdodCwgc2FtcGxlcywgbWV0aG9kID0gJ25lYXJlc3QnKSB7XG4gIHN3aXRjaCAobWV0aG9kLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICduZWFyZXN0JzpcbiAgICAgIHJldHVybiByZXNhbXBsZU5lYXJlc3RJbnRlcmxlYXZlZChcbiAgICAgICAgdmFsdWVBcnJheSwgaW5XaWR0aCwgaW5IZWlnaHQsIG91dFdpZHRoLCBvdXRIZWlnaHQsIHNhbXBsZXMsXG4gICAgICApO1xuICAgIGNhc2UgJ2JpbGluZWFyJzpcbiAgICBjYXNlICdsaW5lYXInOlxuICAgICAgcmV0dXJuIHJlc2FtcGxlQmlsaW5lYXJJbnRlcmxlYXZlZChcbiAgICAgICAgdmFsdWVBcnJheSwgaW5XaWR0aCwgaW5IZWlnaHQsIG91dFdpZHRoLCBvdXRIZWlnaHQsIHNhbXBsZXMsXG4gICAgICApO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHJlc2FtcGxpbmcgbWV0aG9kOiAnJHttZXRob2R9J2ApO1xuICB9XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/resample.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/rgb.js":
/*!*************************************************!*\
  !*** ./node_modules/geotiff/dist-module/rgb.js ***!
  \*************************************************/
/*! exports provided: fromWhiteIsZero, fromBlackIsZero, fromPalette, fromCMYK, fromYCbCr, fromCIELab */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromWhiteIsZero\", function() { return fromWhiteIsZero; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromBlackIsZero\", function() { return fromBlackIsZero; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromPalette\", function() { return fromPalette; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromCMYK\", function() { return fromCMYK; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromYCbCr\", function() { return fromYCbCr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromCIELab\", function() { return fromCIELab; });\nfunction fromWhiteIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = 256 - (raster[i] / max * 256);\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nfunction fromBlackIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = raster[i] / max * 256;\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nfunction fromPalette(raster, colorMap) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  const greenOffset = colorMap.length / 3;\n  const blueOffset = colorMap.length / 3 * 2;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    const mapIndex = raster[i];\n    rgbRaster[j] = colorMap[mapIndex] / 65536 * 256;\n    rgbRaster[j + 1] = colorMap[mapIndex + greenOffset] / 65536 * 256;\n    rgbRaster[j + 2] = colorMap[mapIndex + blueOffset] / 65536 * 256;\n  }\n  return rgbRaster;\n}\n\nfunction fromCMYK(cmykRaster) {\n  const { width, height } = cmykRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  for (let i = 0, j = 0; i < cmykRaster.length; i += 4, j += 3) {\n    const c = cmykRaster[i];\n    const m = cmykRaster[i + 1];\n    const y = cmykRaster[i + 2];\n    const k = cmykRaster[i + 3];\n\n    rgbRaster[j] = 255 * ((255 - c) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 1] = 255 * ((255 - m) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 2] = 255 * ((255 - y) / 256) * ((255 - k) / 256);\n  }\n  return rgbRaster;\n}\n\nfunction fromYCbCr(yCbCrRaster) {\n  const { width, height } = yCbCrRaster;\n  const rgbRaster = new Uint8ClampedArray(width * height * 3);\n  for (let i = 0, j = 0; i < yCbCrRaster.length; i += 3, j += 3) {\n    const y = yCbCrRaster[i];\n    const cb = yCbCrRaster[i + 1];\n    const cr = yCbCrRaster[i + 2];\n\n    rgbRaster[j] = (y + (1.40200 * (cr - 0x80)));\n    rgbRaster[j + 1] = (y - (0.34414 * (cb - 0x80)) - (0.71414 * (cr - 0x80)));\n    rgbRaster[j + 2] = (y + (1.77200 * (cb - 0x80)));\n  }\n  return rgbRaster;\n}\n\nconst Xn = 0.95047;\nconst Yn = 1.00000;\nconst Zn = 1.08883;\n\n// from https://github.com/antimatter15/rgb-lab/blob/master/color.js\n\nfunction fromCIELab(cieLabRaster) {\n  const { width, height } = cieLabRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n\n  for (let i = 0, j = 0; i < cieLabRaster.length; i += 3, j += 3) {\n    const L = cieLabRaster[i + 0];\n    const a_ = cieLabRaster[i + 1] << 24 >> 24; // conversion from uint8 to int8\n    const b_ = cieLabRaster[i + 2] << 24 >> 24; // same\n\n    let y = (L + 16) / 116;\n    let x = (a_ / 500) + y;\n    let z = y - (b_ / 200);\n    let r;\n    let g;\n    let b;\n\n    x = Xn * ((x * x * x > 0.008856) ? x * x * x : (x - (16 / 116)) / 7.787);\n    y = Yn * ((y * y * y > 0.008856) ? y * y * y : (y - (16 / 116)) / 7.787);\n    z = Zn * ((z * z * z > 0.008856) ? z * z * z : (z - (16 / 116)) / 7.787);\n\n    r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n    g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n    b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n    r = (r > 0.0031308) ? ((1.055 * (r ** (1 / 2.4))) - 0.055) : 12.92 * r;\n    g = (g > 0.0031308) ? ((1.055 * (g ** (1 / 2.4))) - 0.055) : 12.92 * g;\n    b = (b > 0.0031308) ? ((1.055 * (b ** (1 / 2.4))) - 0.055) : 12.92 * b;\n\n    rgbRaster[j] = Math.max(0, Math.min(1, r)) * 255;\n    rgbRaster[j + 1] = Math.max(0, Math.min(1, g)) * 255;\n    rgbRaster[j + 2] = Math.max(0, Math.min(1, b)) * 255;\n  }\n  return rgbRaster;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9yZ2IuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9yZ2IuanM/YWQ1YiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gZnJvbVdoaXRlSXNaZXJvKHJhc3RlciwgbWF4KSB7XG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gcmFzdGVyO1xuICBjb25zdCByZ2JSYXN0ZXIgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDMpO1xuICBsZXQgdmFsdWU7XG4gIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IHJhc3Rlci5sZW5ndGg7ICsraSwgaiArPSAzKSB7XG4gICAgdmFsdWUgPSAyNTYgLSAocmFzdGVyW2ldIC8gbWF4ICogMjU2KTtcbiAgICByZ2JSYXN0ZXJbal0gPSB2YWx1ZTtcbiAgICByZ2JSYXN0ZXJbaiArIDFdID0gdmFsdWU7XG4gICAgcmdiUmFzdGVyW2ogKyAyXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiByZ2JSYXN0ZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQmxhY2tJc1plcm8ocmFzdGVyLCBtYXgpIHtcbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSByYXN0ZXI7XG4gIGNvbnN0IHJnYlJhc3RlciA9IG5ldyBVaW50OEFycmF5KHdpZHRoICogaGVpZ2h0ICogMyk7XG4gIGxldCB2YWx1ZTtcbiAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgcmFzdGVyLmxlbmd0aDsgKytpLCBqICs9IDMpIHtcbiAgICB2YWx1ZSA9IHJhc3RlcltpXSAvIG1heCAqIDI1NjtcbiAgICByZ2JSYXN0ZXJbal0gPSB2YWx1ZTtcbiAgICByZ2JSYXN0ZXJbaiArIDFdID0gdmFsdWU7XG4gICAgcmdiUmFzdGVyW2ogKyAyXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiByZ2JSYXN0ZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUGFsZXR0ZShyYXN0ZXIsIGNvbG9yTWFwKSB7XG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gcmFzdGVyO1xuICBjb25zdCByZ2JSYXN0ZXIgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDMpO1xuICBjb25zdCBncmVlbk9mZnNldCA9IGNvbG9yTWFwLmxlbmd0aCAvIDM7XG4gIGNvbnN0IGJsdWVPZmZzZXQgPSBjb2xvck1hcC5sZW5ndGggLyAzICogMjtcbiAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgcmFzdGVyLmxlbmd0aDsgKytpLCBqICs9IDMpIHtcbiAgICBjb25zdCBtYXBJbmRleCA9IHJhc3RlcltpXTtcbiAgICByZ2JSYXN0ZXJbal0gPSBjb2xvck1hcFttYXBJbmRleF0gLyA2NTUzNiAqIDI1NjtcbiAgICByZ2JSYXN0ZXJbaiArIDFdID0gY29sb3JNYXBbbWFwSW5kZXggKyBncmVlbk9mZnNldF0gLyA2NTUzNiAqIDI1NjtcbiAgICByZ2JSYXN0ZXJbaiArIDJdID0gY29sb3JNYXBbbWFwSW5kZXggKyBibHVlT2Zmc2V0XSAvIDY1NTM2ICogMjU2O1xuICB9XG4gIHJldHVybiByZ2JSYXN0ZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQ01ZSyhjbXlrUmFzdGVyKSB7XG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gY215a1Jhc3RlcjtcbiAgY29uc3QgcmdiUmFzdGVyID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiAzKTtcbiAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgY215a1Jhc3Rlci5sZW5ndGg7IGkgKz0gNCwgaiArPSAzKSB7XG4gICAgY29uc3QgYyA9IGNteWtSYXN0ZXJbaV07XG4gICAgY29uc3QgbSA9IGNteWtSYXN0ZXJbaSArIDFdO1xuICAgIGNvbnN0IHkgPSBjbXlrUmFzdGVyW2kgKyAyXTtcbiAgICBjb25zdCBrID0gY215a1Jhc3RlcltpICsgM107XG5cbiAgICByZ2JSYXN0ZXJbal0gPSAyNTUgKiAoKDI1NSAtIGMpIC8gMjU2KSAqICgoMjU1IC0gaykgLyAyNTYpO1xuICAgIHJnYlJhc3RlcltqICsgMV0gPSAyNTUgKiAoKDI1NSAtIG0pIC8gMjU2KSAqICgoMjU1IC0gaykgLyAyNTYpO1xuICAgIHJnYlJhc3RlcltqICsgMl0gPSAyNTUgKiAoKDI1NSAtIHkpIC8gMjU2KSAqICgoMjU1IC0gaykgLyAyNTYpO1xuICB9XG4gIHJldHVybiByZ2JSYXN0ZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tWUNiQ3IoeUNiQ3JSYXN0ZXIpIHtcbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB5Q2JDclJhc3RlcjtcbiAgY29uc3QgcmdiUmFzdGVyID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHdpZHRoICogaGVpZ2h0ICogMyk7XG4gIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IHlDYkNyUmFzdGVyLmxlbmd0aDsgaSArPSAzLCBqICs9IDMpIHtcbiAgICBjb25zdCB5ID0geUNiQ3JSYXN0ZXJbaV07XG4gICAgY29uc3QgY2IgPSB5Q2JDclJhc3RlcltpICsgMV07XG4gICAgY29uc3QgY3IgPSB5Q2JDclJhc3RlcltpICsgMl07XG5cbiAgICByZ2JSYXN0ZXJbal0gPSAoeSArICgxLjQwMjAwICogKGNyIC0gMHg4MCkpKTtcbiAgICByZ2JSYXN0ZXJbaiArIDFdID0gKHkgLSAoMC4zNDQxNCAqIChjYiAtIDB4ODApKSAtICgwLjcxNDE0ICogKGNyIC0gMHg4MCkpKTtcbiAgICByZ2JSYXN0ZXJbaiArIDJdID0gKHkgKyAoMS43NzIwMCAqIChjYiAtIDB4ODApKSk7XG4gIH1cbiAgcmV0dXJuIHJnYlJhc3Rlcjtcbn1cblxuY29uc3QgWG4gPSAwLjk1MDQ3O1xuY29uc3QgWW4gPSAxLjAwMDAwO1xuY29uc3QgWm4gPSAxLjA4ODgzO1xuXG4vLyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9hbnRpbWF0dGVyMTUvcmdiLWxhYi9ibG9iL21hc3Rlci9jb2xvci5qc1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbUNJRUxhYihjaWVMYWJSYXN0ZXIpIHtcbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBjaWVMYWJSYXN0ZXI7XG4gIGNvbnN0IHJnYlJhc3RlciA9IG5ldyBVaW50OEFycmF5KHdpZHRoICogaGVpZ2h0ICogMyk7XG5cbiAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgY2llTGFiUmFzdGVyLmxlbmd0aDsgaSArPSAzLCBqICs9IDMpIHtcbiAgICBjb25zdCBMID0gY2llTGFiUmFzdGVyW2kgKyAwXTtcbiAgICBjb25zdCBhXyA9IGNpZUxhYlJhc3RlcltpICsgMV0gPDwgMjQgPj4gMjQ7IC8vIGNvbnZlcnNpb24gZnJvbSB1aW50OCB0byBpbnQ4XG4gICAgY29uc3QgYl8gPSBjaWVMYWJSYXN0ZXJbaSArIDJdIDw8IDI0ID4+IDI0OyAvLyBzYW1lXG5cbiAgICBsZXQgeSA9IChMICsgMTYpIC8gMTE2O1xuICAgIGxldCB4ID0gKGFfIC8gNTAwKSArIHk7XG4gICAgbGV0IHogPSB5IC0gKGJfIC8gMjAwKTtcbiAgICBsZXQgcjtcbiAgICBsZXQgZztcbiAgICBsZXQgYjtcblxuICAgIHggPSBYbiAqICgoeCAqIHggKiB4ID4gMC4wMDg4NTYpID8geCAqIHggKiB4IDogKHggLSAoMTYgLyAxMTYpKSAvIDcuNzg3KTtcbiAgICB5ID0gWW4gKiAoKHkgKiB5ICogeSA+IDAuMDA4ODU2KSA/IHkgKiB5ICogeSA6ICh5IC0gKDE2IC8gMTE2KSkgLyA3Ljc4Nyk7XG4gICAgeiA9IFpuICogKCh6ICogeiAqIHogPiAwLjAwODg1NikgPyB6ICogeiAqIHogOiAoeiAtICgxNiAvIDExNikpIC8gNy43ODcpO1xuXG4gICAgciA9ICh4ICogMy4yNDA2KSArICh5ICogLTEuNTM3MikgKyAoeiAqIC0wLjQ5ODYpO1xuICAgIGcgPSAoeCAqIC0wLjk2ODkpICsgKHkgKiAxLjg3NTgpICsgKHogKiAwLjA0MTUpO1xuICAgIGIgPSAoeCAqIDAuMDU1NykgKyAoeSAqIC0wLjIwNDApICsgKHogKiAxLjA1NzApO1xuXG4gICAgciA9IChyID4gMC4wMDMxMzA4KSA/ICgoMS4wNTUgKiAociAqKiAoMSAvIDIuNCkpKSAtIDAuMDU1KSA6IDEyLjkyICogcjtcbiAgICBnID0gKGcgPiAwLjAwMzEzMDgpID8gKCgxLjA1NSAqIChnICoqICgxIC8gMi40KSkpIC0gMC4wNTUpIDogMTIuOTIgKiBnO1xuICAgIGIgPSAoYiA+IDAuMDAzMTMwOCkgPyAoKDEuMDU1ICogKGIgKiogKDEgLyAyLjQpKSkgLSAwLjA1NSkgOiAxMi45MiAqIGI7XG5cbiAgICByZ2JSYXN0ZXJbal0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCByKSkgKiAyNTU7XG4gICAgcmdiUmFzdGVyW2ogKyAxXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIGcpKSAqIDI1NTtcbiAgICByZ2JSYXN0ZXJbaiArIDJdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgYikpICogMjU1O1xuICB9XG4gIHJldHVybiByZ2JSYXN0ZXI7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/rgb.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/arraybuffer.js":
/*!****************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/arraybuffer.js ***!
  \****************************************************************/
/*! exports provided: makeBufferSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"makeBufferSource\", function() { return makeBufferSource; });\n/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basesource.js */ \"./node_modules/geotiff/dist-module/source/basesource.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"./node_modules/geotiff/dist-module/utils.js\");\n\n\n\nclass ArrayBufferSource extends _basesource_js__WEBPACK_IMPORTED_MODULE_0__[\"BaseSource\"] {\n  constructor(arrayBuffer) {\n    super();\n    this.arrayBuffer = arrayBuffer;\n  }\n\n  fetchSlice(slice, signal) {\n    if (signal && signal.aborted) {\n      throw new _utils_js__WEBPACK_IMPORTED_MODULE_1__[\"AbortError\"]('Request aborted');\n    }\n    return this.arrayBuffer.slice(slice.offset, slice.offset + slice.length);\n  }\n}\n\nfunction makeBufferSource(arrayBuffer) {\n  return new ArrayBufferSource(arrayBuffer);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvYXJyYXlidWZmZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvYXJyYXlidWZmZXIuanM/OTNmYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlU291cmNlIH0gZnJvbSAnLi9iYXNlc291cmNlLmpzJztcbmltcG9ydCB7IEFib3J0RXJyb3IgfSBmcm9tICcuLi91dGlscy5qcyc7XG5cbmNsYXNzIEFycmF5QnVmZmVyU291cmNlIGV4dGVuZHMgQmFzZVNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yKGFycmF5QnVmZmVyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmFycmF5QnVmZmVyID0gYXJyYXlCdWZmZXI7XG4gIH1cblxuICBmZXRjaFNsaWNlKHNsaWNlLCBzaWduYWwpIHtcbiAgICBpZiAoc2lnbmFsICYmIHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICB0aHJvdyBuZXcgQWJvcnRFcnJvcignUmVxdWVzdCBhYm9ydGVkJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFycmF5QnVmZmVyLnNsaWNlKHNsaWNlLm9mZnNldCwgc2xpY2Uub2Zmc2V0ICsgc2xpY2UubGVuZ3RoKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZUJ1ZmZlclNvdXJjZShhcnJheUJ1ZmZlcikge1xuICByZXR1cm4gbmV3IEFycmF5QnVmZmVyU291cmNlKGFycmF5QnVmZmVyKTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/source/arraybuffer.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/basesource.js":
/*!***************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/basesource.js ***!
  \***************************************************************/
/*! exports provided: BaseSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BaseSource\", function() { return BaseSource; });\n/**\n * @typedef Slice\n * @property {number} offset\n * @property {number} length\n */\n\nclass BaseSource {\n  /**\n   *\n   * @param {Slice[]} slices\n   * @returns {ArrayBuffer[]}\n   */\n  async fetch(slices, signal = undefined) {\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  /**\n   *\n   * @param {Slice} slice\n   * @returns {ArrayBuffer}\n   */\n  async fetchSlice(slice) {\n    throw new Error(`fetching of slice ${slice} not possible, not implemented`);\n  }\n\n  /**\n   * Returns the filesize if already determined and null otherwise\n   */\n  get fileSize() {\n    return null;\n  }\n\n  async close() {\n    // no-op by default\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvYmFzZXNvdXJjZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9iYXNlc291cmNlLmpzP2IzOWQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAdHlwZWRlZiBTbGljZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IG9mZnNldFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxlbmd0aFxuICovXG5cbmV4cG9ydCBjbGFzcyBCYXNlU291cmNlIHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7U2xpY2VbXX0gc2xpY2VzXG4gICAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcltdfVxuICAgKi9cbiAgYXN5bmMgZmV0Y2goc2xpY2VzLCBzaWduYWwgPSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICBzbGljZXMubWFwKChzbGljZSkgPT4gdGhpcy5mZXRjaFNsaWNlKHNsaWNlLCBzaWduYWwpKSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7U2xpY2V9IHNsaWNlXG4gICAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn1cbiAgICovXG4gIGFzeW5jIGZldGNoU2xpY2Uoc2xpY2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGZldGNoaW5nIG9mIHNsaWNlICR7c2xpY2V9IG5vdCBwb3NzaWJsZSwgbm90IGltcGxlbWVudGVkYCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlsZXNpemUgaWYgYWxyZWFkeSBkZXRlcm1pbmVkIGFuZCBudWxsIG90aGVyd2lzZVxuICAgKi9cbiAgZ2V0IGZpbGVTaXplKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgYXN5bmMgY2xvc2UoKSB7XG4gICAgLy8gbm8tb3AgYnkgZGVmYXVsdFxuICB9XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/source/basesource.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/blockedsource.js":
/*!******************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/blockedsource.js ***!
  \******************************************************************/
/*! exports provided: BlockedSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BlockedSource\", function() { return BlockedSource; });\n/* harmony import */ var quick_lru__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! quick-lru */ \"./node_modules/quick-lru/index.js\");\n/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basesource.js */ \"./node_modules/geotiff/dist-module/source/basesource.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.js */ \"./node_modules/geotiff/dist-module/utils.js\");\n\n\n\n\nclass Block {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {ArrayBuffer} [data]\n   */\n  constructor(offset, length, data = null) {\n    this.offset = offset;\n    this.length = length;\n    this.data = data;\n  }\n\n  /**\n   * @returns {number} the top byte border\n   */\n  get top() {\n    return this.offset + this.length;\n  }\n}\n\nclass BlockGroup {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {number[]} blockIds\n   */\n  constructor(offset, length, blockIds) {\n    this.offset = offset;\n    this.length = length;\n    this.blockIds = blockIds;\n  }\n}\n\nclass BlockedSource extends _basesource_js__WEBPACK_IMPORTED_MODULE_1__[\"BaseSource\"] {\n  /**\n   *\n   * @param {BaseSource} source The underlying source that shall be blocked and cached\n   * @param {object} options\n   * @param {number} [options.blockSize]\n   * @param {number} [options.cacheSize]\n   */\n  constructor(source, { blockSize = 65536, cacheSize = 100 } = {}) {\n    super();\n    this.source = source;\n    this.blockSize = blockSize;\n\n    this.blockCache = new quick_lru__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n      maxSize: cacheSize,\n      onEviction: (blockId, block) => {\n        this.evictedBlocks.set(blockId, block);\n      },\n    });\n\n    /** @type {Map<number, Block>} */\n    this.evictedBlocks = new Map();\n\n    // mapping blockId -> Block instance\n    this.blockRequests = new Map();\n\n    // set of blockIds missing for the current requests\n    this.blockIdsToFetch = new Set();\n\n    this.abortedBlockIds = new Set();\n  }\n\n  get fileSize() {\n    return this.source.fileSize;\n  }\n\n  /**\n   *\n   * @param {import(\"./basesource\").Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    const blockRequests = [];\n    const missingBlockIds = [];\n    const allBlockIds = [];\n    this.evictedBlocks.clear();\n\n    for (const { offset, length } of slices) {\n      let top = offset + length;\n\n      const { fileSize } = this;\n      if (fileSize !== null) {\n        top = Math.min(top, fileSize);\n      }\n\n      const firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize;\n\n      for (let current = firstBlockOffset; current < top; current += this.blockSize) {\n        const blockId = Math.floor(current / this.blockSize);\n        if (!this.blockCache.has(blockId) && !this.blockRequests.has(blockId)) {\n          this.blockIdsToFetch.add(blockId);\n          missingBlockIds.push(blockId);\n        }\n        if (this.blockRequests.has(blockId)) {\n          blockRequests.push(this.blockRequests.get(blockId));\n        }\n        allBlockIds.push(blockId);\n      }\n    }\n\n    // allow additional block requests to accumulate\n    await Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"wait\"])();\n    this.fetchBlocks(signal);\n\n    // Gather all of the new requests that this fetch call is contributing to `fetch`.\n    const missingRequests = [];\n    for (const blockId of missingBlockIds) {\n      // The requested missing block could already be in the cache\n      // instead of having its request still be outstanding.\n      if (this.blockRequests.has(blockId)) {\n        missingRequests.push(this.blockRequests.get(blockId));\n      }\n    }\n\n    // Actually await all pending requests that are needed for this `fetch`.\n    await Promise.allSettled(blockRequests);\n    await Promise.allSettled(missingRequests);\n\n    // Perform retries if a block was interrupted by a previous signal\n    const abortedBlockRequests = [];\n    const abortedBlockIds = allBlockIds\n      .filter((id) => this.abortedBlockIds.has(id) || !this.blockCache.has(id));\n    abortedBlockIds.forEach((id) => this.blockIdsToFetch.add(id));\n    // start the retry of some blocks if required\n    if (abortedBlockIds.length > 0 && signal && !signal.aborted) {\n      this.fetchBlocks(null);\n      for (const blockId of abortedBlockIds) {\n        const block = this.blockRequests.get(blockId);\n        if (!block) {\n          throw new Error(`Block ${blockId} is not in the block requests`);\n        }\n        abortedBlockRequests.push(block);\n      }\n      await Promise.allSettled(abortedBlockRequests);\n    }\n\n    // throw an  abort error\n    if (signal && signal.aborted) {\n      throw new _utils_js__WEBPACK_IMPORTED_MODULE_2__[\"AbortError\"]('Request was aborted');\n    }\n\n    const blocks = allBlockIds.map((id) => this.blockCache.get(id) || this.evictedBlocks.get(id));\n    const failedBlocks = blocks.filter((i) => !i);\n    if (failedBlocks.length) {\n      throw new _utils_js__WEBPACK_IMPORTED_MODULE_2__[\"AggregateError\"](failedBlocks, 'Request failed');\n    }\n\n    // create a final Map, with all required blocks for this request to satisfy\n    const requiredBlocks = new Map(Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__[\"zip\"])(allBlockIds, blocks));\n\n    // TODO: satisfy each slice\n    return this.readSliceData(slices, requiredBlocks);\n  }\n\n  /**\n   *\n   * @param {AbortSignal} signal\n   */\n  fetchBlocks(signal) {\n    // check if we still need to\n    if (this.blockIdsToFetch.size > 0) {\n      const groups = this.groupBlocks(this.blockIdsToFetch);\n\n      // start requesting slices of data\n      const groupRequests = this.source.fetch(groups, signal);\n\n      for (let groupIndex = 0; groupIndex < groups.length; ++groupIndex) {\n        const group = groups[groupIndex];\n\n        for (const blockId of group.blockIds) {\n          // make an async IIFE for each block\n          this.blockRequests.set(blockId, (async () => {\n            try {\n              const response = (await groupRequests)[groupIndex];\n              const blockOffset = blockId * this.blockSize;\n              const o = blockOffset - response.offset;\n              const t = Math.min(o + this.blockSize, response.data.byteLength);\n              const data = response.data.slice(o, t);\n              const block = new Block(\n                blockOffset,\n                data.byteLength,\n                data,\n                blockId,\n              );\n              this.blockCache.set(blockId, block);\n              this.abortedBlockIds.delete(blockId);\n            } catch (err) {\n              if (err.name === 'AbortError') {\n                // store the signal here, we need it to determine later if an\n                // error was caused by this signal\n                err.signal = signal;\n                this.blockCache.delete(blockId);\n                this.abortedBlockIds.add(blockId);\n              } else {\n                throw err;\n              }\n            } finally {\n              this.blockRequests.delete(blockId);\n            }\n          })());\n        }\n      }\n      this.blockIdsToFetch.clear();\n    }\n  }\n\n  /**\n   *\n   * @param {Set} blockIds\n   * @returns {BlockGroup[]}\n   */\n  groupBlocks(blockIds) {\n    const sortedBlockIds = Array.from(blockIds).sort((a, b) => a - b);\n    if (sortedBlockIds.length === 0) {\n      return [];\n    }\n    let current = [];\n    let lastBlockId = null;\n    const groups = [];\n\n    for (const blockId of sortedBlockIds) {\n      if (lastBlockId === null || lastBlockId + 1 === blockId) {\n        current.push(blockId);\n        lastBlockId = blockId;\n      } else {\n        groups.push(new BlockGroup(\n          current[0] * this.blockSize,\n          current.length * this.blockSize,\n          current,\n        ));\n        current = [blockId];\n        lastBlockId = blockId;\n      }\n    }\n\n    groups.push(new BlockGroup(\n      current[0] * this.blockSize,\n      current.length * this.blockSize,\n      current,\n    ));\n\n    return groups;\n  }\n\n  /**\n   *\n   * @param {import(\"./basesource\").Slice[]} slices\n   * @param {Map} blocks\n   */\n  readSliceData(slices, blocks) {\n    return slices.map((slice) => {\n      let top = slice.offset + slice.length;\n      if (this.fileSize !== null) {\n        top = Math.min(this.fileSize, top);\n      }\n      const blockIdLow = Math.floor(slice.offset / this.blockSize);\n      const blockIdHigh = Math.floor(top / this.blockSize);\n      const sliceData = new ArrayBuffer(slice.length);\n      const sliceView = new Uint8Array(sliceData);\n\n      for (let blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {\n        const block = blocks.get(blockId);\n        const delta = block.offset - slice.offset;\n        const topDelta = block.top - top;\n        let blockInnerOffset = 0;\n        let rangeInnerOffset = 0;\n        let usedBlockLength;\n\n        if (delta < 0) {\n          blockInnerOffset = -delta;\n        } else if (delta > 0) {\n          rangeInnerOffset = delta;\n        }\n\n        if (topDelta < 0) {\n          usedBlockLength = block.length - blockInnerOffset;\n        } else {\n          usedBlockLength = top - block.offset - blockInnerOffset;\n        }\n\n        const blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);\n        sliceView.set(blockView, rangeInnerOffset);\n      }\n\n      return sliceData;\n    });\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvYmxvY2tlZHNvdXJjZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9ibG9ja2Vkc291cmNlLmpzPzFlNzYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFF1aWNrTFJVIGZyb20gJ3F1aWNrLWxydSc7XG5pbXBvcnQgeyBCYXNlU291cmNlIH0gZnJvbSAnLi9iYXNlc291cmNlLmpzJztcbmltcG9ydCB7IEFib3J0RXJyb3IsIEFnZ3JlZ2F0ZUVycm9yLCB3YWl0LCB6aXAgfSBmcm9tICcuLi91dGlscy5qcyc7XG5cbmNsYXNzIEJsb2NrIHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBbZGF0YV1cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9mZnNldCwgbGVuZ3RoLCBkYXRhID0gbnVsbCkge1xuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge251bWJlcn0gdGhlIHRvcCBieXRlIGJvcmRlclxuICAgKi9cbiAgZ2V0IHRvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5vZmZzZXQgKyB0aGlzLmxlbmd0aDtcbiAgfVxufVxuXG5jbGFzcyBCbG9ja0dyb3VwIHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICAgKiBAcGFyYW0ge251bWJlcltdfSBibG9ja0lkc1xuICAgKi9cbiAgY29uc3RydWN0b3Iob2Zmc2V0LCBsZW5ndGgsIGJsb2NrSWRzKSB7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgdGhpcy5ibG9ja0lkcyA9IGJsb2NrSWRzO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBCbG9ja2VkU291cmNlIGV4dGVuZHMgQmFzZVNvdXJjZSB7XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0Jhc2VTb3VyY2V9IHNvdXJjZSBUaGUgdW5kZXJseWluZyBzb3VyY2UgdGhhdCBzaGFsbCBiZSBibG9ja2VkIGFuZCBjYWNoZWRcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmJsb2NrU2l6ZV1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNhY2hlU2l6ZV1cbiAgICovXG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgeyBibG9ja1NpemUgPSA2NTUzNiwgY2FjaGVTaXplID0gMTAwIH0gPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5ibG9ja1NpemUgPSBibG9ja1NpemU7XG5cbiAgICB0aGlzLmJsb2NrQ2FjaGUgPSBuZXcgUXVpY2tMUlUoe1xuICAgICAgbWF4U2l6ZTogY2FjaGVTaXplLFxuICAgICAgb25FdmljdGlvbjogKGJsb2NrSWQsIGJsb2NrKSA9PiB7XG4gICAgICAgIHRoaXMuZXZpY3RlZEJsb2Nrcy5zZXQoYmxvY2tJZCwgYmxvY2spO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIC8qKiBAdHlwZSB7TWFwPG51bWJlciwgQmxvY2s+fSAqL1xuICAgIHRoaXMuZXZpY3RlZEJsb2NrcyA9IG5ldyBNYXAoKTtcblxuICAgIC8vIG1hcHBpbmcgYmxvY2tJZCAtPiBCbG9jayBpbnN0YW5jZVxuICAgIHRoaXMuYmxvY2tSZXF1ZXN0cyA9IG5ldyBNYXAoKTtcblxuICAgIC8vIHNldCBvZiBibG9ja0lkcyBtaXNzaW5nIGZvciB0aGUgY3VycmVudCByZXF1ZXN0c1xuICAgIHRoaXMuYmxvY2tJZHNUb0ZldGNoID0gbmV3IFNldCgpO1xuXG4gICAgdGhpcy5hYm9ydGVkQmxvY2tJZHMgPSBuZXcgU2V0KCk7XG4gIH1cblxuICBnZXQgZmlsZVNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlLmZpbGVTaXplO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9iYXNlc291cmNlXCIpLlNsaWNlW119IHNsaWNlc1xuICAgKi9cbiAgYXN5bmMgZmV0Y2goc2xpY2VzLCBzaWduYWwpIHtcbiAgICBjb25zdCBibG9ja1JlcXVlc3RzID0gW107XG4gICAgY29uc3QgbWlzc2luZ0Jsb2NrSWRzID0gW107XG4gICAgY29uc3QgYWxsQmxvY2tJZHMgPSBbXTtcbiAgICB0aGlzLmV2aWN0ZWRCbG9ja3MuY2xlYXIoKTtcblxuICAgIGZvciAoY29uc3QgeyBvZmZzZXQsIGxlbmd0aCB9IG9mIHNsaWNlcykge1xuICAgICAgbGV0IHRvcCA9IG9mZnNldCArIGxlbmd0aDtcblxuICAgICAgY29uc3QgeyBmaWxlU2l6ZSB9ID0gdGhpcztcbiAgICAgIGlmIChmaWxlU2l6ZSAhPT0gbnVsbCkge1xuICAgICAgICB0b3AgPSBNYXRoLm1pbih0b3AsIGZpbGVTaXplKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZmlyc3RCbG9ja09mZnNldCA9IE1hdGguZmxvb3Iob2Zmc2V0IC8gdGhpcy5ibG9ja1NpemUpICogdGhpcy5ibG9ja1NpemU7XG5cbiAgICAgIGZvciAobGV0IGN1cnJlbnQgPSBmaXJzdEJsb2NrT2Zmc2V0OyBjdXJyZW50IDwgdG9wOyBjdXJyZW50ICs9IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrSWQgPSBNYXRoLmZsb29yKGN1cnJlbnQgLyB0aGlzLmJsb2NrU2l6ZSk7XG4gICAgICAgIGlmICghdGhpcy5ibG9ja0NhY2hlLmhhcyhibG9ja0lkKSAmJiAhdGhpcy5ibG9ja1JlcXVlc3RzLmhhcyhibG9ja0lkKSkge1xuICAgICAgICAgIHRoaXMuYmxvY2tJZHNUb0ZldGNoLmFkZChibG9ja0lkKTtcbiAgICAgICAgICBtaXNzaW5nQmxvY2tJZHMucHVzaChibG9ja0lkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ibG9ja1JlcXVlc3RzLmhhcyhibG9ja0lkKSkge1xuICAgICAgICAgIGJsb2NrUmVxdWVzdHMucHVzaCh0aGlzLmJsb2NrUmVxdWVzdHMuZ2V0KGJsb2NrSWQpKTtcbiAgICAgICAgfVxuICAgICAgICBhbGxCbG9ja0lkcy5wdXNoKGJsb2NrSWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFsbG93IGFkZGl0aW9uYWwgYmxvY2sgcmVxdWVzdHMgdG8gYWNjdW11bGF0ZVxuICAgIGF3YWl0IHdhaXQoKTtcbiAgICB0aGlzLmZldGNoQmxvY2tzKHNpZ25hbCk7XG5cbiAgICAvLyBHYXRoZXIgYWxsIG9mIHRoZSBuZXcgcmVxdWVzdHMgdGhhdCB0aGlzIGZldGNoIGNhbGwgaXMgY29udHJpYnV0aW5nIHRvIGBmZXRjaGAuXG4gICAgY29uc3QgbWlzc2luZ1JlcXVlc3RzID0gW107XG4gICAgZm9yIChjb25zdCBibG9ja0lkIG9mIG1pc3NpbmdCbG9ja0lkcykge1xuICAgICAgLy8gVGhlIHJlcXVlc3RlZCBtaXNzaW5nIGJsb2NrIGNvdWxkIGFscmVhZHkgYmUgaW4gdGhlIGNhY2hlXG4gICAgICAvLyBpbnN0ZWFkIG9mIGhhdmluZyBpdHMgcmVxdWVzdCBzdGlsbCBiZSBvdXRzdGFuZGluZy5cbiAgICAgIGlmICh0aGlzLmJsb2NrUmVxdWVzdHMuaGFzKGJsb2NrSWQpKSB7XG4gICAgICAgIG1pc3NpbmdSZXF1ZXN0cy5wdXNoKHRoaXMuYmxvY2tSZXF1ZXN0cy5nZXQoYmxvY2tJZCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFjdHVhbGx5IGF3YWl0IGFsbCBwZW5kaW5nIHJlcXVlc3RzIHRoYXQgYXJlIG5lZWRlZCBmb3IgdGhpcyBgZmV0Y2hgLlxuICAgIGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChibG9ja1JlcXVlc3RzKTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQobWlzc2luZ1JlcXVlc3RzKTtcblxuICAgIC8vIFBlcmZvcm0gcmV0cmllcyBpZiBhIGJsb2NrIHdhcyBpbnRlcnJ1cHRlZCBieSBhIHByZXZpb3VzIHNpZ25hbFxuICAgIGNvbnN0IGFib3J0ZWRCbG9ja1JlcXVlc3RzID0gW107XG4gICAgY29uc3QgYWJvcnRlZEJsb2NrSWRzID0gYWxsQmxvY2tJZHNcbiAgICAgIC5maWx0ZXIoKGlkKSA9PiB0aGlzLmFib3J0ZWRCbG9ja0lkcy5oYXMoaWQpIHx8ICF0aGlzLmJsb2NrQ2FjaGUuaGFzKGlkKSk7XG4gICAgYWJvcnRlZEJsb2NrSWRzLmZvckVhY2goKGlkKSA9PiB0aGlzLmJsb2NrSWRzVG9GZXRjaC5hZGQoaWQpKTtcbiAgICAvLyBzdGFydCB0aGUgcmV0cnkgb2Ygc29tZSBibG9ja3MgaWYgcmVxdWlyZWRcbiAgICBpZiAoYWJvcnRlZEJsb2NrSWRzLmxlbmd0aCA+IDAgJiYgc2lnbmFsICYmICFzaWduYWwuYWJvcnRlZCkge1xuICAgICAgdGhpcy5mZXRjaEJsb2NrcyhudWxsKTtcbiAgICAgIGZvciAoY29uc3QgYmxvY2tJZCBvZiBhYm9ydGVkQmxvY2tJZHMpIHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSB0aGlzLmJsb2NrUmVxdWVzdHMuZ2V0KGJsb2NrSWQpO1xuICAgICAgICBpZiAoIWJsb2NrKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCbG9jayAke2Jsb2NrSWR9IGlzIG5vdCBpbiB0aGUgYmxvY2sgcmVxdWVzdHNgKTtcbiAgICAgICAgfVxuICAgICAgICBhYm9ydGVkQmxvY2tSZXF1ZXN0cy5wdXNoKGJsb2NrKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChhYm9ydGVkQmxvY2tSZXF1ZXN0cyk7XG4gICAgfVxuXG4gICAgLy8gdGhyb3cgYW4gIGFib3J0IGVycm9yXG4gICAgaWYgKHNpZ25hbCAmJiBzaWduYWwuYWJvcnRlZCkge1xuICAgICAgdGhyb3cgbmV3IEFib3J0RXJyb3IoJ1JlcXVlc3Qgd2FzIGFib3J0ZWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBibG9ja3MgPSBhbGxCbG9ja0lkcy5tYXAoKGlkKSA9PiB0aGlzLmJsb2NrQ2FjaGUuZ2V0KGlkKSB8fCB0aGlzLmV2aWN0ZWRCbG9ja3MuZ2V0KGlkKSk7XG4gICAgY29uc3QgZmFpbGVkQmxvY2tzID0gYmxvY2tzLmZpbHRlcigoaSkgPT4gIWkpO1xuICAgIGlmIChmYWlsZWRCbG9ja3MubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgQWdncmVnYXRlRXJyb3IoZmFpbGVkQmxvY2tzLCAnUmVxdWVzdCBmYWlsZWQnKTtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgYSBmaW5hbCBNYXAsIHdpdGggYWxsIHJlcXVpcmVkIGJsb2NrcyBmb3IgdGhpcyByZXF1ZXN0IHRvIHNhdGlzZnlcbiAgICBjb25zdCByZXF1aXJlZEJsb2NrcyA9IG5ldyBNYXAoemlwKGFsbEJsb2NrSWRzLCBibG9ja3MpKTtcblxuICAgIC8vIFRPRE86IHNhdGlzZnkgZWFjaCBzbGljZVxuICAgIHJldHVybiB0aGlzLnJlYWRTbGljZURhdGEoc2xpY2VzLCByZXF1aXJlZEJsb2Nrcyk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gc2lnbmFsXG4gICAqL1xuICBmZXRjaEJsb2NrcyhzaWduYWwpIHtcbiAgICAvLyBjaGVjayBpZiB3ZSBzdGlsbCBuZWVkIHRvXG4gICAgaWYgKHRoaXMuYmxvY2tJZHNUb0ZldGNoLnNpemUgPiAwKSB7XG4gICAgICBjb25zdCBncm91cHMgPSB0aGlzLmdyb3VwQmxvY2tzKHRoaXMuYmxvY2tJZHNUb0ZldGNoKTtcblxuICAgICAgLy8gc3RhcnQgcmVxdWVzdGluZyBzbGljZXMgb2YgZGF0YVxuICAgICAgY29uc3QgZ3JvdXBSZXF1ZXN0cyA9IHRoaXMuc291cmNlLmZldGNoKGdyb3Vwcywgc2lnbmFsKTtcblxuICAgICAgZm9yIChsZXQgZ3JvdXBJbmRleCA9IDA7IGdyb3VwSW5kZXggPCBncm91cHMubGVuZ3RoOyArK2dyb3VwSW5kZXgpIHtcbiAgICAgICAgY29uc3QgZ3JvdXAgPSBncm91cHNbZ3JvdXBJbmRleF07XG5cbiAgICAgICAgZm9yIChjb25zdCBibG9ja0lkIG9mIGdyb3VwLmJsb2NrSWRzKSB7XG4gICAgICAgICAgLy8gbWFrZSBhbiBhc3luYyBJSUZFIGZvciBlYWNoIGJsb2NrXG4gICAgICAgICAgdGhpcy5ibG9ja1JlcXVlc3RzLnNldChibG9ja0lkLCAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSAoYXdhaXQgZ3JvdXBSZXF1ZXN0cylbZ3JvdXBJbmRleF07XG4gICAgICAgICAgICAgIGNvbnN0IGJsb2NrT2Zmc2V0ID0gYmxvY2tJZCAqIHRoaXMuYmxvY2tTaXplO1xuICAgICAgICAgICAgICBjb25zdCBvID0gYmxvY2tPZmZzZXQgLSByZXNwb25zZS5vZmZzZXQ7XG4gICAgICAgICAgICAgIGNvbnN0IHQgPSBNYXRoLm1pbihvICsgdGhpcy5ibG9ja1NpemUsIHJlc3BvbnNlLmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSByZXNwb25zZS5kYXRhLnNsaWNlKG8sIHQpO1xuICAgICAgICAgICAgICBjb25zdCBibG9jayA9IG5ldyBCbG9jayhcbiAgICAgICAgICAgICAgICBibG9ja09mZnNldCxcbiAgICAgICAgICAgICAgICBkYXRhLmJ5dGVMZW5ndGgsXG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICBibG9ja0lkLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB0aGlzLmJsb2NrQ2FjaGUuc2V0KGJsb2NrSWQsIGJsb2NrKTtcbiAgICAgICAgICAgICAgdGhpcy5hYm9ydGVkQmxvY2tJZHMuZGVsZXRlKGJsb2NrSWQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIGlmIChlcnIubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RvcmUgdGhlIHNpZ25hbCBoZXJlLCB3ZSBuZWVkIGl0IHRvIGRldGVybWluZSBsYXRlciBpZiBhblxuICAgICAgICAgICAgICAgIC8vIGVycm9yIHdhcyBjYXVzZWQgYnkgdGhpcyBzaWduYWxcbiAgICAgICAgICAgICAgICBlcnIuc2lnbmFsID0gc2lnbmFsO1xuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tDYWNoZS5kZWxldGUoYmxvY2tJZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hYm9ydGVkQmxvY2tJZHMuYWRkKGJsb2NrSWQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgdGhpcy5ibG9ja1JlcXVlc3RzLmRlbGV0ZShibG9ja0lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5ibG9ja0lkc1RvRmV0Y2guY2xlYXIoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtTZXR9IGJsb2NrSWRzXG4gICAqIEByZXR1cm5zIHtCbG9ja0dyb3VwW119XG4gICAqL1xuICBncm91cEJsb2NrcyhibG9ja0lkcykge1xuICAgIGNvbnN0IHNvcnRlZEJsb2NrSWRzID0gQXJyYXkuZnJvbShibG9ja0lkcykuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgIGlmIChzb3J0ZWRCbG9ja0lkcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnQgPSBbXTtcbiAgICBsZXQgbGFzdEJsb2NrSWQgPSBudWxsO1xuICAgIGNvbnN0IGdyb3VwcyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBibG9ja0lkIG9mIHNvcnRlZEJsb2NrSWRzKSB7XG4gICAgICBpZiAobGFzdEJsb2NrSWQgPT09IG51bGwgfHwgbGFzdEJsb2NrSWQgKyAxID09PSBibG9ja0lkKSB7XG4gICAgICAgIGN1cnJlbnQucHVzaChibG9ja0lkKTtcbiAgICAgICAgbGFzdEJsb2NrSWQgPSBibG9ja0lkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JvdXBzLnB1c2gobmV3IEJsb2NrR3JvdXAoXG4gICAgICAgICAgY3VycmVudFswXSAqIHRoaXMuYmxvY2tTaXplLFxuICAgICAgICAgIGN1cnJlbnQubGVuZ3RoICogdGhpcy5ibG9ja1NpemUsXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgKSk7XG4gICAgICAgIGN1cnJlbnQgPSBbYmxvY2tJZF07XG4gICAgICAgIGxhc3RCbG9ja0lkID0gYmxvY2tJZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBncm91cHMucHVzaChuZXcgQmxvY2tHcm91cChcbiAgICAgIGN1cnJlbnRbMF0gKiB0aGlzLmJsb2NrU2l6ZSxcbiAgICAgIGN1cnJlbnQubGVuZ3RoICogdGhpcy5ibG9ja1NpemUsXG4gICAgICBjdXJyZW50LFxuICAgICkpO1xuXG4gICAgcmV0dXJuIGdyb3VwcztcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vYmFzZXNvdXJjZVwiKS5TbGljZVtdfSBzbGljZXNcbiAgICogQHBhcmFtIHtNYXB9IGJsb2Nrc1xuICAgKi9cbiAgcmVhZFNsaWNlRGF0YShzbGljZXMsIGJsb2Nrcykge1xuICAgIHJldHVybiBzbGljZXMubWFwKChzbGljZSkgPT4ge1xuICAgICAgbGV0IHRvcCA9IHNsaWNlLm9mZnNldCArIHNsaWNlLmxlbmd0aDtcbiAgICAgIGlmICh0aGlzLmZpbGVTaXplICE9PSBudWxsKSB7XG4gICAgICAgIHRvcCA9IE1hdGgubWluKHRoaXMuZmlsZVNpemUsIHRvcCk7XG4gICAgICB9XG4gICAgICBjb25zdCBibG9ja0lkTG93ID0gTWF0aC5mbG9vcihzbGljZS5vZmZzZXQgLyB0aGlzLmJsb2NrU2l6ZSk7XG4gICAgICBjb25zdCBibG9ja0lkSGlnaCA9IE1hdGguZmxvb3IodG9wIC8gdGhpcy5ibG9ja1NpemUpO1xuICAgICAgY29uc3Qgc2xpY2VEYXRhID0gbmV3IEFycmF5QnVmZmVyKHNsaWNlLmxlbmd0aCk7XG4gICAgICBjb25zdCBzbGljZVZpZXcgPSBuZXcgVWludDhBcnJheShzbGljZURhdGEpO1xuXG4gICAgICBmb3IgKGxldCBibG9ja0lkID0gYmxvY2tJZExvdzsgYmxvY2tJZCA8PSBibG9ja0lkSGlnaDsgKytibG9ja0lkKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gYmxvY2tzLmdldChibG9ja0lkKTtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBibG9jay5vZmZzZXQgLSBzbGljZS5vZmZzZXQ7XG4gICAgICAgIGNvbnN0IHRvcERlbHRhID0gYmxvY2sudG9wIC0gdG9wO1xuICAgICAgICBsZXQgYmxvY2tJbm5lck9mZnNldCA9IDA7XG4gICAgICAgIGxldCByYW5nZUlubmVyT2Zmc2V0ID0gMDtcbiAgICAgICAgbGV0IHVzZWRCbG9ja0xlbmd0aDtcblxuICAgICAgICBpZiAoZGVsdGEgPCAwKSB7XG4gICAgICAgICAgYmxvY2tJbm5lck9mZnNldCA9IC1kZWx0YTtcbiAgICAgICAgfSBlbHNlIGlmIChkZWx0YSA+IDApIHtcbiAgICAgICAgICByYW5nZUlubmVyT2Zmc2V0ID0gZGVsdGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9wRGVsdGEgPCAwKSB7XG4gICAgICAgICAgdXNlZEJsb2NrTGVuZ3RoID0gYmxvY2subGVuZ3RoIC0gYmxvY2tJbm5lck9mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1c2VkQmxvY2tMZW5ndGggPSB0b3AgLSBibG9jay5vZmZzZXQgLSBibG9ja0lubmVyT2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYmxvY2tWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2suZGF0YSwgYmxvY2tJbm5lck9mZnNldCwgdXNlZEJsb2NrTGVuZ3RoKTtcbiAgICAgICAgc2xpY2VWaWV3LnNldChibG9ja1ZpZXcsIHJhbmdlSW5uZXJPZmZzZXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2xpY2VEYXRhO1xuICAgIH0pO1xuICB9XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/source/blockedsource.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/client/base.js":
/*!****************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/client/base.js ***!
  \****************************************************************/
/*! exports provided: BaseResponse, BaseClient */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BaseResponse\", function() { return BaseResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BaseClient\", function() { return BaseClient; });\nclass BaseResponse {\n  /**\n   * Returns whether the response has an ok'ish status code\n   */\n  get ok() {\n    return this.status >= 200 && this.status <= 299;\n  }\n\n  /**\n   * Returns the status code of the response\n   */\n  get status() {\n    throw new Error('not implemented');\n  }\n\n  /**\n   * Returns the value of the specified header\n   * @param {string} headerName the header name\n   * @returns {string} the header value\n   */\n  getHeader(headerName) { // eslint-disable-line no-unused-vars\n    throw new Error('not implemented');\n  }\n\n  /**\n   * @returns {ArrayBuffer} the response data of the request\n   */\n  async getData() {\n    throw new Error('not implemented');\n  }\n}\n\nclass BaseClient {\n  constructor(url) {\n    this.url = url;\n  }\n\n  /**\n   * Send a request with the options\n   * @param {{headers: HeadersInit, signal: AbortSignal}} [options={}]\n   * @returns {Promise<BaseResponse>}\n   */\n  async request({ headers, signal } = {}) { // eslint-disable-line no-unused-vars\n    throw new Error('request is not implemented');\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvY2xpZW50L2Jhc2UuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvY2xpZW50L2Jhc2UuanM/MzAwNSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY2xhc3MgQmFzZVJlc3BvbnNlIHtcbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgcmVzcG9uc2UgaGFzIGFuIG9rJ2lzaCBzdGF0dXMgY29kZVxuICAgKi9cbiAgZ2V0IG9rKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXR1cyA+PSAyMDAgJiYgdGhpcy5zdGF0dXMgPD0gMjk5O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0YXR1cyBjb2RlIG9mIHRoZSByZXNwb25zZVxuICAgKi9cbiAgZ2V0IHN0YXR1cygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBzcGVjaWZpZWQgaGVhZGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBoZWFkZXJOYW1lIHRoZSBoZWFkZXIgbmFtZVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgaGVhZGVyIHZhbHVlXG4gICAqL1xuICBnZXRIZWFkZXIoaGVhZGVyTmFtZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IHRoZSByZXNwb25zZSBkYXRhIG9mIHRoZSByZXF1ZXN0XG4gICAqL1xuICBhc3luYyBnZXREYXRhKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEJhc2VDbGllbnQge1xuICBjb25zdHJ1Y3Rvcih1cmwpIHtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgcmVxdWVzdCB3aXRoIHRoZSBvcHRpb25zXG4gICAqIEBwYXJhbSB7e2hlYWRlcnM6IEhlYWRlcnNJbml0LCBzaWduYWw6IEFib3J0U2lnbmFsfX0gW29wdGlvbnM9e31dXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEJhc2VSZXNwb25zZT59XG4gICAqL1xuICBhc3luYyByZXF1ZXN0KHsgaGVhZGVycywgc2lnbmFsIH0gPSB7fSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1ZXN0IGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/source/client/base.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/client/fetch.js":
/*!*****************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/client/fetch.js ***!
  \*****************************************************************/
/*! exports provided: FetchClient */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FetchClient\", function() { return FetchClient; });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"./node_modules/geotiff/dist-module/source/client/base.js\");\n\n\nclass FetchResponse extends _base_js__WEBPACK_IMPORTED_MODULE_0__[\"BaseResponse\"] {\n  /**\n   * BaseResponse facade for fetch API Response\n   * @param {Response} response\n   */\n  constructor(response) {\n    super();\n    this.response = response;\n  }\n\n  get status() {\n    return this.response.status;\n  }\n\n  getHeader(name) {\n    return this.response.headers.get(name);\n  }\n\n  async getData() {\n    const data = this.response.arrayBuffer\n      ? await this.response.arrayBuffer()\n      : (await this.response.buffer()).buffer;\n    return data;\n  }\n}\n\nclass FetchClient extends _base_js__WEBPACK_IMPORTED_MODULE_0__[\"BaseClient\"] {\n  constructor(url, credentials) {\n    super(url);\n    this.credentials = credentials;\n  }\n\n  /**\n   * @param {{headers: HeadersInit, signal: AbortSignal}} [options={}]\n   * @returns {Promise<FetchResponse>}\n   */\n  async request({ headers, signal } = {}) {\n    const response = await fetch(this.url, {\n      headers, credentials: this.credentials, signal,\n    });\n    return new FetchResponse(response);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvY2xpZW50L2ZldGNoLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvc291cmNlL2NsaWVudC9mZXRjaC5qcz8yOTVhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VDbGllbnQsIEJhc2VSZXNwb25zZSB9IGZyb20gJy4vYmFzZS5qcyc7XG5cbmNsYXNzIEZldGNoUmVzcG9uc2UgZXh0ZW5kcyBCYXNlUmVzcG9uc2Uge1xuICAvKipcbiAgICogQmFzZVJlc3BvbnNlIGZhY2FkZSBmb3IgZmV0Y2ggQVBJIFJlc3BvbnNlXG4gICAqIEBwYXJhbSB7UmVzcG9uc2V9IHJlc3BvbnNlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZXNwb25zZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICB9XG5cbiAgZ2V0IHN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNwb25zZS5zdGF0dXM7XG4gIH1cblxuICBnZXRIZWFkZXIobmFtZSkge1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlLmhlYWRlcnMuZ2V0KG5hbWUpO1xuICB9XG5cbiAgYXN5bmMgZ2V0RGF0YSgpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXNwb25zZS5hcnJheUJ1ZmZlclxuICAgICAgPyBhd2FpdCB0aGlzLnJlc3BvbnNlLmFycmF5QnVmZmVyKClcbiAgICAgIDogKGF3YWl0IHRoaXMucmVzcG9uc2UuYnVmZmVyKCkpLmJ1ZmZlcjtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRmV0Y2hDbGllbnQgZXh0ZW5kcyBCYXNlQ2xpZW50IHtcbiAgY29uc3RydWN0b3IodXJsLCBjcmVkZW50aWFscykge1xuICAgIHN1cGVyKHVybCk7XG4gICAgdGhpcy5jcmVkZW50aWFscyA9IGNyZWRlbnRpYWxzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7e2hlYWRlcnM6IEhlYWRlcnNJbml0LCBzaWduYWw6IEFib3J0U2lnbmFsfX0gW29wdGlvbnM9e31dXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEZldGNoUmVzcG9uc2U+fVxuICAgKi9cbiAgYXN5bmMgcmVxdWVzdCh7IGhlYWRlcnMsIHNpZ25hbCB9ID0ge30pIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHRoaXMudXJsLCB7XG4gICAgICBoZWFkZXJzLCBjcmVkZW50aWFsczogdGhpcy5jcmVkZW50aWFscywgc2lnbmFsLFxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgRmV0Y2hSZXNwb25zZShyZXNwb25zZSk7XG4gIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/source/client/fetch.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/client/http.js":
/*!****************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/client/http.js ***!
  \****************************************************************/
/*! exports provided: HttpClient */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HttpClient\", function() { return HttpClient; });\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! http */ 11);\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(http__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! https */ 12);\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(https__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! url */ 13);\n/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(url__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base.js */ \"./node_modules/geotiff/dist-module/source/client/base.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils.js */ \"./node_modules/geotiff/dist-module/utils.js\");\n\n\n\n\n\n\n\nclass HttpResponse extends _base_js__WEBPACK_IMPORTED_MODULE_3__[\"BaseResponse\"] {\n  /**\n   * BaseResponse facade for node HTTP/HTTPS API Response\n   * @param {http.ServerResponse} response\n   */\n  constructor(response, dataPromise) {\n    super();\n    this.response = response;\n    this.dataPromise = dataPromise;\n  }\n\n  get status() {\n    return this.response.statusCode;\n  }\n\n  getHeader(name) {\n    return this.response.headers[name];\n  }\n\n  async getData() {\n    const data = await this.dataPromise;\n    return data;\n  }\n}\n\nclass HttpClient extends _base_js__WEBPACK_IMPORTED_MODULE_3__[\"BaseClient\"] {\n  constructor(url) {\n    super(url);\n    this.parsedUrl = url__WEBPACK_IMPORTED_MODULE_2___default.a.parse(this.url);\n    this.httpApi = (this.parsedUrl.protocol === 'http:' ? http__WEBPACK_IMPORTED_MODULE_0___default.a : https__WEBPACK_IMPORTED_MODULE_1___default.a);\n  }\n\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const request = this.httpApi.get(\n        {\n          ...this.parsedUrl,\n          headers,\n        },\n        (response) => {\n          const dataPromise = new Promise((resolveData) => {\n            const chunks = [];\n\n            // collect chunks\n            response.on('data', (chunk) => {\n              chunks.push(chunk);\n            });\n\n            // concatenate all chunks and resolve the promise with the resulting buffer\n            response.on('end', () => {\n              const data = Buffer.concat(chunks).buffer;\n              resolveData(data);\n            });\n            response.on('error', reject);\n          });\n          resolve(new HttpResponse(response, dataPromise));\n        },\n      );\n      request.on('error', reject);\n\n      if (signal) {\n        if (signal.aborted) {\n          request.destroy(new _utils_js__WEBPACK_IMPORTED_MODULE_4__[\"AbortError\"]('Request aborted'));\n        }\n        signal.addEventListener('abort', () => request.destroy(new _utils_js__WEBPACK_IMPORTED_MODULE_4__[\"AbortError\"]('Request aborted')));\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvY2xpZW50L2h0dHAuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvY2xpZW50L2h0dHAuanM/Njk4YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgaHR0cCBmcm9tICdodHRwJztcbmltcG9ydCBodHRwcyBmcm9tICdodHRwcyc7XG5pbXBvcnQgdXJsTW9kIGZyb20gJ3VybCc7XG5cbmltcG9ydCB7IEJhc2VDbGllbnQsIEJhc2VSZXNwb25zZSB9IGZyb20gJy4vYmFzZS5qcyc7XG5pbXBvcnQgeyBBYm9ydEVycm9yIH0gZnJvbSAnLi4vLi4vdXRpbHMuanMnO1xuXG5jbGFzcyBIdHRwUmVzcG9uc2UgZXh0ZW5kcyBCYXNlUmVzcG9uc2Uge1xuICAvKipcbiAgICogQmFzZVJlc3BvbnNlIGZhY2FkZSBmb3Igbm9kZSBIVFRQL0hUVFBTIEFQSSBSZXNwb25zZVxuICAgKiBAcGFyYW0ge2h0dHAuU2VydmVyUmVzcG9uc2V9IHJlc3BvbnNlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZXNwb25zZSwgZGF0YVByb21pc2UpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICB0aGlzLmRhdGFQcm9taXNlID0gZGF0YVByb21pc2U7XG4gIH1cblxuICBnZXQgc3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gIH1cblxuICBnZXRIZWFkZXIobmFtZSkge1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlLmhlYWRlcnNbbmFtZV07XG4gIH1cblxuICBhc3luYyBnZXREYXRhKCkge1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmRhdGFQcm9taXNlO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBIdHRwQ2xpZW50IGV4dGVuZHMgQmFzZUNsaWVudCB7XG4gIGNvbnN0cnVjdG9yKHVybCkge1xuICAgIHN1cGVyKHVybCk7XG4gICAgdGhpcy5wYXJzZWRVcmwgPSB1cmxNb2QucGFyc2UodGhpcy51cmwpO1xuICAgIHRoaXMuaHR0cEFwaSA9ICh0aGlzLnBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHA6JyA/IGh0dHAgOiBodHRwcyk7XG4gIH1cblxuICBjb25zdHJ1Y3RSZXF1ZXN0KGhlYWRlcnMsIHNpZ25hbCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5odHRwQXBpLmdldChcbiAgICAgICAge1xuICAgICAgICAgIC4uLnRoaXMucGFyc2VkVXJsLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgIH0sXG4gICAgICAgIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRhdGFQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmVEYXRhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaHVua3MgPSBbXTtcblxuICAgICAgICAgICAgLy8gY29sbGVjdCBjaHVua3NcbiAgICAgICAgICAgIHJlc3BvbnNlLm9uKCdkYXRhJywgKGNodW5rKSA9PiB7XG4gICAgICAgICAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBjb25jYXRlbmF0ZSBhbGwgY2h1bmtzIGFuZCByZXNvbHZlIHRoZSBwcm9taXNlIHdpdGggdGhlIHJlc3VsdGluZyBidWZmZXJcbiAgICAgICAgICAgIHJlc3BvbnNlLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBCdWZmZXIuY29uY2F0KGNodW5rcykuYnVmZmVyO1xuICAgICAgICAgICAgICByZXNvbHZlRGF0YShkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzcG9uc2Uub24oJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXNvbHZlKG5ldyBIdHRwUmVzcG9uc2UocmVzcG9uc2UsIGRhdGFQcm9taXNlKSk7XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgICAgcmVxdWVzdC5vbignZXJyb3InLCByZWplY3QpO1xuXG4gICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgIHJlcXVlc3QuZGVzdHJveShuZXcgQWJvcnRFcnJvcignUmVxdWVzdCBhYm9ydGVkJykpO1xuICAgICAgICB9XG4gICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHJlcXVlc3QuZGVzdHJveShuZXcgQWJvcnRFcnJvcignUmVxdWVzdCBhYm9ydGVkJykpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIHJlcXVlc3QoeyBoZWFkZXJzLCBzaWduYWwgfSA9IHt9KSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNvbnN0cnVjdFJlcXVlc3QoaGVhZGVycywgc2lnbmFsKTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/source/client/http.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/client/xhr.js":
/*!***************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/client/xhr.js ***!
  \***************************************************************/
/*! exports provided: XHRClient */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"XHRClient\", function() { return XHRClient; });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"./node_modules/geotiff/dist-module/source/client/base.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils.js */ \"./node_modules/geotiff/dist-module/utils.js\");\n\n\n\nclass XHRResponse extends _base_js__WEBPACK_IMPORTED_MODULE_0__[\"BaseResponse\"] {\n  /**\n   * BaseResponse facade for XMLHttpRequest\n   * @param {XMLHttpRequest} xhr\n   * @param {ArrayBuffer} data\n   */\n  constructor(xhr, data) {\n    super();\n    this.xhr = xhr;\n    this.data = data;\n  }\n\n  get status() {\n    return this.xhr.status;\n  }\n\n  getHeader(name) {\n    return this.xhr.getResponseHeader(name);\n  }\n\n  async getData() {\n    return this.data;\n  }\n}\n\nclass XHRClient extends _base_js__WEBPACK_IMPORTED_MODULE_0__[\"BaseClient\"] {\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n      xhr.open('GET', this.url);\n      xhr.responseType = 'arraybuffer';\n      for (const [key, value] of Object.entries(headers)) {\n        xhr.setRequestHeader(key, value);\n      }\n\n      // hook signals\n      xhr.onload = () => {\n        const data = xhr.response;\n        resolve(new XHRResponse(xhr, data));\n      };\n      xhr.onerror = reject;\n      xhr.onabort = () => reject(new _utils_js__WEBPACK_IMPORTED_MODULE_1__[\"AbortError\"]('Request aborted'));\n      xhr.send();\n\n      if (signal) {\n        if (signal.aborted) {\n          xhr.abort();\n        }\n        signal.addEventListener('abort', () => xhr.abort());\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvY2xpZW50L3hoci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9jbGllbnQveGhyLmpzPzk1ZGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZUNsaWVudCwgQmFzZVJlc3BvbnNlIH0gZnJvbSAnLi9iYXNlLmpzJztcbmltcG9ydCB7IEFib3J0RXJyb3IgfSBmcm9tICcuLi8uLi91dGlscy5qcyc7XG5cbmNsYXNzIFhIUlJlc3BvbnNlIGV4dGVuZHMgQmFzZVJlc3BvbnNlIHtcbiAgLyoqXG4gICAqIEJhc2VSZXNwb25zZSBmYWNhZGUgZm9yIFhNTEh0dHBSZXF1ZXN0XG4gICAqIEBwYXJhbSB7WE1MSHR0cFJlcXVlc3R9IHhoclxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih4aHIsIGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMueGhyID0geGhyO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cblxuICBnZXQgc3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLnhoci5zdGF0dXM7XG4gIH1cblxuICBnZXRIZWFkZXIobmFtZSkge1xuICAgIHJldHVybiB0aGlzLnhoci5nZXRSZXNwb25zZUhlYWRlcihuYW1lKTtcbiAgfVxuXG4gIGFzeW5jIGdldERhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgWEhSQ2xpZW50IGV4dGVuZHMgQmFzZUNsaWVudCB7XG4gIGNvbnN0cnVjdFJlcXVlc3QoaGVhZGVycywgc2lnbmFsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgeGhyLm9wZW4oJ0dFVCcsIHRoaXMudXJsKTtcbiAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaGVhZGVycykpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGhvb2sgc2lnbmFsc1xuICAgICAgeGhyLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHhoci5yZXNwb25zZTtcbiAgICAgICAgcmVzb2x2ZShuZXcgWEhSUmVzcG9uc2UoeGhyLCBkYXRhKSk7XG4gICAgICB9O1xuICAgICAgeGhyLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICB4aHIub25hYm9ydCA9ICgpID0+IHJlamVjdChuZXcgQWJvcnRFcnJvcignUmVxdWVzdCBhYm9ydGVkJykpO1xuICAgICAgeGhyLnNlbmQoKTtcblxuICAgICAgaWYgKHNpZ25hbCkge1xuICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB4aHIuYWJvcnQoKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyByZXF1ZXN0KHsgaGVhZGVycywgc2lnbmFsIH0gPSB7fSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jb25zdHJ1Y3RSZXF1ZXN0KGhlYWRlcnMsIHNpZ25hbCk7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/source/client/xhr.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/file.js":
/*!*********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/file.js ***!
  \*********************************************************/
/*! exports provided: makeFileSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"makeFileSource\", function() { return makeFileSource; });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ 14);\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basesource.js */ \"./node_modules/geotiff/dist-module/source/basesource.js\");\n\n\n\nfunction closeAsync(fd) {\n  return new Promise((resolve, reject) => {\n    fs__WEBPACK_IMPORTED_MODULE_0___default.a.close(fd, (err) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n\nfunction openAsync(path, flags, mode = undefined) {\n  return new Promise((resolve, reject) => {\n    fs__WEBPACK_IMPORTED_MODULE_0___default.a.open(path, flags, mode, (err, fd) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(fd);\n      }\n    });\n  });\n}\n\nfunction readAsync(...args) {\n  return new Promise((resolve, reject) => {\n    fs__WEBPACK_IMPORTED_MODULE_0___default.a.read(...args, (err, bytesRead, buffer) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve({ bytesRead, buffer });\n      }\n    });\n  });\n}\n\nclass FileSource extends _basesource_js__WEBPACK_IMPORTED_MODULE_1__[\"BaseSource\"] {\n  constructor(path) {\n    super();\n    this.path = path;\n    this.openRequest = openAsync(path, 'r');\n  }\n\n  async fetchSlice(slice) {\n    // TODO: use `signal`\n    const fd = await this.openRequest;\n    const { buffer } = await readAsync(\n      fd,\n      Buffer.alloc(slice.length),\n      0,\n      slice.length,\n      slice.offset,\n    );\n    return buffer.buffer;\n  }\n\n  async close() {\n    const fd = await this.openRequest;\n    await closeAsync(fd);\n  }\n}\n\nfunction makeFileSource(path) {\n  return new FileSource(path);\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvZmlsZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9maWxlLmpzPzJkNzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCB7IEJhc2VTb3VyY2UgfSBmcm9tICcuL2Jhc2Vzb3VyY2UuanMnO1xuXG5mdW5jdGlvbiBjbG9zZUFzeW5jKGZkKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZnMuY2xvc2UoZmQsIChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvcGVuQXN5bmMocGF0aCwgZmxhZ3MsIG1vZGUgPSB1bmRlZmluZWQpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBmcy5vcGVuKHBhdGgsIGZsYWdzLCBtb2RlLCAoZXJyLCBmZCkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUoZmQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVhZEFzeW5jKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBmcy5yZWFkKC4uLmFyZ3MsIChlcnIsIGJ5dGVzUmVhZCwgYnVmZmVyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZSh7IGJ5dGVzUmVhZCwgYnVmZmVyIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuY2xhc3MgRmlsZVNvdXJjZSBleHRlbmRzIEJhc2VTb3VyY2Uge1xuICBjb25zdHJ1Y3RvcihwYXRoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMub3BlblJlcXVlc3QgPSBvcGVuQXN5bmMocGF0aCwgJ3InKTtcbiAgfVxuXG4gIGFzeW5jIGZldGNoU2xpY2Uoc2xpY2UpIHtcbiAgICAvLyBUT0RPOiB1c2UgYHNpZ25hbGBcbiAgICBjb25zdCBmZCA9IGF3YWl0IHRoaXMub3BlblJlcXVlc3Q7XG4gICAgY29uc3QgeyBidWZmZXIgfSA9IGF3YWl0IHJlYWRBc3luYyhcbiAgICAgIGZkLFxuICAgICAgQnVmZmVyLmFsbG9jKHNsaWNlLmxlbmd0aCksXG4gICAgICAwLFxuICAgICAgc2xpY2UubGVuZ3RoLFxuICAgICAgc2xpY2Uub2Zmc2V0LFxuICAgICk7XG4gICAgcmV0dXJuIGJ1ZmZlci5idWZmZXI7XG4gIH1cblxuICBhc3luYyBjbG9zZSgpIHtcbiAgICBjb25zdCBmZCA9IGF3YWl0IHRoaXMub3BlblJlcXVlc3Q7XG4gICAgYXdhaXQgY2xvc2VBc3luYyhmZCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VGaWxlU291cmNlKHBhdGgpIHtcbiAgcmV0dXJuIG5ldyBGaWxlU291cmNlKHBhdGgpO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/source/file.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/filereader.js":
/*!***************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/filereader.js ***!
  \***************************************************************/
/*! exports provided: makeFileReaderSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"makeFileReaderSource\", function() { return makeFileReaderSource; });\n/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basesource.js */ \"./node_modules/geotiff/dist-module/source/basesource.js\");\n\n\nclass FileReaderSource extends _basesource_js__WEBPACK_IMPORTED_MODULE_0__[\"BaseSource\"] {\n  constructor(file) {\n    super();\n    this.file = file;\n  }\n\n  async fetchSlice(slice, signal) {\n    return new Promise((resolve, reject) => {\n      const blob = this.file.slice(slice.offset, slice.offset + slice.length);\n      const reader = new FileReader();\n      reader.onload = (event) => resolve(event.target.result);\n      reader.onerror = reject;\n      reader.onabort = reject;\n      reader.readAsArrayBuffer(blob);\n\n      if (signal) {\n        signal.addEventListener('abort', () => reader.abort());\n      }\n    });\n  }\n}\n\n/**\n * Create a new source from a given file/blob.\n * @param {Blob} file The file or blob to read from.\n * @returns The constructed source\n */\nfunction makeFileReaderSource(file) {\n  return new FileReaderSource(file);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvZmlsZXJlYWRlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9maWxlcmVhZGVyLmpzPzAzYTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZVNvdXJjZSB9IGZyb20gJy4vYmFzZXNvdXJjZS5qcyc7XG5cbmNsYXNzIEZpbGVSZWFkZXJTb3VyY2UgZXh0ZW5kcyBCYXNlU291cmNlIHtcbiAgY29uc3RydWN0b3IoZmlsZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5maWxlID0gZmlsZTtcbiAgfVxuXG4gIGFzeW5jIGZldGNoU2xpY2Uoc2xpY2UsIHNpZ25hbCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBibG9iID0gdGhpcy5maWxlLnNsaWNlKHNsaWNlLm9mZnNldCwgc2xpY2Uub2Zmc2V0ICsgc2xpY2UubGVuZ3RoKTtcbiAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICByZWFkZXIub25sb2FkID0gKGV2ZW50KSA9PiByZXNvbHZlKGV2ZW50LnRhcmdldC5yZXN1bHQpO1xuICAgICAgcmVhZGVyLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICByZWFkZXIub25hYm9ydCA9IHJlamVjdDtcbiAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTtcblxuICAgICAgaWYgKHNpZ25hbCkge1xuICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiByZWFkZXIuYWJvcnQoKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc291cmNlIGZyb20gYSBnaXZlbiBmaWxlL2Jsb2IuXG4gKiBAcGFyYW0ge0Jsb2J9IGZpbGUgVGhlIGZpbGUgb3IgYmxvYiB0byByZWFkIGZyb20uXG4gKiBAcmV0dXJucyBUaGUgY29uc3RydWN0ZWQgc291cmNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlRmlsZVJlYWRlclNvdXJjZShmaWxlKSB7XG4gIHJldHVybiBuZXcgRmlsZVJlYWRlclNvdXJjZShmaWxlKTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/source/filereader.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/httputils.js":
/*!**************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/httputils.js ***!
  \**************************************************************/
/*! exports provided: parseContentType, parseContentRange, parseByteRanges */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseContentType\", function() { return parseContentType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseContentRange\", function() { return parseContentRange; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseByteRanges\", function() { return parseByteRanges; });\nconst CRLFCRLF = '\\r\\n\\r\\n';\n\n/*\n * Shim for 'Object.fromEntries'\n */\nfunction itemsToObject(items) {\n  if (typeof Object.fromEntries !== 'undefined') {\n    return Object.fromEntries(items);\n  }\n  const obj = {};\n  for (const [key, value] of items) {\n    obj[key.toLowerCase()] = value;\n  }\n  return obj;\n}\n\n/**\n * Parse HTTP headers from a given string.\n * @param {String} text the text to parse the headers from\n * @returns {Object} the parsed headers with lowercase keys\n */\nfunction parseHeaders(text) {\n  const items = text\n    .split('\\r\\n')\n    .map((line) => {\n      const kv = line.split(':').map((str) => str.trim());\n      kv[0] = kv[0].toLowerCase();\n      return kv;\n    });\n\n  return itemsToObject(items);\n}\n\n/**\n * Parse a 'Content-Type' header value to the content-type and parameters\n * @param {String} rawContentType the raw string to parse from\n * @returns {Object} the parsed content type with the fields: type and params\n */\nfunction parseContentType(rawContentType) {\n  const [type, ...rawParams] = rawContentType.split(';').map((s) => s.trim());\n  const paramsItems = rawParams.map((param) => param.split('='));\n  return { type, params: itemsToObject(paramsItems) };\n}\n\n/**\n * Parse a 'Content-Range' header value to its start, end, and total parts\n * @param {String} rawContentRange the raw string to parse from\n * @returns {Object} the parsed parts\n */\nfunction parseContentRange(rawContentRange) {\n  let start;\n  let end;\n  let total;\n\n  if (rawContentRange) {\n    [, start, end, total] = rawContentRange.match(/bytes (\\d+)-(\\d+)\\/(\\d+)/);\n    start = parseInt(start, 10);\n    end = parseInt(end, 10);\n    total = parseInt(total, 10);\n  }\n\n  return { start, end, total };\n}\n\n/**\n * Parses a list of byteranges from the given 'multipart/byteranges' HTTP response.\n * Each item in the list has the following properties:\n * - headers: the HTTP headers\n * - data: the sliced ArrayBuffer for that specific part\n * - offset: the offset of the byterange within its originating file\n * - length: the length of the byterange\n * @param {ArrayBuffer} responseArrayBuffer the response to be parsed and split\n * @param {String} boundary the boundary string used to split the sections\n * @returns {Object[]} the parsed byteranges\n */\nfunction parseByteRanges(responseArrayBuffer, boundary) {\n  let offset = null;\n  const decoder = new TextDecoder('ascii');\n  const out = [];\n\n  const startBoundary = `--${boundary}`;\n  const endBoundary = `${startBoundary}--`;\n\n  // search for the initial boundary, may be offset by some bytes\n  // TODO: more efficient to check for `--` in bytes directly\n  for (let i = 0; i < 10; ++i) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, i, startBoundary.length),\n    );\n    if (text === startBoundary) {\n      offset = i;\n    }\n  }\n\n  if (offset === null) {\n    throw new Error('Could not find initial boundary');\n  }\n\n  while (offset < responseArrayBuffer.byteLength) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, offset,\n        Math.min(startBoundary.length + 1024, responseArrayBuffer.byteLength - offset),\n      ),\n    );\n\n    // break if we arrived at the end\n    if (text.length === 0 || text.startsWith(endBoundary)) {\n      break;\n    }\n\n    // assert that we are actually dealing with a byterange and are at the correct offset\n    if (!text.startsWith(startBoundary)) {\n      throw new Error('Part does not start with boundary');\n    }\n\n    // get a substring from where we read the headers\n    const innerText = text.substr(startBoundary.length + 2);\n\n    if (innerText.length === 0) {\n      break;\n    }\n\n    // find the double linebreak that denotes the end of the headers\n    const endOfHeaders = innerText.indexOf(CRLFCRLF);\n\n    // parse the headers to get the content range size\n    const headers = parseHeaders(innerText.substr(0, endOfHeaders));\n    const { start, end, total } = parseContentRange(headers['content-range']);\n\n    // calculate the length of the slice and the next offset\n    const startOfData = offset + startBoundary.length + endOfHeaders + CRLFCRLF.length;\n    const length = parseInt(end, 10) + 1 - parseInt(start, 10);\n    out.push({\n      headers,\n      data: responseArrayBuffer.slice(startOfData, startOfData + length),\n      offset: start,\n      length,\n      fileSize: total,\n    });\n\n    offset = startOfData + length + 4;\n  }\n\n  return out;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvaHR0cHV0aWxzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvc291cmNlL2h0dHB1dGlscy5qcz9jODZkIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IENSTEZDUkxGID0gJ1xcclxcblxcclxcbic7XG5cbi8qXG4gKiBTaGltIGZvciAnT2JqZWN0LmZyb21FbnRyaWVzJ1xuICovXG5mdW5jdGlvbiBpdGVtc1RvT2JqZWN0KGl0ZW1zKSB7XG4gIGlmICh0eXBlb2YgT2JqZWN0LmZyb21FbnRyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoaXRlbXMpO1xuICB9XG4gIGNvbnN0IG9iaiA9IHt9O1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBpdGVtcykge1xuICAgIG9ialtrZXkudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIFBhcnNlIEhUVFAgaGVhZGVycyBmcm9tIGEgZ2l2ZW4gc3RyaW5nLlxuICogQHBhcmFtIHtTdHJpbmd9IHRleHQgdGhlIHRleHQgdG8gcGFyc2UgdGhlIGhlYWRlcnMgZnJvbVxuICogQHJldHVybnMge09iamVjdH0gdGhlIHBhcnNlZCBoZWFkZXJzIHdpdGggbG93ZXJjYXNlIGtleXNcbiAqL1xuZnVuY3Rpb24gcGFyc2VIZWFkZXJzKHRleHQpIHtcbiAgY29uc3QgaXRlbXMgPSB0ZXh0XG4gICAgLnNwbGl0KCdcXHJcXG4nKVxuICAgIC5tYXAoKGxpbmUpID0+IHtcbiAgICAgIGNvbnN0IGt2ID0gbGluZS5zcGxpdCgnOicpLm1hcCgoc3RyKSA9PiBzdHIudHJpbSgpKTtcbiAgICAgIGt2WzBdID0ga3ZbMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgIHJldHVybiBrdjtcbiAgICB9KTtcblxuICByZXR1cm4gaXRlbXNUb09iamVjdChpdGVtcyk7XG59XG5cbi8qKlxuICogUGFyc2UgYSAnQ29udGVudC1UeXBlJyBoZWFkZXIgdmFsdWUgdG8gdGhlIGNvbnRlbnQtdHlwZSBhbmQgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtTdHJpbmd9IHJhd0NvbnRlbnRUeXBlIHRoZSByYXcgc3RyaW5nIHRvIHBhcnNlIGZyb21cbiAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBwYXJzZWQgY29udGVudCB0eXBlIHdpdGggdGhlIGZpZWxkczogdHlwZSBhbmQgcGFyYW1zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUNvbnRlbnRUeXBlKHJhd0NvbnRlbnRUeXBlKSB7XG4gIGNvbnN0IFt0eXBlLCAuLi5yYXdQYXJhbXNdID0gcmF3Q29udGVudFR5cGUuc3BsaXQoJzsnKS5tYXAoKHMpID0+IHMudHJpbSgpKTtcbiAgY29uc3QgcGFyYW1zSXRlbXMgPSByYXdQYXJhbXMubWFwKChwYXJhbSkgPT4gcGFyYW0uc3BsaXQoJz0nKSk7XG4gIHJldHVybiB7IHR5cGUsIHBhcmFtczogaXRlbXNUb09iamVjdChwYXJhbXNJdGVtcykgfTtcbn1cblxuLyoqXG4gKiBQYXJzZSBhICdDb250ZW50LVJhbmdlJyBoZWFkZXIgdmFsdWUgdG8gaXRzIHN0YXJ0LCBlbmQsIGFuZCB0b3RhbCBwYXJ0c1xuICogQHBhcmFtIHtTdHJpbmd9IHJhd0NvbnRlbnRSYW5nZSB0aGUgcmF3IHN0cmluZyB0byBwYXJzZSBmcm9tXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgcGFyc2VkIHBhcnRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUNvbnRlbnRSYW5nZShyYXdDb250ZW50UmFuZ2UpIHtcbiAgbGV0IHN0YXJ0O1xuICBsZXQgZW5kO1xuICBsZXQgdG90YWw7XG5cbiAgaWYgKHJhd0NvbnRlbnRSYW5nZSkge1xuICAgIFssIHN0YXJ0LCBlbmQsIHRvdGFsXSA9IHJhd0NvbnRlbnRSYW5nZS5tYXRjaCgvYnl0ZXMgKFxcZCspLShcXGQrKVxcLyhcXGQrKS8pO1xuICAgIHN0YXJ0ID0gcGFyc2VJbnQoc3RhcnQsIDEwKTtcbiAgICBlbmQgPSBwYXJzZUludChlbmQsIDEwKTtcbiAgICB0b3RhbCA9IHBhcnNlSW50KHRvdGFsLCAxMCk7XG4gIH1cblxuICByZXR1cm4geyBzdGFydCwgZW5kLCB0b3RhbCB9O1xufVxuXG4vKipcbiAqIFBhcnNlcyBhIGxpc3Qgb2YgYnl0ZXJhbmdlcyBmcm9tIHRoZSBnaXZlbiAnbXVsdGlwYXJ0L2J5dGVyYW5nZXMnIEhUVFAgcmVzcG9uc2UuXG4gKiBFYWNoIGl0ZW0gaW4gdGhlIGxpc3QgaGFzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqIC0gaGVhZGVyczogdGhlIEhUVFAgaGVhZGVyc1xuICogLSBkYXRhOiB0aGUgc2xpY2VkIEFycmF5QnVmZmVyIGZvciB0aGF0IHNwZWNpZmljIHBhcnRcbiAqIC0gb2Zmc2V0OiB0aGUgb2Zmc2V0IG9mIHRoZSBieXRlcmFuZ2Ugd2l0aGluIGl0cyBvcmlnaW5hdGluZyBmaWxlXG4gKiAtIGxlbmd0aDogdGhlIGxlbmd0aCBvZiB0aGUgYnl0ZXJhbmdlXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSByZXNwb25zZUFycmF5QnVmZmVyIHRoZSByZXNwb25zZSB0byBiZSBwYXJzZWQgYW5kIHNwbGl0XG4gKiBAcGFyYW0ge1N0cmluZ30gYm91bmRhcnkgdGhlIGJvdW5kYXJ5IHN0cmluZyB1c2VkIHRvIHNwbGl0IHRoZSBzZWN0aW9uc1xuICogQHJldHVybnMge09iamVjdFtdfSB0aGUgcGFyc2VkIGJ5dGVyYW5nZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQnl0ZVJhbmdlcyhyZXNwb25zZUFycmF5QnVmZmVyLCBib3VuZGFyeSkge1xuICBsZXQgb2Zmc2V0ID0gbnVsbDtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcignYXNjaWknKTtcbiAgY29uc3Qgb3V0ID0gW107XG5cbiAgY29uc3Qgc3RhcnRCb3VuZGFyeSA9IGAtLSR7Ym91bmRhcnl9YDtcbiAgY29uc3QgZW5kQm91bmRhcnkgPSBgJHtzdGFydEJvdW5kYXJ5fS0tYDtcblxuICAvLyBzZWFyY2ggZm9yIHRoZSBpbml0aWFsIGJvdW5kYXJ5LCBtYXkgYmUgb2Zmc2V0IGJ5IHNvbWUgYnl0ZXNcbiAgLy8gVE9ETzogbW9yZSBlZmZpY2llbnQgdG8gY2hlY2sgZm9yIGAtLWAgaW4gYnl0ZXMgZGlyZWN0bHlcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgKytpKSB7XG4gICAgY29uc3QgdGV4dCA9IGRlY29kZXIuZGVjb2RlKFxuICAgICAgbmV3IFVpbnQ4QXJyYXkocmVzcG9uc2VBcnJheUJ1ZmZlciwgaSwgc3RhcnRCb3VuZGFyeS5sZW5ndGgpLFxuICAgICk7XG4gICAgaWYgKHRleHQgPT09IHN0YXJ0Qm91bmRhcnkpIHtcbiAgICAgIG9mZnNldCA9IGk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9mZnNldCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgaW5pdGlhbCBib3VuZGFyeScpO1xuICB9XG5cbiAgd2hpbGUgKG9mZnNldCA8IHJlc3BvbnNlQXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgIGNvbnN0IHRleHQgPSBkZWNvZGVyLmRlY29kZShcbiAgICAgIG5ldyBVaW50OEFycmF5KHJlc3BvbnNlQXJyYXlCdWZmZXIsIG9mZnNldCxcbiAgICAgICAgTWF0aC5taW4oc3RhcnRCb3VuZGFyeS5sZW5ndGggKyAxMDI0LCByZXNwb25zZUFycmF5QnVmZmVyLmJ5dGVMZW5ndGggLSBvZmZzZXQpLFxuICAgICAgKSxcbiAgICApO1xuXG4gICAgLy8gYnJlYWsgaWYgd2UgYXJyaXZlZCBhdCB0aGUgZW5kXG4gICAgaWYgKHRleHQubGVuZ3RoID09PSAwIHx8IHRleHQuc3RhcnRzV2l0aChlbmRCb3VuZGFyeSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIGFzc2VydCB0aGF0IHdlIGFyZSBhY3R1YWxseSBkZWFsaW5nIHdpdGggYSBieXRlcmFuZ2UgYW5kIGFyZSBhdCB0aGUgY29ycmVjdCBvZmZzZXRcbiAgICBpZiAoIXRleHQuc3RhcnRzV2l0aChzdGFydEJvdW5kYXJ5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJ0IGRvZXMgbm90IHN0YXJ0IHdpdGggYm91bmRhcnknKTtcbiAgICB9XG5cbiAgICAvLyBnZXQgYSBzdWJzdHJpbmcgZnJvbSB3aGVyZSB3ZSByZWFkIHRoZSBoZWFkZXJzXG4gICAgY29uc3QgaW5uZXJUZXh0ID0gdGV4dC5zdWJzdHIoc3RhcnRCb3VuZGFyeS5sZW5ndGggKyAyKTtcblxuICAgIGlmIChpbm5lclRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBmaW5kIHRoZSBkb3VibGUgbGluZWJyZWFrIHRoYXQgZGVub3RlcyB0aGUgZW5kIG9mIHRoZSBoZWFkZXJzXG4gICAgY29uc3QgZW5kT2ZIZWFkZXJzID0gaW5uZXJUZXh0LmluZGV4T2YoQ1JMRkNSTEYpO1xuXG4gICAgLy8gcGFyc2UgdGhlIGhlYWRlcnMgdG8gZ2V0IHRoZSBjb250ZW50IHJhbmdlIHNpemVcbiAgICBjb25zdCBoZWFkZXJzID0gcGFyc2VIZWFkZXJzKGlubmVyVGV4dC5zdWJzdHIoMCwgZW5kT2ZIZWFkZXJzKSk7XG4gICAgY29uc3QgeyBzdGFydCwgZW5kLCB0b3RhbCB9ID0gcGFyc2VDb250ZW50UmFuZ2UoaGVhZGVyc1snY29udGVudC1yYW5nZSddKTtcblxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgbGVuZ3RoIG9mIHRoZSBzbGljZSBhbmQgdGhlIG5leHQgb2Zmc2V0XG4gICAgY29uc3Qgc3RhcnRPZkRhdGEgPSBvZmZzZXQgKyBzdGFydEJvdW5kYXJ5Lmxlbmd0aCArIGVuZE9mSGVhZGVycyArIENSTEZDUkxGLmxlbmd0aDtcbiAgICBjb25zdCBsZW5ndGggPSBwYXJzZUludChlbmQsIDEwKSArIDEgLSBwYXJzZUludChzdGFydCwgMTApO1xuICAgIG91dC5wdXNoKHtcbiAgICAgIGhlYWRlcnMsXG4gICAgICBkYXRhOiByZXNwb25zZUFycmF5QnVmZmVyLnNsaWNlKHN0YXJ0T2ZEYXRhLCBzdGFydE9mRGF0YSArIGxlbmd0aCksXG4gICAgICBvZmZzZXQ6IHN0YXJ0LFxuICAgICAgbGVuZ3RoLFxuICAgICAgZmlsZVNpemU6IHRvdGFsLFxuICAgIH0pO1xuXG4gICAgb2Zmc2V0ID0gc3RhcnRPZkRhdGEgKyBsZW5ndGggKyA0O1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/source/httputils.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/remote.js":
/*!***********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/remote.js ***!
  \***********************************************************/
/*! exports provided: makeFetchSource, makeXHRSource, makeHttpSource, makeCustomSource, makeRemoteSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"makeFetchSource\", function() { return makeFetchSource; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"makeXHRSource\", function() { return makeXHRSource; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"makeHttpSource\", function() { return makeHttpSource; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"makeCustomSource\", function() { return makeCustomSource; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"makeRemoteSource\", function() { return makeRemoteSource; });\n/* harmony import */ var _httputils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./httputils.js */ \"./node_modules/geotiff/dist-module/source/httputils.js\");\n/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basesource.js */ \"./node_modules/geotiff/dist-module/source/basesource.js\");\n/* harmony import */ var _blockedsource_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./blockedsource.js */ \"./node_modules/geotiff/dist-module/source/blockedsource.js\");\n/* harmony import */ var _client_fetch_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./client/fetch.js */ \"./node_modules/geotiff/dist-module/source/client/fetch.js\");\n/* harmony import */ var _client_xhr_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./client/xhr.js */ \"./node_modules/geotiff/dist-module/source/client/xhr.js\");\n/* harmony import */ var _client_http_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./client/http.js */ \"./node_modules/geotiff/dist-module/source/client/http.js\");\n\n\n\n\n\n\n\n\nclass RemoteSource extends _basesource_js__WEBPACK_IMPORTED_MODULE_1__[\"BaseSource\"] {\n  /**\n   *\n   * @param {BaseClient} client\n   * @param {object} headers\n   * @param {numbers} maxRanges\n   * @param {boolean} allowFullFile\n   */\n  constructor(client, headers, maxRanges, allowFullFile) {\n    super();\n    this.client = client;\n    this.headers = headers;\n    this.maxRanges = maxRanges;\n    this.allowFullFile = allowFullFile;\n    this._fileSize = null;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    // if we allow multi-ranges, split the incoming request into that many sub-requests\n    // and join them afterwards\n    if (this.maxRanges >= slices.length) {\n      return this.fetchSlices(slices, signal);\n    } else if (this.maxRanges > 0 && slices.length > 1) {\n      // TODO: split into multiple multi-range requests\n\n      // const subSlicesRequests = [];\n      // for (let i = 0; i < slices.length; i += this.maxRanges) {\n      //   subSlicesRequests.push(\n      //     this.fetchSlices(slices.slice(i, i + this.maxRanges), signal),\n      //   );\n      // }\n      // return (await Promise.all(subSlicesRequests)).flat();\n    }\n\n    // otherwise make a single request for each slice\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  async fetchSlices(slices, signal) {\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${slices\n          .map(({ offset, length }) => `${offset}-${offset + length}`)\n          .join(',')\n        }`,\n      },\n      signal,\n    });\n\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const { type, params } = Object(_httputils_js__WEBPACK_IMPORTED_MODULE_0__[\"parseContentType\"])(response.getHeader('content-type'));\n      if (type === 'multipart/byteranges') {\n        const byteRanges = Object(_httputils_js__WEBPACK_IMPORTED_MODULE_0__[\"parseByteRanges\"])(await response.getData(), params.boundary);\n        this._fileSize = byteRanges[0].fileSize || null;\n        return byteRanges;\n      }\n\n      const data = await response.getData();\n\n      const { start, end, total } = Object(_httputils_js__WEBPACK_IMPORTED_MODULE_0__[\"parseContentRange\"])(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      const first = [{\n        data,\n        offset: start,\n        length: end - start,\n      }];\n\n      if (slices.length > 1) {\n        // we requested more than one slice, but got only the first\n        // unfortunately, some HTTP Servers don't support multi-ranges\n        // and return only the first\n\n        // get the rest of the slices and fetch them iteratively\n        const others = await Promise.all(slices.slice(1).map((slice) => this.fetchSlice(slice, signal)));\n        return first.concat(others);\n      }\n      return first;\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n      const data = await response.getData();\n      this._fileSize = data.byteLength;\n      return [{\n        data,\n        offset: 0,\n        length: data.byteLength,\n      }];\n    }\n  }\n\n  async fetchSlice(slice, signal) {\n    const { offset, length } = slice;\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${offset}-${offset + length}`,\n      },\n      signal,\n    });\n\n    // check the response was okay and if the server actually understands range requests\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const data = await response.getData();\n\n      const { total } = Object(_httputils_js__WEBPACK_IMPORTED_MODULE_0__[\"parseContentRange\"])(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      return {\n        data,\n        offset,\n        length,\n      };\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n\n      const data = await response.getData();\n\n      this._fileSize = data.byteLength;\n      return {\n        data,\n        offset: 0,\n        length: data.byteLength,\n      };\n    }\n  }\n\n  get fileSize() {\n    return this._fileSize;\n  }\n}\n\nfunction maybeWrapInBlockedSource(source, { blockSize, cacheSize }) {\n  if (blockSize === null) {\n    return source;\n  }\n  return new _blockedsource_js__WEBPACK_IMPORTED_MODULE_2__[\"BlockedSource\"](source, { blockSize, cacheSize });\n}\n\nfunction makeFetchSource(url, { headers = {}, credentials, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new _client_fetch_js__WEBPACK_IMPORTED_MODULE_3__[\"FetchClient\"](url, credentials);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nfunction makeXHRSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new _client_xhr_js__WEBPACK_IMPORTED_MODULE_4__[\"XHRClient\"](url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nfunction makeHttpSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new _client_http_js__WEBPACK_IMPORTED_MODULE_5__[\"HttpClient\"](url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nfunction makeCustomSource(client, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\n/**\n *\n * @param {string} url\n * @param {object} options\n */\nfunction makeRemoteSource(url, { forceXHR = false, ...clientOptions } = {}) {\n  if (typeof fetch === 'function' && !forceXHR) {\n    return makeFetchSource(url, clientOptions);\n  }\n  if (typeof XMLHttpRequest !== 'undefined') {\n    return makeXHRSource(url, clientOptions);\n  }\n  return makeHttpSource(url, clientOptions);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvcmVtb3RlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvc291cmNlL3JlbW90ZS5qcz85NzBjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBhcnNlQnl0ZVJhbmdlcywgcGFyc2VDb250ZW50UmFuZ2UsIHBhcnNlQ29udGVudFR5cGUgfSBmcm9tICcuL2h0dHB1dGlscy5qcyc7XG5pbXBvcnQgeyBCYXNlU291cmNlIH0gZnJvbSAnLi9iYXNlc291cmNlLmpzJztcbmltcG9ydCB7IEJsb2NrZWRTb3VyY2UgfSBmcm9tICcuL2Jsb2NrZWRzb3VyY2UuanMnO1xuXG5pbXBvcnQgeyBGZXRjaENsaWVudCB9IGZyb20gJy4vY2xpZW50L2ZldGNoLmpzJztcbmltcG9ydCB7IFhIUkNsaWVudCB9IGZyb20gJy4vY2xpZW50L3hoci5qcyc7XG5pbXBvcnQgeyBIdHRwQ2xpZW50IH0gZnJvbSAnLi9jbGllbnQvaHR0cC5qcyc7XG5cbmNsYXNzIFJlbW90ZVNvdXJjZSBleHRlbmRzIEJhc2VTb3VyY2Uge1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtCYXNlQ2xpZW50fSBjbGllbnRcbiAgICogQHBhcmFtIHtvYmplY3R9IGhlYWRlcnNcbiAgICogQHBhcmFtIHtudW1iZXJzfSBtYXhSYW5nZXNcbiAgICogQHBhcmFtIHtib29sZWFufSBhbGxvd0Z1bGxGaWxlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIGhlYWRlcnMsIG1heFJhbmdlcywgYWxsb3dGdWxsRmlsZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICB0aGlzLm1heFJhbmdlcyA9IG1heFJhbmdlcztcbiAgICB0aGlzLmFsbG93RnVsbEZpbGUgPSBhbGxvd0Z1bGxGaWxlO1xuICAgIHRoaXMuX2ZpbGVTaXplID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge1NsaWNlW119IHNsaWNlc1xuICAgKi9cbiAgYXN5bmMgZmV0Y2goc2xpY2VzLCBzaWduYWwpIHtcbiAgICAvLyBpZiB3ZSBhbGxvdyBtdWx0aS1yYW5nZXMsIHNwbGl0IHRoZSBpbmNvbWluZyByZXF1ZXN0IGludG8gdGhhdCBtYW55IHN1Yi1yZXF1ZXN0c1xuICAgIC8vIGFuZCBqb2luIHRoZW0gYWZ0ZXJ3YXJkc1xuICAgIGlmICh0aGlzLm1heFJhbmdlcyA+PSBzbGljZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5mZXRjaFNsaWNlcyhzbGljZXMsIHNpZ25hbCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1heFJhbmdlcyA+IDAgJiYgc2xpY2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIFRPRE86IHNwbGl0IGludG8gbXVsdGlwbGUgbXVsdGktcmFuZ2UgcmVxdWVzdHNcblxuICAgICAgLy8gY29uc3Qgc3ViU2xpY2VzUmVxdWVzdHMgPSBbXTtcbiAgICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpY2VzLmxlbmd0aDsgaSArPSB0aGlzLm1heFJhbmdlcykge1xuICAgICAgLy8gICBzdWJTbGljZXNSZXF1ZXN0cy5wdXNoKFxuICAgICAgLy8gICAgIHRoaXMuZmV0Y2hTbGljZXMoc2xpY2VzLnNsaWNlKGksIGkgKyB0aGlzLm1heFJhbmdlcyksIHNpZ25hbCksXG4gICAgICAvLyAgICk7XG4gICAgICAvLyB9XG4gICAgICAvLyByZXR1cm4gKGF3YWl0IFByb21pc2UuYWxsKHN1YlNsaWNlc1JlcXVlc3RzKSkuZmxhdCgpO1xuICAgIH1cblxuICAgIC8vIG90aGVyd2lzZSBtYWtlIGEgc2luZ2xlIHJlcXVlc3QgZm9yIGVhY2ggc2xpY2VcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICBzbGljZXMubWFwKChzbGljZSkgPT4gdGhpcy5mZXRjaFNsaWNlKHNsaWNlLCBzaWduYWwpKSxcbiAgICApO1xuICB9XG5cbiAgYXN5bmMgZmV0Y2hTbGljZXMoc2xpY2VzLCBzaWduYWwpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3Qoe1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICAuLi50aGlzLmhlYWRlcnMsXG4gICAgICAgIFJhbmdlOiBgYnl0ZXM9JHtzbGljZXNcbiAgICAgICAgICAubWFwKCh7IG9mZnNldCwgbGVuZ3RoIH0pID0+IGAke29mZnNldH0tJHtvZmZzZXQgKyBsZW5ndGh9YClcbiAgICAgICAgICAuam9pbignLCcpXG4gICAgICAgIH1gLFxuICAgICAgfSxcbiAgICAgIHNpZ25hbCxcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgZmV0Y2hpbmcgZGF0YS4nKTtcbiAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA2KSB7XG4gICAgICBjb25zdCB7IHR5cGUsIHBhcmFtcyB9ID0gcGFyc2VDb250ZW50VHlwZShyZXNwb25zZS5nZXRIZWFkZXIoJ2NvbnRlbnQtdHlwZScpKTtcbiAgICAgIGlmICh0eXBlID09PSAnbXVsdGlwYXJ0L2J5dGVyYW5nZXMnKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVSYW5nZXMgPSBwYXJzZUJ5dGVSYW5nZXMoYXdhaXQgcmVzcG9uc2UuZ2V0RGF0YSgpLCBwYXJhbXMuYm91bmRhcnkpO1xuICAgICAgICB0aGlzLl9maWxlU2l6ZSA9IGJ5dGVSYW5nZXNbMF0uZmlsZVNpemUgfHwgbnVsbDtcbiAgICAgICAgcmV0dXJuIGJ5dGVSYW5nZXM7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5nZXREYXRhKCk7XG5cbiAgICAgIGNvbnN0IHsgc3RhcnQsIGVuZCwgdG90YWwgfSA9IHBhcnNlQ29udGVudFJhbmdlKHJlc3BvbnNlLmdldEhlYWRlcignY29udGVudC1yYW5nZScpKTtcbiAgICAgIHRoaXMuX2ZpbGVTaXplID0gdG90YWwgfHwgbnVsbDtcbiAgICAgIGNvbnN0IGZpcnN0ID0gW3tcbiAgICAgICAgZGF0YSxcbiAgICAgICAgb2Zmc2V0OiBzdGFydCxcbiAgICAgICAgbGVuZ3RoOiBlbmQgLSBzdGFydCxcbiAgICAgIH1dO1xuXG4gICAgICBpZiAoc2xpY2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLy8gd2UgcmVxdWVzdGVkIG1vcmUgdGhhbiBvbmUgc2xpY2UsIGJ1dCBnb3Qgb25seSB0aGUgZmlyc3RcbiAgICAgICAgLy8gdW5mb3J0dW5hdGVseSwgc29tZSBIVFRQIFNlcnZlcnMgZG9uJ3Qgc3VwcG9ydCBtdWx0aS1yYW5nZXNcbiAgICAgICAgLy8gYW5kIHJldHVybiBvbmx5IHRoZSBmaXJzdFxuXG4gICAgICAgIC8vIGdldCB0aGUgcmVzdCBvZiB0aGUgc2xpY2VzIGFuZCBmZXRjaCB0aGVtIGl0ZXJhdGl2ZWx5XG4gICAgICAgIGNvbnN0IG90aGVycyA9IGF3YWl0IFByb21pc2UuYWxsKHNsaWNlcy5zbGljZSgxKS5tYXAoKHNsaWNlKSA9PiB0aGlzLmZldGNoU2xpY2Uoc2xpY2UsIHNpZ25hbCkpKTtcbiAgICAgICAgcmV0dXJuIGZpcnN0LmNvbmNhdChvdGhlcnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpcnN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRoaXMuYWxsb3dGdWxsRmlsZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcnZlciByZXNwb25kZWQgd2l0aCBmdWxsIGZpbGUnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5nZXREYXRhKCk7XG4gICAgICB0aGlzLl9maWxlU2l6ZSA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgIHJldHVybiBbe1xuICAgICAgICBkYXRhLFxuICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgIGxlbmd0aDogZGF0YS5ieXRlTGVuZ3RoLFxuICAgICAgfV07XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZmV0Y2hTbGljZShzbGljZSwgc2lnbmFsKSB7XG4gICAgY29uc3QgeyBvZmZzZXQsIGxlbmd0aCB9ID0gc2xpY2U7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0KHtcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgLi4udGhpcy5oZWFkZXJzLFxuICAgICAgICBSYW5nZTogYGJ5dGVzPSR7b2Zmc2V0fS0ke29mZnNldCArIGxlbmd0aH1gLFxuICAgICAgfSxcbiAgICAgIHNpZ25hbCxcbiAgICB9KTtcblxuICAgIC8vIGNoZWNrIHRoZSByZXNwb25zZSB3YXMgb2theSBhbmQgaWYgdGhlIHNlcnZlciBhY3R1YWxseSB1bmRlcnN0YW5kcyByYW5nZSByZXF1ZXN0c1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgZmV0Y2hpbmcgZGF0YS4nKTtcbiAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA2KSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuZ2V0RGF0YSgpO1xuXG4gICAgICBjb25zdCB7IHRvdGFsIH0gPSBwYXJzZUNvbnRlbnRSYW5nZShyZXNwb25zZS5nZXRIZWFkZXIoJ2NvbnRlbnQtcmFuZ2UnKSk7XG4gICAgICB0aGlzLl9maWxlU2l6ZSA9IHRvdGFsIHx8IG51bGw7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhLFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIGxlbmd0aCxcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdGhpcy5hbGxvd0Z1bGxGaWxlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2VydmVyIHJlc3BvbmRlZCB3aXRoIGZ1bGwgZmlsZScpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuZ2V0RGF0YSgpO1xuXG4gICAgICB0aGlzLl9maWxlU2l6ZSA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGEsXG4gICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgbGVuZ3RoOiBkYXRhLmJ5dGVMZW5ndGgsXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGdldCBmaWxlU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZVNpemU7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVXcmFwSW5CbG9ja2VkU291cmNlKHNvdXJjZSwgeyBibG9ja1NpemUsIGNhY2hlU2l6ZSB9KSB7XG4gIGlmIChibG9ja1NpemUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gc291cmNlO1xuICB9XG4gIHJldHVybiBuZXcgQmxvY2tlZFNvdXJjZShzb3VyY2UsIHsgYmxvY2tTaXplLCBjYWNoZVNpemUgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlRmV0Y2hTb3VyY2UodXJsLCB7IGhlYWRlcnMgPSB7fSwgY3JlZGVudGlhbHMsIG1heFJhbmdlcyA9IDAsIGFsbG93RnVsbEZpbGUgPSBmYWxzZSwgLi4uYmxvY2tPcHRpb25zIH0gPSB7fSkge1xuICBjb25zdCBjbGllbnQgPSBuZXcgRmV0Y2hDbGllbnQodXJsLCBjcmVkZW50aWFscyk7XG4gIGNvbnN0IHNvdXJjZSA9IG5ldyBSZW1vdGVTb3VyY2UoY2xpZW50LCBoZWFkZXJzLCBtYXhSYW5nZXMsIGFsbG93RnVsbEZpbGUpO1xuICByZXR1cm4gbWF5YmVXcmFwSW5CbG9ja2VkU291cmNlKHNvdXJjZSwgYmxvY2tPcHRpb25zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VYSFJTb3VyY2UodXJsLCB7IGhlYWRlcnMgPSB7fSwgbWF4UmFuZ2VzID0gMCwgYWxsb3dGdWxsRmlsZSA9IGZhbHNlLCAuLi5ibG9ja09wdGlvbnMgfSA9IHt9KSB7XG4gIGNvbnN0IGNsaWVudCA9IG5ldyBYSFJDbGllbnQodXJsKTtcbiAgY29uc3Qgc291cmNlID0gbmV3IFJlbW90ZVNvdXJjZShjbGllbnQsIGhlYWRlcnMsIG1heFJhbmdlcywgYWxsb3dGdWxsRmlsZSk7XG4gIHJldHVybiBtYXliZVdyYXBJbkJsb2NrZWRTb3VyY2Uoc291cmNlLCBibG9ja09wdGlvbnMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZUh0dHBTb3VyY2UodXJsLCB7IGhlYWRlcnMgPSB7fSwgbWF4UmFuZ2VzID0gMCwgYWxsb3dGdWxsRmlsZSA9IGZhbHNlLCAuLi5ibG9ja09wdGlvbnMgfSA9IHt9KSB7XG4gIGNvbnN0IGNsaWVudCA9IG5ldyBIdHRwQ2xpZW50KHVybCk7XG4gIGNvbnN0IHNvdXJjZSA9IG5ldyBSZW1vdGVTb3VyY2UoY2xpZW50LCBoZWFkZXJzLCBtYXhSYW5nZXMsIGFsbG93RnVsbEZpbGUpO1xuICByZXR1cm4gbWF5YmVXcmFwSW5CbG9ja2VkU291cmNlKHNvdXJjZSwgYmxvY2tPcHRpb25zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VDdXN0b21Tb3VyY2UoY2xpZW50LCB7IGhlYWRlcnMgPSB7fSwgbWF4UmFuZ2VzID0gMCwgYWxsb3dGdWxsRmlsZSA9IGZhbHNlLCAuLi5ibG9ja09wdGlvbnMgfSA9IHt9KSB7XG4gIGNvbnN0IHNvdXJjZSA9IG5ldyBSZW1vdGVTb3VyY2UoY2xpZW50LCBoZWFkZXJzLCBtYXhSYW5nZXMsIGFsbG93RnVsbEZpbGUpO1xuICByZXR1cm4gbWF5YmVXcmFwSW5CbG9ja2VkU291cmNlKHNvdXJjZSwgYmxvY2tPcHRpb25zKTtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VSZW1vdGVTb3VyY2UodXJsLCB7IGZvcmNlWEhSID0gZmFsc2UsIC4uLmNsaWVudE9wdGlvbnMgfSA9IHt9KSB7XG4gIGlmICh0eXBlb2YgZmV0Y2ggPT09ICdmdW5jdGlvbicgJiYgIWZvcmNlWEhSKSB7XG4gICAgcmV0dXJuIG1ha2VGZXRjaFNvdXJjZSh1cmwsIGNsaWVudE9wdGlvbnMpO1xuICB9XG4gIGlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG1ha2VYSFJTb3VyY2UodXJsLCBjbGllbnRPcHRpb25zKTtcbiAgfVxuICByZXR1cm4gbWFrZUh0dHBTb3VyY2UodXJsLCBjbGllbnRPcHRpb25zKTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/source/remote.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/utils.js":
/*!***************************************************!*\
  !*** ./node_modules/geotiff/dist-module/utils.js ***!
  \***************************************************/
/*! exports provided: assign, chunk, endsWith, forEach, invert, range, times, toArray, toArrayRecursively, parseContentRange, wait, zip, AbortError, CustomAggregateError, AggregateError */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"assign\", function() { return assign; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"chunk\", function() { return chunk; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"endsWith\", function() { return endsWith; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forEach\", function() { return forEach; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"invert\", function() { return invert; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"range\", function() { return range; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"times\", function() { return times; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toArray\", function() { return toArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toArrayRecursively\", function() { return toArrayRecursively; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseContentRange\", function() { return parseContentRange; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"wait\", function() { return wait; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"zip\", function() { return zip; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AbortError\", function() { return AbortError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CustomAggregateError\", function() { return CustomAggregateError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AggregateError\", function() { return AggregateError; });\nfunction assign(target, source) {\n  for (const key in source) {\n    if (source.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n}\n\nfunction chunk(iterable, length) {\n  const results = [];\n  const lengthOfIterable = iterable.length;\n  for (let i = 0; i < lengthOfIterable; i += length) {\n    const chunked = [];\n    for (let ci = i; ci < i + length; ci++) {\n      chunked.push(iterable[ci]);\n    }\n    results.push(chunked);\n  }\n  return results;\n}\n\nfunction endsWith(string, expectedEnding) {\n  if (string.length < expectedEnding.length) {\n    return false;\n  }\n  const actualEnding = string.substr(string.length - expectedEnding.length);\n  return actualEnding === expectedEnding;\n}\n\nfunction forEach(iterable, func) {\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    func(iterable[i], i);\n  }\n}\n\nfunction invert(oldObj) {\n  const newObj = {};\n  for (const key in oldObj) {\n    if (oldObj.hasOwnProperty(key)) {\n      const value = oldObj[key];\n      newObj[value] = key;\n    }\n  }\n  return newObj;\n}\n\nfunction range(n) {\n  const results = [];\n  for (let i = 0; i < n; i++) {\n    results.push(i);\n  }\n  return results;\n}\n\nfunction times(numTimes, func) {\n  const results = [];\n  for (let i = 0; i < numTimes; i++) {\n    results.push(func(i));\n  }\n  return results;\n}\n\nfunction toArray(iterable) {\n  const results = [];\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    results.push(iterable[i]);\n  }\n  return results;\n}\n\nfunction toArrayRecursively(input) {\n  if (input.length) {\n    return toArray(input).map(toArrayRecursively);\n  }\n  return input;\n}\n\n// copied from https://github.com/academia-de-codigo/parse-content-range-header/blob/master/index.js\nfunction parseContentRange(headerValue) {\n  if (!headerValue) {\n    return null;\n  }\n\n  if (typeof headerValue !== 'string') {\n    throw new Error('invalid argument');\n  }\n\n  const parseInt = (number) => Number.parseInt(number, 10);\n\n  // Check for presence of unit\n  let matches = headerValue.match(/^(\\w*) /);\n  const unit = matches && matches[1];\n\n  // check for start-end/size header format\n  matches = headerValue.match(/(\\d+)-(\\d+)\\/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: parseInt(matches[1]),\n      last: parseInt(matches[2]),\n      length: matches[3] === '*' ? null : parseInt(matches[3]),\n    };\n  }\n\n  // check for size header format\n  matches = headerValue.match(/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: null,\n      last: null,\n      length: matches[1] === '*' ? null : parseInt(matches[1]),\n    };\n  }\n\n  return null;\n}\n\n/*\n * Promisified wrapper around 'setTimeout' to allow 'await'\n */\nasync function wait(milliseconds) {\n  return new Promise((resolve) => setTimeout(resolve, milliseconds));\n}\n\nfunction zip(a, b) {\n  const A = Array.isArray(a) ? a : Array.from(a);\n  const B = Array.isArray(b) ? b : Array.from(b);\n  return A.map((k, i) => [k, B[i]]);\n}\n\n// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\nclass AbortError extends Error {\n  constructor(params) {\n    // Pass remaining arguments (including vendor specific ones) to parent constructor\n    super(params);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AbortError);\n    }\n\n    this.name = 'AbortError';\n  }\n}\n\nclass CustomAggregateError extends Error {\n  constructor(errors, message) {\n    super(message);\n    this.errors = errors;\n    this.message = message;\n    this.name = 'AggregateError';\n  }\n}\n\nconst AggregateError = CustomAggregateError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS91dGlscy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3V0aWxzLmpzP2FlNzUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkge1xuICBmb3IgKGNvbnN0IGtleSBpbiBzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaHVuayhpdGVyYWJsZSwgbGVuZ3RoKSB7XG4gIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgY29uc3QgbGVuZ3RoT2ZJdGVyYWJsZSA9IGl0ZXJhYmxlLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGhPZkl0ZXJhYmxlOyBpICs9IGxlbmd0aCkge1xuICAgIGNvbnN0IGNodW5rZWQgPSBbXTtcbiAgICBmb3IgKGxldCBjaSA9IGk7IGNpIDwgaSArIGxlbmd0aDsgY2krKykge1xuICAgICAgY2h1bmtlZC5wdXNoKGl0ZXJhYmxlW2NpXSk7XG4gICAgfVxuICAgIHJlc3VsdHMucHVzaChjaHVua2VkKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuZHNXaXRoKHN0cmluZywgZXhwZWN0ZWRFbmRpbmcpIHtcbiAgaWYgKHN0cmluZy5sZW5ndGggPCBleHBlY3RlZEVuZGluZy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgYWN0dWFsRW5kaW5nID0gc3RyaW5nLnN1YnN0cihzdHJpbmcubGVuZ3RoIC0gZXhwZWN0ZWRFbmRpbmcubGVuZ3RoKTtcbiAgcmV0dXJuIGFjdHVhbEVuZGluZyA9PT0gZXhwZWN0ZWRFbmRpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JFYWNoKGl0ZXJhYmxlLCBmdW5jKSB7XG4gIGNvbnN0IHsgbGVuZ3RoIH0gPSBpdGVyYWJsZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGZ1bmMoaXRlcmFibGVbaV0sIGkpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQob2xkT2JqKSB7XG4gIGNvbnN0IG5ld09iaiA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBvbGRPYmopIHtcbiAgICBpZiAob2xkT2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb2xkT2JqW2tleV07XG4gICAgICBuZXdPYmpbdmFsdWVdID0ga2V5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3T2JqO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmFuZ2Uobikge1xuICBjb25zdCByZXN1bHRzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgcmVzdWx0cy5wdXNoKGkpO1xuICB9XG4gIHJldHVybiByZXN1bHRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGltZXMobnVtVGltZXMsIGZ1bmMpIHtcbiAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVRpbWVzOyBpKyspIHtcbiAgICByZXN1bHRzLnB1c2goZnVuYyhpKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b0FycmF5KGl0ZXJhYmxlKSB7XG4gIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgY29uc3QgeyBsZW5ndGggfSA9IGl0ZXJhYmxlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0cy5wdXNoKGl0ZXJhYmxlW2ldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvQXJyYXlSZWN1cnNpdmVseShpbnB1dCkge1xuICBpZiAoaW5wdXQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRvQXJyYXkoaW5wdXQpLm1hcCh0b0FycmF5UmVjdXJzaXZlbHkpO1xuICB9XG4gIHJldHVybiBpbnB1dDtcbn1cblxuLy8gY29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2FjYWRlbWlhLWRlLWNvZGlnby9wYXJzZS1jb250ZW50LXJhbmdlLWhlYWRlci9ibG9iL21hc3Rlci9pbmRleC5qc1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ29udGVudFJhbmdlKGhlYWRlclZhbHVlKSB7XG4gIGlmICghaGVhZGVyVmFsdWUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaGVhZGVyVmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gIH1cblxuICBjb25zdCBwYXJzZUludCA9IChudW1iZXIpID0+IE51bWJlci5wYXJzZUludChudW1iZXIsIDEwKTtcblxuICAvLyBDaGVjayBmb3IgcHJlc2VuY2Ugb2YgdW5pdFxuICBsZXQgbWF0Y2hlcyA9IGhlYWRlclZhbHVlLm1hdGNoKC9eKFxcdyopIC8pO1xuICBjb25zdCB1bml0ID0gbWF0Y2hlcyAmJiBtYXRjaGVzWzFdO1xuXG4gIC8vIGNoZWNrIGZvciBzdGFydC1lbmQvc2l6ZSBoZWFkZXIgZm9ybWF0XG4gIG1hdGNoZXMgPSBoZWFkZXJWYWx1ZS5tYXRjaCgvKFxcZCspLShcXGQrKVxcLyhcXGQrfFxcKikvKTtcbiAgaWYgKG1hdGNoZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdW5pdCxcbiAgICAgIGZpcnN0OiBwYXJzZUludChtYXRjaGVzWzFdKSxcbiAgICAgIGxhc3Q6IHBhcnNlSW50KG1hdGNoZXNbMl0pLFxuICAgICAgbGVuZ3RoOiBtYXRjaGVzWzNdID09PSAnKicgPyBudWxsIDogcGFyc2VJbnQobWF0Y2hlc1szXSksXG4gICAgfTtcbiAgfVxuXG4gIC8vIGNoZWNrIGZvciBzaXplIGhlYWRlciBmb3JtYXRcbiAgbWF0Y2hlcyA9IGhlYWRlclZhbHVlLm1hdGNoKC8oXFxkK3xcXCopLyk7XG4gIGlmIChtYXRjaGVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVuaXQsXG4gICAgICBmaXJzdDogbnVsbCxcbiAgICAgIGxhc3Q6IG51bGwsXG4gICAgICBsZW5ndGg6IG1hdGNoZXNbMV0gPT09ICcqJyA/IG51bGwgOiBwYXJzZUludChtYXRjaGVzWzFdKSxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qXG4gKiBQcm9taXNpZmllZCB3cmFwcGVyIGFyb3VuZCAnc2V0VGltZW91dCcgdG8gYWxsb3cgJ2F3YWl0J1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd2FpdChtaWxsaXNlY29uZHMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1pbGxpc2Vjb25kcykpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gemlwKGEsIGIpIHtcbiAgY29uc3QgQSA9IEFycmF5LmlzQXJyYXkoYSkgPyBhIDogQXJyYXkuZnJvbShhKTtcbiAgY29uc3QgQiA9IEFycmF5LmlzQXJyYXkoYikgPyBiIDogQXJyYXkuZnJvbShiKTtcbiAgcmV0dXJuIEEubWFwKChrLCBpKSA9PiBbaywgQltpXV0pO1xufVxuXG4vLyBCYXNlZCBvbiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvclxuZXhwb3J0IGNsYXNzIEFib3J0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIC8vIFBhc3MgcmVtYWluaW5nIGFyZ3VtZW50cyAoaW5jbHVkaW5nIHZlbmRvciBzcGVjaWZpYyBvbmVzKSB0byBwYXJlbnQgY29uc3RydWN0b3JcbiAgICBzdXBlcihwYXJhbXMpO1xuXG4gICAgLy8gTWFpbnRhaW5zIHByb3BlciBzdGFjayB0cmFjZSBmb3Igd2hlcmUgb3VyIGVycm9yIHdhcyB0aHJvd24gKG9ubHkgYXZhaWxhYmxlIG9uIFY4KVxuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQWJvcnRFcnJvcik7XG4gICAgfVxuXG4gICAgdGhpcy5uYW1lID0gJ0Fib3J0RXJyb3InO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBDdXN0b21BZ2dyZWdhdGVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoZXJyb3JzLCBtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLm5hbWUgPSAnQWdncmVnYXRlRXJyb3InO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBBZ2dyZWdhdGVFcnJvciA9IEN1c3RvbUFnZ3JlZ2F0ZUVycm9yO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/utils.js\n");

/***/ }),

/***/ "./node_modules/quick-lru/index.js":
/*!*****************************************!*\
  !*** ./node_modules/quick-lru/index.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return QuickLRU; });\nclass QuickLRU extends Map {\n\tconstructor(options = {}) {\n\t\tsuper();\n\n\t\tif (!(options.maxSize && options.maxSize > 0)) {\n\t\t\tthrow new TypeError('`maxSize` must be a number greater than 0');\n\t\t}\n\n\t\tif (typeof options.maxAge === 'number' && options.maxAge === 0) {\n\t\t\tthrow new TypeError('`maxAge` must be a number greater than 0');\n\t\t}\n\n\t\t// TODO: Use private class fields when ESLint supports them.\n\t\tthis.maxSize = options.maxSize;\n\t\tthis.maxAge = options.maxAge || Number.POSITIVE_INFINITY;\n\t\tthis.onEviction = options.onEviction;\n\t\tthis.cache = new Map();\n\t\tthis.oldCache = new Map();\n\t\tthis._size = 0;\n\t}\n\n\t// TODO: Use private class methods when targeting Node.js 16.\n\t_emitEvictions(cache) {\n\t\tif (typeof this.onEviction !== 'function') {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const [key, item] of cache) {\n\t\t\tthis.onEviction(key, item.value);\n\t\t}\n\t}\n\n\t_deleteIfExpired(key, item) {\n\t\tif (typeof item.expiry === 'number' && item.expiry <= Date.now()) {\n\t\t\tif (typeof this.onEviction === 'function') {\n\t\t\t\tthis.onEviction(key, item.value);\n\t\t\t}\n\n\t\t\treturn this.delete(key);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t_getOrDeleteIfExpired(key, item) {\n\t\tconst deleted = this._deleteIfExpired(key, item);\n\t\tif (deleted === false) {\n\t\t\treturn item.value;\n\t\t}\n\t}\n\n\t_getItemValue(key, item) {\n\t\treturn item.expiry ? this._getOrDeleteIfExpired(key, item) : item.value;\n\t}\n\n\t_peek(key, cache) {\n\t\tconst item = cache.get(key);\n\n\t\treturn this._getItemValue(key, item);\n\t}\n\n\t_set(key, value) {\n\t\tthis.cache.set(key, value);\n\t\tthis._size++;\n\n\t\tif (this._size >= this.maxSize) {\n\t\t\tthis._size = 0;\n\t\t\tthis._emitEvictions(this.oldCache);\n\t\t\tthis.oldCache = this.cache;\n\t\t\tthis.cache = new Map();\n\t\t}\n\t}\n\n\t_moveToRecent(key, item) {\n\t\tthis.oldCache.delete(key);\n\t\tthis._set(key, item);\n\t}\n\n\t* _entriesAscending() {\n\t\tfor (const item of this.oldCache) {\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield item;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const item of this.cache) {\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield item;\n\t\t\t}\n\t\t}\n\t}\n\n\tget(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\tconst item = this.cache.get(key);\n\n\t\t\treturn this._getItemValue(key, item);\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\tconst item = this.oldCache.get(key);\n\t\t\tif (this._deleteIfExpired(key, item) === false) {\n\t\t\t\tthis._moveToRecent(key, item);\n\t\t\t\treturn item.value;\n\t\t\t}\n\t\t}\n\t}\n\n\tset(key, value, {maxAge = this.maxAge} = {}) {\n\t\tconst expiry =\n\t\t\ttypeof maxAge === 'number' && maxAge !== Number.POSITIVE_INFINITY ?\n\t\t\t\tDate.now() + maxAge :\n\t\t\t\tundefined;\n\t\tif (this.cache.has(key)) {\n\t\t\tthis.cache.set(key, {\n\t\t\t\tvalue,\n\t\t\t\texpiry\n\t\t\t});\n\t\t} else {\n\t\t\tthis._set(key, {value, expiry});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\thas(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn !this._deleteIfExpired(key, this.cache.get(key));\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\treturn !this._deleteIfExpired(key, this.oldCache.get(key));\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpeek(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn this._peek(key, this.cache);\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\treturn this._peek(key, this.oldCache);\n\t\t}\n\t}\n\n\tdelete(key) {\n\t\tconst deleted = this.cache.delete(key);\n\t\tif (deleted) {\n\t\t\tthis._size--;\n\t\t}\n\n\t\treturn this.oldCache.delete(key) || deleted;\n\t}\n\n\tclear() {\n\t\tthis.cache.clear();\n\t\tthis.oldCache.clear();\n\t\tthis._size = 0;\n\t}\n\n\tresize(newSize) {\n\t\tif (!(newSize && newSize > 0)) {\n\t\t\tthrow new TypeError('`maxSize` must be a number greater than 0');\n\t\t}\n\n\t\tconst items = [...this._entriesAscending()];\n\t\tconst removeCount = items.length - newSize;\n\t\tif (removeCount < 0) {\n\t\t\tthis.cache = new Map(items);\n\t\t\tthis.oldCache = new Map();\n\t\t\tthis._size = items.length;\n\t\t} else {\n\t\t\tif (removeCount > 0) {\n\t\t\t\tthis._emitEvictions(items.slice(0, removeCount));\n\t\t\t}\n\n\t\t\tthis.oldCache = new Map(items.slice(removeCount));\n\t\t\tthis.cache = new Map();\n\t\t\tthis._size = 0;\n\t\t}\n\n\t\tthis.maxSize = newSize;\n\t}\n\n\t* keys() {\n\t\tfor (const [key] of this) {\n\t\t\tyield key;\n\t\t}\n\t}\n\n\t* values() {\n\t\tfor (const [, value] of this) {\n\t\t\tyield value;\n\t\t}\n\t}\n\n\t* [Symbol.iterator]() {\n\t\tfor (const item of this.cache) {\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield [key, value.value];\n\t\t\t}\n\t\t}\n\n\t\tfor (const item of this.oldCache) {\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield [key, value.value];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t* entriesDescending() {\n\t\tlet items = [...this.cache];\n\t\tfor (let i = items.length - 1; i >= 0; --i) {\n\t\t\tconst item = items[i];\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield [key, value.value];\n\t\t\t}\n\t\t}\n\n\t\titems = [...this.oldCache];\n\t\tfor (let i = items.length - 1; i >= 0; --i) {\n\t\t\tconst item = items[i];\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield [key, value.value];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t* entriesAscending() {\n\t\tfor (const [key, value] of this._entriesAscending()) {\n\t\t\tyield [key, value.value];\n\t\t}\n\t}\n\n\tget size() {\n\t\tif (!this._size) {\n\t\t\treturn this.oldCache.size;\n\t\t}\n\n\t\tlet oldCacheSize = 0;\n\t\tfor (const key of this.oldCache.keys()) {\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\toldCacheSize++;\n\t\t\t}\n\t\t}\n\n\t\treturn Math.min(this._size + oldCacheSize, this.maxSize);\n\t}\n\n\tentries() {\n\t\treturn this.entriesAscending();\n\t}\n\n\tforEach(callbackFunction, thisArgument = this) {\n\t\tfor (const [key, value] of this.entriesAscending()) {\n\t\t\tcallbackFunction.call(thisArgument, value, key, this);\n\t\t}\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn JSON.stringify([...this.entriesAscending()]);\n\t}\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcXVpY2stbHJ1L2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3F1aWNrLWxydS9pbmRleC5qcz85ZGQwIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1aWNrTFJVIGV4dGVuZHMgTWFwIHtcblx0Y29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdGlmICghKG9wdGlvbnMubWF4U2l6ZSAmJiBvcHRpb25zLm1heFNpemUgPiAwKSkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignYG1heFNpemVgIG11c3QgYmUgYSBudW1iZXIgZ3JlYXRlciB0aGFuIDAnKTtcblx0XHR9XG5cblx0XHRpZiAodHlwZW9mIG9wdGlvbnMubWF4QWdlID09PSAnbnVtYmVyJyAmJiBvcHRpb25zLm1heEFnZSA9PT0gMCkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignYG1heEFnZWAgbXVzdCBiZSBhIG51bWJlciBncmVhdGVyIHRoYW4gMCcpO1xuXHRcdH1cblxuXHRcdC8vIFRPRE86IFVzZSBwcml2YXRlIGNsYXNzIGZpZWxkcyB3aGVuIEVTTGludCBzdXBwb3J0cyB0aGVtLlxuXHRcdHRoaXMubWF4U2l6ZSA9IG9wdGlvbnMubWF4U2l6ZTtcblx0XHR0aGlzLm1heEFnZSA9IG9wdGlvbnMubWF4QWdlIHx8IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblx0XHR0aGlzLm9uRXZpY3Rpb24gPSBvcHRpb25zLm9uRXZpY3Rpb247XG5cdFx0dGhpcy5jYWNoZSA9IG5ldyBNYXAoKTtcblx0XHR0aGlzLm9sZENhY2hlID0gbmV3IE1hcCgpO1xuXHRcdHRoaXMuX3NpemUgPSAwO1xuXHR9XG5cblx0Ly8gVE9ETzogVXNlIHByaXZhdGUgY2xhc3MgbWV0aG9kcyB3aGVuIHRhcmdldGluZyBOb2RlLmpzIDE2LlxuXHRfZW1pdEV2aWN0aW9ucyhjYWNoZSkge1xuXHRcdGlmICh0eXBlb2YgdGhpcy5vbkV2aWN0aW9uICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Zm9yIChjb25zdCBba2V5LCBpdGVtXSBvZiBjYWNoZSkge1xuXHRcdFx0dGhpcy5vbkV2aWN0aW9uKGtleSwgaXRlbS52YWx1ZSk7XG5cdFx0fVxuXHR9XG5cblx0X2RlbGV0ZUlmRXhwaXJlZChrZXksIGl0ZW0pIHtcblx0XHRpZiAodHlwZW9mIGl0ZW0uZXhwaXJ5ID09PSAnbnVtYmVyJyAmJiBpdGVtLmV4cGlyeSA8PSBEYXRlLm5vdygpKSB7XG5cdFx0XHRpZiAodHlwZW9mIHRoaXMub25FdmljdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHR0aGlzLm9uRXZpY3Rpb24oa2V5LCBpdGVtLnZhbHVlKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMuZGVsZXRlKGtleSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0X2dldE9yRGVsZXRlSWZFeHBpcmVkKGtleSwgaXRlbSkge1xuXHRcdGNvbnN0IGRlbGV0ZWQgPSB0aGlzLl9kZWxldGVJZkV4cGlyZWQoa2V5LCBpdGVtKTtcblx0XHRpZiAoZGVsZXRlZCA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybiBpdGVtLnZhbHVlO1xuXHRcdH1cblx0fVxuXG5cdF9nZXRJdGVtVmFsdWUoa2V5LCBpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0uZXhwaXJ5ID8gdGhpcy5fZ2V0T3JEZWxldGVJZkV4cGlyZWQoa2V5LCBpdGVtKSA6IGl0ZW0udmFsdWU7XG5cdH1cblxuXHRfcGVlayhrZXksIGNhY2hlKSB7XG5cdFx0Y29uc3QgaXRlbSA9IGNhY2hlLmdldChrZXkpO1xuXG5cdFx0cmV0dXJuIHRoaXMuX2dldEl0ZW1WYWx1ZShrZXksIGl0ZW0pO1xuXHR9XG5cblx0X3NldChrZXksIHZhbHVlKSB7XG5cdFx0dGhpcy5jYWNoZS5zZXQoa2V5LCB2YWx1ZSk7XG5cdFx0dGhpcy5fc2l6ZSsrO1xuXG5cdFx0aWYgKHRoaXMuX3NpemUgPj0gdGhpcy5tYXhTaXplKSB7XG5cdFx0XHR0aGlzLl9zaXplID0gMDtcblx0XHRcdHRoaXMuX2VtaXRFdmljdGlvbnModGhpcy5vbGRDYWNoZSk7XG5cdFx0XHR0aGlzLm9sZENhY2hlID0gdGhpcy5jYWNoZTtcblx0XHRcdHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7XG5cdFx0fVxuXHR9XG5cblx0X21vdmVUb1JlY2VudChrZXksIGl0ZW0pIHtcblx0XHR0aGlzLm9sZENhY2hlLmRlbGV0ZShrZXkpO1xuXHRcdHRoaXMuX3NldChrZXksIGl0ZW0pO1xuXHR9XG5cblx0KiBfZW50cmllc0FzY2VuZGluZygpIHtcblx0XHRmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5vbGRDYWNoZSkge1xuXHRcdFx0Y29uc3QgW2tleSwgdmFsdWVdID0gaXRlbTtcblx0XHRcdGlmICghdGhpcy5jYWNoZS5oYXMoa2V5KSkge1xuXHRcdFx0XHRjb25zdCBkZWxldGVkID0gdGhpcy5fZGVsZXRlSWZFeHBpcmVkKGtleSwgdmFsdWUpO1xuXHRcdFx0XHRpZiAoZGVsZXRlZCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHR5aWVsZCBpdGVtO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChjb25zdCBpdGVtIG9mIHRoaXMuY2FjaGUpIHtcblx0XHRcdGNvbnN0IFtrZXksIHZhbHVlXSA9IGl0ZW07XG5cdFx0XHRjb25zdCBkZWxldGVkID0gdGhpcy5fZGVsZXRlSWZFeHBpcmVkKGtleSwgdmFsdWUpO1xuXHRcdFx0aWYgKGRlbGV0ZWQgPT09IGZhbHNlKSB7XG5cdFx0XHRcdHlpZWxkIGl0ZW07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Z2V0KGtleSkge1xuXHRcdGlmICh0aGlzLmNhY2hlLmhhcyhrZXkpKSB7XG5cdFx0XHRjb25zdCBpdGVtID0gdGhpcy5jYWNoZS5nZXQoa2V5KTtcblxuXHRcdFx0cmV0dXJuIHRoaXMuX2dldEl0ZW1WYWx1ZShrZXksIGl0ZW0pO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9sZENhY2hlLmhhcyhrZXkpKSB7XG5cdFx0XHRjb25zdCBpdGVtID0gdGhpcy5vbGRDYWNoZS5nZXQoa2V5KTtcblx0XHRcdGlmICh0aGlzLl9kZWxldGVJZkV4cGlyZWQoa2V5LCBpdGVtKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0dGhpcy5fbW92ZVRvUmVjZW50KGtleSwgaXRlbSk7XG5cdFx0XHRcdHJldHVybiBpdGVtLnZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHNldChrZXksIHZhbHVlLCB7bWF4QWdlID0gdGhpcy5tYXhBZ2V9ID0ge30pIHtcblx0XHRjb25zdCBleHBpcnkgPVxuXHRcdFx0dHlwZW9mIG1heEFnZSA9PT0gJ251bWJlcicgJiYgbWF4QWdlICE9PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgP1xuXHRcdFx0XHREYXRlLm5vdygpICsgbWF4QWdlIDpcblx0XHRcdFx0dW5kZWZpbmVkO1xuXHRcdGlmICh0aGlzLmNhY2hlLmhhcyhrZXkpKSB7XG5cdFx0XHR0aGlzLmNhY2hlLnNldChrZXksIHtcblx0XHRcdFx0dmFsdWUsXG5cdFx0XHRcdGV4cGlyeVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3NldChrZXksIHt2YWx1ZSwgZXhwaXJ5fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRoYXMoa2V5KSB7XG5cdFx0aWYgKHRoaXMuY2FjaGUuaGFzKGtleSkpIHtcblx0XHRcdHJldHVybiAhdGhpcy5fZGVsZXRlSWZFeHBpcmVkKGtleSwgdGhpcy5jYWNoZS5nZXQoa2V5KSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMub2xkQ2FjaGUuaGFzKGtleSkpIHtcblx0XHRcdHJldHVybiAhdGhpcy5fZGVsZXRlSWZFeHBpcmVkKGtleSwgdGhpcy5vbGRDYWNoZS5nZXQoa2V5KSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cGVlayhrZXkpIHtcblx0XHRpZiAodGhpcy5jYWNoZS5oYXMoa2V5KSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3BlZWsoa2V5LCB0aGlzLmNhY2hlKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vbGRDYWNoZS5oYXMoa2V5KSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3BlZWsoa2V5LCB0aGlzLm9sZENhY2hlKTtcblx0XHR9XG5cdH1cblxuXHRkZWxldGUoa2V5KSB7XG5cdFx0Y29uc3QgZGVsZXRlZCA9IHRoaXMuY2FjaGUuZGVsZXRlKGtleSk7XG5cdFx0aWYgKGRlbGV0ZWQpIHtcblx0XHRcdHRoaXMuX3NpemUtLTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5vbGRDYWNoZS5kZWxldGUoa2V5KSB8fCBkZWxldGVkO1xuXHR9XG5cblx0Y2xlYXIoKSB7XG5cdFx0dGhpcy5jYWNoZS5jbGVhcigpO1xuXHRcdHRoaXMub2xkQ2FjaGUuY2xlYXIoKTtcblx0XHR0aGlzLl9zaXplID0gMDtcblx0fVxuXG5cdHJlc2l6ZShuZXdTaXplKSB7XG5cdFx0aWYgKCEobmV3U2l6ZSAmJiBuZXdTaXplID4gMCkpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ2BtYXhTaXplYCBtdXN0IGJlIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiAwJyk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgaXRlbXMgPSBbLi4udGhpcy5fZW50cmllc0FzY2VuZGluZygpXTtcblx0XHRjb25zdCByZW1vdmVDb3VudCA9IGl0ZW1zLmxlbmd0aCAtIG5ld1NpemU7XG5cdFx0aWYgKHJlbW92ZUNvdW50IDwgMCkge1xuXHRcdFx0dGhpcy5jYWNoZSA9IG5ldyBNYXAoaXRlbXMpO1xuXHRcdFx0dGhpcy5vbGRDYWNoZSA9IG5ldyBNYXAoKTtcblx0XHRcdHRoaXMuX3NpemUgPSBpdGVtcy5sZW5ndGg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChyZW1vdmVDb3VudCA+IDApIHtcblx0XHRcdFx0dGhpcy5fZW1pdEV2aWN0aW9ucyhpdGVtcy5zbGljZSgwLCByZW1vdmVDb3VudCkpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm9sZENhY2hlID0gbmV3IE1hcChpdGVtcy5zbGljZShyZW1vdmVDb3VudCkpO1xuXHRcdFx0dGhpcy5jYWNoZSA9IG5ldyBNYXAoKTtcblx0XHRcdHRoaXMuX3NpemUgPSAwO1xuXHRcdH1cblxuXHRcdHRoaXMubWF4U2l6ZSA9IG5ld1NpemU7XG5cdH1cblxuXHQqIGtleXMoKSB7XG5cdFx0Zm9yIChjb25zdCBba2V5XSBvZiB0aGlzKSB7XG5cdFx0XHR5aWVsZCBrZXk7XG5cdFx0fVxuXHR9XG5cblx0KiB2YWx1ZXMoKSB7XG5cdFx0Zm9yIChjb25zdCBbLCB2YWx1ZV0gb2YgdGhpcykge1xuXHRcdFx0eWllbGQgdmFsdWU7XG5cdFx0fVxuXHR9XG5cblx0KiBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcblx0XHRmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5jYWNoZSkge1xuXHRcdFx0Y29uc3QgW2tleSwgdmFsdWVdID0gaXRlbTtcblx0XHRcdGNvbnN0IGRlbGV0ZWQgPSB0aGlzLl9kZWxldGVJZkV4cGlyZWQoa2V5LCB2YWx1ZSk7XG5cdFx0XHRpZiAoZGVsZXRlZCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0eWllbGQgW2tleSwgdmFsdWUudmFsdWVdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLm9sZENhY2hlKSB7XG5cdFx0XHRjb25zdCBba2V5LCB2YWx1ZV0gPSBpdGVtO1xuXHRcdFx0aWYgKCF0aGlzLmNhY2hlLmhhcyhrZXkpKSB7XG5cdFx0XHRcdGNvbnN0IGRlbGV0ZWQgPSB0aGlzLl9kZWxldGVJZkV4cGlyZWQoa2V5LCB2YWx1ZSk7XG5cdFx0XHRcdGlmIChkZWxldGVkID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdHlpZWxkIFtrZXksIHZhbHVlLnZhbHVlXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdCogZW50cmllc0Rlc2NlbmRpbmcoKSB7XG5cdFx0bGV0IGl0ZW1zID0gWy4uLnRoaXMuY2FjaGVdO1xuXHRcdGZvciAobGV0IGkgPSBpdGVtcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuXHRcdFx0Y29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuXHRcdFx0Y29uc3QgW2tleSwgdmFsdWVdID0gaXRlbTtcblx0XHRcdGNvbnN0IGRlbGV0ZWQgPSB0aGlzLl9kZWxldGVJZkV4cGlyZWQoa2V5LCB2YWx1ZSk7XG5cdFx0XHRpZiAoZGVsZXRlZCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0eWllbGQgW2tleSwgdmFsdWUudmFsdWVdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGl0ZW1zID0gWy4uLnRoaXMub2xkQ2FjaGVdO1xuXHRcdGZvciAobGV0IGkgPSBpdGVtcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuXHRcdFx0Y29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuXHRcdFx0Y29uc3QgW2tleSwgdmFsdWVdID0gaXRlbTtcblx0XHRcdGlmICghdGhpcy5jYWNoZS5oYXMoa2V5KSkge1xuXHRcdFx0XHRjb25zdCBkZWxldGVkID0gdGhpcy5fZGVsZXRlSWZFeHBpcmVkKGtleSwgdmFsdWUpO1xuXHRcdFx0XHRpZiAoZGVsZXRlZCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHR5aWVsZCBba2V5LCB2YWx1ZS52YWx1ZV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQqIGVudHJpZXNBc2NlbmRpbmcoKSB7XG5cdFx0Zm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5fZW50cmllc0FzY2VuZGluZygpKSB7XG5cdFx0XHR5aWVsZCBba2V5LCB2YWx1ZS52YWx1ZV07XG5cdFx0fVxuXHR9XG5cblx0Z2V0IHNpemUoKSB7XG5cdFx0aWYgKCF0aGlzLl9zaXplKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5vbGRDYWNoZS5zaXplO1xuXHRcdH1cblxuXHRcdGxldCBvbGRDYWNoZVNpemUgPSAwO1xuXHRcdGZvciAoY29uc3Qga2V5IG9mIHRoaXMub2xkQ2FjaGUua2V5cygpKSB7XG5cdFx0XHRpZiAoIXRoaXMuY2FjaGUuaGFzKGtleSkpIHtcblx0XHRcdFx0b2xkQ2FjaGVTaXplKys7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIE1hdGgubWluKHRoaXMuX3NpemUgKyBvbGRDYWNoZVNpemUsIHRoaXMubWF4U2l6ZSk7XG5cdH1cblxuXHRlbnRyaWVzKCkge1xuXHRcdHJldHVybiB0aGlzLmVudHJpZXNBc2NlbmRpbmcoKTtcblx0fVxuXG5cdGZvckVhY2goY2FsbGJhY2tGdW5jdGlvbiwgdGhpc0FyZ3VtZW50ID0gdGhpcykge1xuXHRcdGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuZW50cmllc0FzY2VuZGluZygpKSB7XG5cdFx0XHRjYWxsYmFja0Z1bmN0aW9uLmNhbGwodGhpc0FyZ3VtZW50LCB2YWx1ZSwga2V5LCB0aGlzKTtcblx0XHR9XG5cdH1cblxuXHRnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KFsuLi50aGlzLmVudHJpZXNBc2NlbmRpbmcoKV0pO1xuXHR9XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/quick-lru/index.js\n");

/***/ }),

/***/ "./node_modules/terriajs-tiff-imagery-provider/dist/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/terriajs-tiff-imagery-provider/dist/index.js ***!
  \*******************************************************************/
/*! exports provided: TIFFImageryProvider, colorscales, default, renderColorScaleToCanvas */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TIFFImageryProvider\", function() { return TIFFImageryProvider; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"colorscales\", function() { return colorscales; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return TIFFImageryProvider; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"renderColorScaleToCanvas\", function() { return renderColorScaleToCanvas; });\n/* harmony import */ var terriajs_cesium_Source_Core_Cartesian2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! terriajs-cesium/Source/Core/Cartesian2 */ \"./node_modules/terriajs-cesium/Source/Core/Cartesian2.js\");\n/* harmony import */ var terriajs_cesium_Source_Core_Cartesian2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(terriajs_cesium_Source_Core_Cartesian2__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var terriajs_cesium_Source_Core_Color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! terriajs-cesium/Source/Core/Color */ \"./node_modules/terriajs-cesium/Source/Core/Color.js\");\n/* harmony import */ var terriajs_cesium_Source_Core_Color__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(terriajs_cesium_Source_Core_Color__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var terriajs_cesium_Source_Core_Credit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! terriajs-cesium/Source/Core/Credit */ \"./node_modules/terriajs-cesium/Source/Core/Credit.js\");\n/* harmony import */ var terriajs_cesium_Source_Core_Credit__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(terriajs_cesium_Source_Core_Credit__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var terriajs_cesium_Source_Core_defined__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! terriajs-cesium/Source/Core/defined */ \"./node_modules/terriajs-cesium/Source/Core/defined.js\");\n/* harmony import */ var terriajs_cesium_Source_Core_defined__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(terriajs_cesium_Source_Core_defined__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var terriajs_cesium_Source_Core_DeveloperError__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! terriajs-cesium/Source/Core/DeveloperError */ \"./node_modules/terriajs-cesium/Source/Core/DeveloperError.js\");\n/* harmony import */ var terriajs_cesium_Source_Core_DeveloperError__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(terriajs_cesium_Source_Core_DeveloperError__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var terriajs_cesium_Source_Core_Event__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! terriajs-cesium/Source/Core/Event */ \"./node_modules/terriajs-cesium/Source/Core/Event.js\");\n/* harmony import */ var terriajs_cesium_Source_Core_Event__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(terriajs_cesium_Source_Core_Event__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var terriajs_cesium_Source_Core_GeographicTilingScheme__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! terriajs-cesium/Source/Core/GeographicTilingScheme */ \"./node_modules/terriajs-cesium/Source/Core/GeographicTilingScheme.js\");\n/* harmony import */ var terriajs_cesium_Source_Core_GeographicTilingScheme__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(terriajs_cesium_Source_Core_GeographicTilingScheme__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var terriajs_cesium_Source_Core_Math__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! terriajs-cesium/Source/Core/Math */ \"./node_modules/terriajs-cesium/Source/Core/Math.js\");\n/* harmony import */ var terriajs_cesium_Source_Core_Math__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(terriajs_cesium_Source_Core_Math__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var terriajs_cesium_Source_Core_Rectangle__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! terriajs-cesium/Source/Core/Rectangle */ \"./node_modules/terriajs-cesium/Source/Core/Rectangle.js\");\n/* harmony import */ var terriajs_cesium_Source_Core_Rectangle__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(terriajs_cesium_Source_Core_Rectangle__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var terriajs_cesium_Source_Core_WebMercatorTilingScheme__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! terriajs-cesium/Source/Core/WebMercatorTilingScheme */ \"./node_modules/terriajs-cesium/Source/Core/WebMercatorTilingScheme.js\");\n/* harmony import */ var terriajs_cesium_Source_Core_WebMercatorTilingScheme__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(terriajs_cesium_Source_Core_WebMercatorTilingScheme__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var terriajs_cesium_Source_Scene_ImageryLayerFeatureInfo__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! terriajs-cesium/Source/Scene/ImageryLayerFeatureInfo */ \"./node_modules/terriajs-cesium/Source/Scene/ImageryLayerFeatureInfo.js\");\n/* harmony import */ var terriajs_cesium_Source_Scene_ImageryLayerFeatureInfo__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(terriajs_cesium_Source_Scene_ImageryLayerFeatureInfo__WEBPACK_IMPORTED_MODULE_10__);\n/* harmony import */ var geotiff__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! geotiff */ \"./node_modules/geotiff/dist-module/geotiff.js\");\n/* harmony import */ var terriajs_cesium_Source_Core_Cartographic__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! terriajs-cesium/Source/Core/Cartographic */ \"./node_modules/terriajs-cesium/Source/Core/Cartographic.js\");\n/* harmony import */ var terriajs_cesium_Source_Core_Cartographic__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(terriajs_cesium_Source_Core_Cartographic__WEBPACK_IMPORTED_MODULE_12__);\n/* harmony import */ var terriajs_cesium_Source_Core_Cartesian3__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! terriajs-cesium/Source/Core/Cartesian3 */ \"./node_modules/terriajs-cesium/Source/Core/Cartesian3.js\");\n/* harmony import */ var terriajs_cesium_Source_Core_Cartesian3__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(terriajs_cesium_Source_Core_Cartesian3__WEBPACK_IMPORTED_MODULE_13__);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst colorscales = {\n  viridis: new Uint8Array([68, 1, 84, 255, 68, 2, 86, 255, 69, 4, 87, 255, 69, 5, 89, 255, 70, 7, 90, 255, 70, 8, 92, 255, 70, 10, 93, 255, 70, 11, 94, 255, 71, 13, 96, 255, 71, 14, 97, 255, 71, 16, 99, 255, 71, 17, 100, 255, 71, 19, 101, 255, 72, 20, 103, 255, 72, 22, 104, 255, 72, 23, 105, 255, 72, 24, 106, 255, 72, 26, 108, 255, 72, 27, 109, 255, 72, 28, 110, 255, 72, 29, 111, 255, 72, 31, 112, 255, 72, 32, 113, 255, 72, 33, 115, 255, 72, 35, 116, 255, 72, 36, 117, 255, 72, 37, 118, 255, 72, 38, 119, 255, 72, 40, 120, 255, 72, 41, 121, 255, 71, 42, 122, 255, 71, 44, 122, 255, 71, 45, 123, 255, 71, 46, 124, 255, 71, 47, 125, 255, 70, 48, 126, 255, 70, 50, 126, 255, 70, 51, 127, 255, 70, 52, 128, 255, 69, 53, 129, 255, 69, 55, 129, 255, 69, 56, 130, 255, 68, 57, 131, 255, 68, 58, 131, 255, 68, 59, 132, 255, 67, 61, 132, 255, 67, 62, 133, 255, 66, 63, 133, 255, 66, 64, 134, 255, 66, 65, 134, 255, 65, 66, 135, 255, 65, 68, 135, 255, 64, 69, 136, 255, 64, 70, 136, 255, 63, 71, 136, 255, 63, 72, 137, 255, 62, 73, 137, 255, 62, 74, 137, 255, 62, 76, 138, 255, 61, 77, 138, 255, 61, 78, 138, 255, 60, 79, 138, 255, 60, 80, 139, 255, 59, 81, 139, 255, 59, 82, 139, 255, 58, 83, 139, 255, 58, 84, 140, 255, 57, 85, 140, 255, 57, 86, 140, 255, 56, 88, 140, 255, 56, 89, 140, 255, 55, 90, 140, 255, 55, 91, 141, 255, 54, 92, 141, 255, 54, 93, 141, 255, 53, 94, 141, 255, 53, 95, 141, 255, 52, 96, 141, 255, 52, 97, 141, 255, 51, 98, 141, 255, 51, 99, 141, 255, 50, 100, 142, 255, 50, 101, 142, 255, 49, 102, 142, 255, 49, 103, 142, 255, 49, 104, 142, 255, 48, 105, 142, 255, 48, 106, 142, 255, 47, 107, 142, 255, 47, 108, 142, 255, 46, 109, 142, 255, 46, 110, 142, 255, 46, 111, 142, 255, 45, 112, 142, 255, 45, 113, 142, 255, 44, 113, 142, 255, 44, 114, 142, 255, 44, 115, 142, 255, 43, 116, 142, 255, 43, 117, 142, 255, 42, 118, 142, 255, 42, 119, 142, 255, 42, 120, 142, 255, 41, 121, 142, 255, 41, 122, 142, 255, 41, 123, 142, 255, 40, 124, 142, 255, 40, 125, 142, 255, 39, 126, 142, 255, 39, 127, 142, 255, 39, 128, 142, 255, 38, 129, 142, 255, 38, 130, 142, 255, 38, 130, 142, 255, 37, 131, 142, 255, 37, 132, 142, 255, 37, 133, 142, 255, 36, 134, 142, 255, 36, 135, 142, 255, 35, 136, 142, 255, 35, 137, 142, 255, 35, 138, 141, 255, 34, 139, 141, 255, 34, 140, 141, 255, 34, 141, 141, 255, 33, 142, 141, 255, 33, 143, 141, 255, 33, 144, 141, 255, 33, 145, 140, 255, 32, 146, 140, 255, 32, 146, 140, 255, 32, 147, 140, 255, 31, 148, 140, 255, 31, 149, 139, 255, 31, 150, 139, 255, 31, 151, 139, 255, 31, 152, 139, 255, 31, 153, 138, 255, 31, 154, 138, 255, 30, 155, 138, 255, 30, 156, 137, 255, 30, 157, 137, 255, 31, 158, 137, 255, 31, 159, 136, 255, 31, 160, 136, 255, 31, 161, 136, 255, 31, 161, 135, 255, 31, 162, 135, 255, 32, 163, 134, 255, 32, 164, 134, 255, 33, 165, 133, 255, 33, 166, 133, 255, 34, 167, 133, 255, 34, 168, 132, 255, 35, 169, 131, 255, 36, 170, 131, 255, 37, 171, 130, 255, 37, 172, 130, 255, 38, 173, 129, 255, 39, 173, 129, 255, 40, 174, 128, 255, 41, 175, 127, 255, 42, 176, 127, 255, 44, 177, 126, 255, 45, 178, 125, 255, 46, 179, 124, 255, 47, 180, 124, 255, 49, 181, 123, 255, 50, 182, 122, 255, 52, 182, 121, 255, 53, 183, 121, 255, 55, 184, 120, 255, 56, 185, 119, 255, 58, 186, 118, 255, 59, 187, 117, 255, 61, 188, 116, 255, 63, 188, 115, 255, 64, 189, 114, 255, 66, 190, 113, 255, 68, 191, 112, 255, 70, 192, 111, 255, 72, 193, 110, 255, 74, 193, 109, 255, 76, 194, 108, 255, 78, 195, 107, 255, 80, 196, 106, 255, 82, 197, 105, 255, 84, 197, 104, 255, 86, 198, 103, 255, 88, 199, 101, 255, 90, 200, 100, 255, 92, 200, 99, 255, 94, 201, 98, 255, 96, 202, 96, 255, 99, 203, 95, 255, 101, 203, 94, 255, 103, 204, 92, 255, 105, 205, 91, 255, 108, 205, 90, 255, 110, 206, 88, 255, 112, 207, 87, 255, 115, 208, 86, 255, 117, 208, 84, 255, 119, 209, 83, 255, 122, 209, 81, 255, 124, 210, 80, 255, 127, 211, 78, 255, 129, 211, 77, 255, 132, 212, 75, 255, 134, 213, 73, 255, 137, 213, 72, 255, 139, 214, 70, 255, 142, 214, 69, 255, 144, 215, 67, 255, 147, 215, 65, 255, 149, 216, 64, 255, 152, 216, 62, 255, 155, 217, 60, 255, 157, 217, 59, 255, 160, 218, 57, 255, 162, 218, 55, 255, 165, 219, 54, 255, 168, 219, 52, 255, 170, 220, 50, 255, 173, 220, 48, 255, 176, 221, 47, 255, 178, 221, 45, 255, 181, 222, 43, 255, 184, 222, 41, 255, 186, 222, 40, 255, 189, 223, 38, 255, 192, 223, 37, 255, 194, 223, 35, 255, 197, 224, 33, 255, 200, 224, 32, 255, 202, 225, 31, 255, 205, 225, 29, 255, 208, 225, 28, 255, 210, 226, 27, 255, 213, 226, 26, 255, 216, 226, 25, 255, 218, 227, 25, 255, 221, 227, 24, 255, 223, 227, 24, 255, 226, 228, 24, 255, 229, 228, 25, 255, 231, 228, 25, 255, 234, 229, 26, 255, 236, 229, 27, 255, 239, 229, 28, 255, 241, 229, 29, 255, 244, 230, 30, 255, 246, 230, 32, 255, 248, 230, 33, 255, 251, 231, 35, 255, 253, 231, 37, 255]),\n  inferno: new Uint8Array([0, 0, 4, 255, 1, 0, 5, 255, 1, 1, 6, 255, 1, 1, 8, 255, 2, 1, 10, 255, 2, 2, 12, 255, 2, 2, 14, 255, 3, 2, 16, 255, 4, 3, 18, 255, 4, 3, 20, 255, 5, 4, 23, 255, 6, 4, 25, 255, 7, 5, 27, 255, 8, 5, 29, 255, 9, 6, 31, 255, 10, 7, 34, 255, 11, 7, 36, 255, 12, 8, 38, 255, 13, 8, 41, 255, 14, 9, 43, 255, 16, 9, 45, 255, 17, 10, 48, 255, 18, 10, 50, 255, 20, 11, 52, 255, 21, 11, 55, 255, 22, 11, 57, 255, 24, 12, 60, 255, 25, 12, 62, 255, 27, 12, 65, 255, 28, 12, 67, 255, 30, 12, 69, 255, 31, 12, 72, 255, 33, 12, 74, 255, 35, 12, 76, 255, 36, 12, 79, 255, 38, 12, 81, 255, 40, 11, 83, 255, 41, 11, 85, 255, 43, 11, 87, 255, 45, 11, 89, 255, 47, 10, 91, 255, 49, 10, 92, 255, 50, 10, 94, 255, 52, 10, 95, 255, 54, 9, 97, 255, 56, 9, 98, 255, 57, 9, 99, 255, 59, 9, 100, 255, 61, 9, 101, 255, 62, 9, 102, 255, 64, 10, 103, 255, 66, 10, 104, 255, 68, 10, 104, 255, 69, 10, 105, 255, 71, 11, 106, 255, 73, 11, 106, 255, 74, 12, 107, 255, 76, 12, 107, 255, 77, 13, 108, 255, 79, 13, 108, 255, 81, 14, 108, 255, 82, 14, 109, 255, 84, 15, 109, 255, 85, 15, 109, 255, 87, 16, 110, 255, 89, 16, 110, 255, 90, 17, 110, 255, 92, 18, 110, 255, 93, 18, 110, 255, 95, 19, 110, 255, 97, 19, 110, 255, 98, 20, 110, 255, 100, 21, 110, 255, 101, 21, 110, 255, 103, 22, 110, 255, 105, 22, 110, 255, 106, 23, 110, 255, 108, 24, 110, 255, 109, 24, 110, 255, 111, 25, 110, 255, 113, 25, 110, 255, 114, 26, 110, 255, 116, 26, 110, 255, 117, 27, 110, 255, 119, 28, 109, 255, 120, 28, 109, 255, 122, 29, 109, 255, 124, 29, 109, 255, 125, 30, 109, 255, 127, 30, 108, 255, 128, 31, 108, 255, 130, 32, 108, 255, 132, 32, 107, 255, 133, 33, 107, 255, 135, 33, 107, 255, 136, 34, 106, 255, 138, 34, 106, 255, 140, 35, 105, 255, 141, 35, 105, 255, 143, 36, 105, 255, 144, 37, 104, 255, 146, 37, 104, 255, 147, 38, 103, 255, 149, 38, 103, 255, 151, 39, 102, 255, 152, 39, 102, 255, 154, 40, 101, 255, 155, 41, 100, 255, 157, 41, 100, 255, 159, 42, 99, 255, 160, 42, 99, 255, 162, 43, 98, 255, 163, 44, 97, 255, 165, 44, 96, 255, 166, 45, 96, 255, 168, 46, 95, 255, 169, 46, 94, 255, 171, 47, 94, 255, 173, 48, 93, 255, 174, 48, 92, 255, 176, 49, 91, 255, 177, 50, 90, 255, 179, 50, 90, 255, 180, 51, 89, 255, 182, 52, 88, 255, 183, 53, 87, 255, 185, 53, 86, 255, 186, 54, 85, 255, 188, 55, 84, 255, 189, 56, 83, 255, 191, 57, 82, 255, 192, 58, 81, 255, 193, 58, 80, 255, 195, 59, 79, 255, 196, 60, 78, 255, 198, 61, 77, 255, 199, 62, 76, 255, 200, 63, 75, 255, 202, 64, 74, 255, 203, 65, 73, 255, 204, 66, 72, 255, 206, 67, 71, 255, 207, 68, 70, 255, 208, 69, 69, 255, 210, 70, 68, 255, 211, 71, 67, 255, 212, 72, 66, 255, 213, 74, 65, 255, 215, 75, 63, 255, 216, 76, 62, 255, 217, 77, 61, 255, 218, 78, 60, 255, 219, 80, 59, 255, 221, 81, 58, 255, 222, 82, 56, 255, 223, 83, 55, 255, 224, 85, 54, 255, 225, 86, 53, 255, 226, 87, 52, 255, 227, 89, 51, 255, 228, 90, 49, 255, 229, 92, 48, 255, 230, 93, 47, 255, 231, 94, 46, 255, 232, 96, 45, 255, 233, 97, 43, 255, 234, 99, 42, 255, 235, 100, 41, 255, 235, 102, 40, 255, 236, 103, 38, 255, 237, 105, 37, 255, 238, 106, 36, 255, 239, 108, 35, 255, 239, 110, 33, 255, 240, 111, 32, 255, 241, 113, 31, 255, 241, 115, 29, 255, 242, 116, 28, 255, 243, 118, 27, 255, 243, 120, 25, 255, 244, 121, 24, 255, 245, 123, 23, 255, 245, 125, 21, 255, 246, 126, 20, 255, 246, 128, 19, 255, 247, 130, 18, 255, 247, 132, 16, 255, 248, 133, 15, 255, 248, 135, 14, 255, 248, 137, 12, 255, 249, 139, 11, 255, 249, 140, 10, 255, 249, 142, 9, 255, 250, 144, 8, 255, 250, 146, 7, 255, 250, 148, 7, 255, 251, 150, 6, 255, 251, 151, 6, 255, 251, 153, 6, 255, 251, 155, 6, 255, 251, 157, 7, 255, 252, 159, 7, 255, 252, 161, 8, 255, 252, 163, 9, 255, 252, 165, 10, 255, 252, 166, 12, 255, 252, 168, 13, 255, 252, 170, 15, 255, 252, 172, 17, 255, 252, 174, 18, 255, 252, 176, 20, 255, 252, 178, 22, 255, 252, 180, 24, 255, 251, 182, 26, 255, 251, 184, 29, 255, 251, 186, 31, 255, 251, 188, 33, 255, 251, 190, 35, 255, 250, 192, 38, 255, 250, 194, 40, 255, 250, 196, 42, 255, 250, 198, 45, 255, 249, 199, 47, 255, 249, 201, 50, 255, 249, 203, 53, 255, 248, 205, 55, 255, 248, 207, 58, 255, 247, 209, 61, 255, 247, 211, 64, 255, 246, 213, 67, 255, 246, 215, 70, 255, 245, 217, 73, 255, 245, 219, 76, 255, 244, 221, 79, 255, 244, 223, 83, 255, 244, 225, 86, 255, 243, 227, 90, 255, 243, 229, 93, 255, 242, 230, 97, 255, 242, 232, 101, 255, 242, 234, 105, 255, 241, 236, 109, 255, 241, 237, 113, 255, 241, 239, 117, 255, 241, 241, 121, 255, 242, 242, 125, 255, 242, 244, 130, 255, 243, 245, 134, 255, 243, 246, 138, 255, 244, 248, 142, 255, 245, 249, 146, 255, 246, 250, 150, 255, 248, 251, 154, 255, 249, 252, 157, 255, 250, 253, 161, 255, 252, 255, 164, 255]),\n  turbo: new Uint8Array([48, 18, 59, 255, 50, 21, 67, 255, 51, 24, 74, 255, 52, 27, 81, 255, 53, 30, 88, 255, 54, 33, 95, 255, 55, 36, 102, 255, 56, 39, 109, 255, 57, 42, 115, 255, 58, 45, 121, 255, 59, 47, 128, 255, 60, 50, 134, 255, 61, 53, 139, 255, 62, 56, 145, 255, 63, 59, 151, 255, 63, 62, 156, 255, 64, 64, 162, 255, 65, 67, 167, 255, 65, 70, 172, 255, 66, 73, 177, 255, 66, 75, 181, 255, 67, 78, 186, 255, 68, 81, 191, 255, 68, 84, 195, 255, 68, 86, 199, 255, 69, 89, 203, 255, 69, 92, 207, 255, 69, 94, 211, 255, 70, 97, 214, 255, 70, 100, 218, 255, 70, 102, 221, 255, 70, 105, 224, 255, 70, 107, 227, 255, 71, 110, 230, 255, 71, 113, 233, 255, 71, 115, 235, 255, 71, 118, 238, 255, 71, 120, 240, 255, 71, 123, 242, 255, 70, 125, 244, 255, 70, 128, 246, 255, 70, 130, 248, 255, 70, 133, 250, 255, 70, 135, 251, 255, 69, 138, 252, 255, 69, 140, 253, 255, 68, 143, 254, 255, 67, 145, 254, 255, 66, 148, 255, 255, 65, 150, 255, 255, 64, 153, 255, 255, 62, 155, 254, 255, 61, 158, 254, 255, 59, 160, 253, 255, 58, 163, 252, 255, 56, 165, 251, 255, 55, 168, 250, 255, 53, 171, 248, 255, 51, 173, 247, 255, 49, 175, 245, 255, 47, 178, 244, 255, 46, 180, 242, 255, 44, 183, 240, 255, 42, 185, 238, 255, 40, 188, 235, 255, 39, 190, 233, 255, 37, 192, 231, 255, 35, 195, 228, 255, 34, 197, 226, 255, 32, 199, 223, 255, 31, 201, 221, 255, 30, 203, 218, 255, 28, 205, 216, 255, 27, 208, 213, 255, 26, 210, 210, 255, 26, 212, 208, 255, 25, 213, 205, 255, 24, 215, 202, 255, 24, 217, 200, 255, 24, 219, 197, 255, 24, 221, 194, 255, 24, 222, 192, 255, 24, 224, 189, 255, 25, 226, 187, 255, 25, 227, 185, 255, 26, 228, 182, 255, 28, 230, 180, 255, 29, 231, 178, 255, 31, 233, 175, 255, 32, 234, 172, 255, 34, 235, 170, 255, 37, 236, 167, 255, 39, 238, 164, 255, 42, 239, 161, 255, 44, 240, 158, 255, 47, 241, 155, 255, 50, 242, 152, 255, 53, 243, 148, 255, 56, 244, 145, 255, 60, 245, 142, 255, 63, 246, 138, 255, 67, 247, 135, 255, 70, 248, 132, 255, 74, 248, 128, 255, 78, 249, 125, 255, 82, 250, 122, 255, 85, 250, 118, 255, 89, 251, 115, 255, 93, 252, 111, 255, 97, 252, 108, 255, 101, 253, 105, 255, 105, 253, 102, 255, 109, 254, 98, 255, 113, 254, 95, 255, 117, 254, 92, 255, 121, 254, 89, 255, 125, 255, 86, 255, 128, 255, 83, 255, 132, 255, 81, 255, 136, 255, 78, 255, 139, 255, 75, 255, 143, 255, 73, 255, 146, 255, 71, 255, 150, 254, 68, 255, 153, 254, 66, 255, 156, 254, 64, 255, 159, 253, 63, 255, 161, 253, 61, 255, 164, 252, 60, 255, 167, 252, 58, 255, 169, 251, 57, 255, 172, 251, 56, 255, 175, 250, 55, 255, 177, 249, 54, 255, 180, 248, 54, 255, 183, 247, 53, 255, 185, 246, 53, 255, 188, 245, 52, 255, 190, 244, 52, 255, 193, 243, 52, 255, 195, 241, 52, 255, 198, 240, 52, 255, 200, 239, 52, 255, 203, 237, 52, 255, 205, 236, 52, 255, 208, 234, 52, 255, 210, 233, 53, 255, 212, 231, 53, 255, 215, 229, 53, 255, 217, 228, 54, 255, 219, 226, 54, 255, 221, 224, 55, 255, 223, 223, 55, 255, 225, 221, 55, 255, 227, 219, 56, 255, 229, 217, 56, 255, 231, 215, 57, 255, 233, 213, 57, 255, 235, 211, 57, 255, 236, 209, 58, 255, 238, 207, 58, 255, 239, 205, 58, 255, 241, 203, 58, 255, 242, 201, 58, 255, 244, 199, 58, 255, 245, 197, 58, 255, 246, 195, 58, 255, 247, 193, 58, 255, 248, 190, 57, 255, 249, 188, 57, 255, 250, 186, 57, 255, 251, 184, 56, 255, 251, 182, 55, 255, 252, 179, 54, 255, 252, 177, 54, 255, 253, 174, 53, 255, 253, 172, 52, 255, 254, 169, 51, 255, 254, 167, 50, 255, 254, 164, 49, 255, 254, 161, 48, 255, 254, 158, 47, 255, 254, 155, 45, 255, 254, 153, 44, 255, 254, 150, 43, 255, 254, 147, 42, 255, 254, 144, 41, 255, 253, 141, 39, 255, 253, 138, 38, 255, 252, 135, 37, 255, 252, 132, 35, 255, 251, 129, 34, 255, 251, 126, 33, 255, 250, 123, 31, 255, 249, 120, 30, 255, 249, 117, 29, 255, 248, 114, 28, 255, 247, 111, 26, 255, 246, 108, 25, 255, 245, 105, 24, 255, 244, 102, 23, 255, 243, 99, 21, 255, 242, 96, 20, 255, 241, 93, 19, 255, 240, 91, 18, 255, 239, 88, 17, 255, 237, 85, 16, 255, 236, 83, 15, 255, 235, 80, 14, 255, 234, 78, 13, 255, 232, 75, 12, 255, 231, 73, 12, 255, 229, 71, 11, 255, 228, 69, 10, 255, 226, 67, 10, 255, 225, 65, 9, 255, 223, 63, 8, 255, 221, 61, 8, 255, 220, 59, 7, 255, 218, 57, 7, 255, 216, 55, 6, 255, 214, 53, 6, 255, 212, 51, 5, 255, 210, 49, 5, 255, 208, 47, 5, 255, 206, 45, 4, 255, 204, 43, 4, 255, 202, 42, 4, 255, 200, 40, 3, 255, 197, 38, 3, 255, 195, 37, 3, 255, 193, 35, 2, 255, 190, 33, 2, 255, 188, 32, 2, 255, 185, 30, 2, 255, 183, 29, 2, 255, 180, 27, 1, 255, 178, 26, 1, 255, 175, 24, 1, 255, 172, 23, 1, 255, 169, 22, 1, 255, 167, 20, 1, 255, 164, 19, 1, 255, 161, 18, 1, 255, 158, 16, 1, 255, 155, 15, 1, 255, 152, 14, 1, 255, 149, 13, 1, 255, 146, 11, 1, 255, 142, 10, 1, 255, 139, 9, 2, 255, 136, 8, 2, 255, 133, 7, 2, 255, 129, 6, 2, 255, 126, 5, 2, 255, 122, 4, 3, 255]),\n  rainbow: {\n    colors: [\"#96005A\", \"#0000C8\", \"#0019FF\", \"#0098FF\", \"#2CFF96\", \"#97FF00\", \"#FFEA00\", \"#FF6F00\", \"#FF0000\"],\n    positions: [0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1]\n  },\n  jet: {\n    colors: [\"#000083\", \"#003CAA\", \"#05FFFF\", \"#FFFF00\", \"#FA0000\", \"#800000\"],\n    positions: [0, 0.125, 0.375, 0.625, 0.875, 1]\n  },\n  hsv: {\n    colors: [\"#ff0000\", \"#fdff02\", \"#f7ff02\", \"#00fc04\", \"#00fc0a\", \"#01f9ff\", \"#0200fd\", \"#0800fd\", \"#ff00fb\", \"#ff00f5\", \"#ff0006\"],\n    positions: [0, 0.169, 0.173, 0.337, 0.341, 0.506, 0.671, 0.675, 0.839, 0.843, 1]\n  },\n  hot: {\n    colors: [\"#000000\", \"#e60000\", \"#ffd200\", \"#ffffff\"],\n    positions: [0, 0.3, 0.6, 1]\n  },\n  cool: {\n    colors: [\"#00ffff\", \"#ff00ff\"],\n    positions: [0, 1]\n  },\n  spring: {\n    colors: [\"#ff00ff\", \"#ffff00\"],\n    positions: [0, 1]\n  },\n  summer: {\n    colors: [\"#008066\", \"#ffff66\"],\n    positions: [0, 1]\n  },\n  autumn: {\n    colors: [\"#ff0000\", \"#ffff00\"],\n    positions: [0, 1]\n  },\n  winter: {\n    colors: [\"#0000ff\", \"#00ff80\"],\n    positions: [0, 1]\n  },\n  bone: {\n    colors: [\"#000000\", \"#545474\", \"#a9c8c8\", \"#ffffff\"],\n    positions: [0, 0.376, 0.753, 1]\n  },\n  copper: {\n    colors: [\"#000000\", \"#ffa066\", \"#ffc77f\"],\n    positions: [0, 0.804, 1]\n  },\n  greys: {\n    colors: [\"#000000\", \"#ffffff\"],\n    positions: [0, 1]\n  },\n  ylgnbu: {\n    colors: [\"#081d58\", \"#253494\", \"#225ea8\", \"#1d91c0\", \"#41b6c4\", \"#7fcdbb\", \"#c7e9b4\", \"#edf8d9\", \"#ffffd9\"],\n    positions: [0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1]\n  },\n  greens: {\n    colors: [\"#00441b\", \"#006d2c\", \"#238b45\", \"#41ab5d\", \"#74c476\", \"#a1d99b\", \"#c7e9c0\", \"#e5f5e0\", \"#f7fcf5\"],\n    positions: [0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1]\n  },\n  ylorrd: {\n    colors: [\"#800026\", \"#bd0026\", \"#e31a1c\", \"#fc4e2a\", \"#fd8d3c\", \"#feb24c\", \"#fed976\", \"#ffeda0\", \"#ffffcc\"],\n    positions: [0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1]\n  },\n  bluered: {\n    colors: [\"#0000ff\", \"#ff0000\"],\n    positions: [0, 1]\n  },\n  rdbu: {\n    colors: [\"#050aac\", \"#6a89f7\", \"#bebebe\", \"#dcaa84\", \"#e6915a\", \"#b20a1c\"],\n    positions: [0, 0.35, 0.5, 0.6, 0.7, 1]\n  },\n  picnic: {\n    colors: [\"#0000ff\", \"#3399ff\", \"#66ccff\", \"#99ccff\", \"#ccccff\", \"#ffffff\", \"#ffccff\", \"#ff99ff\", \"#ff66cc\", \"#ff6666\", \"#ff0000\"],\n    positions: [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]\n  },\n  portland: {\n    colors: [\"#0c3383\", \"#0a88ba\", \"#f2d338\", \"#f28f38\", \"#d91e1e\"],\n    positions: [0, 0.25, 0.5, 0.75, 1]\n  },\n  blackbody: {\n    colors: [\"#000000\", \"#e60000\", \"#e6d200\", \"#ffffff\", \"#a0c8ff\"],\n    positions: [0, 0.2, 0.4, 0.7, 1]\n  },\n  earth: {\n    colors: [\"#000082\", \"#00b4b4\", \"#28d228\", \"#e6e632\", \"#784614\", \"#ffffff\"],\n    positions: [0, 0.1, 0.2, 0.4, 0.6, 1]\n  },\n  electric: {\n    colors: [\"#000000\", \"#1e0064\", \"#780064\", \"#a05a00\", \"#e6c800\", \"#fffadc\"],\n    positions: [0, 0.15, 0.4, 0.6, 0.8, 1]\n  },\n  magma: new Uint8Array([0, 0, 4, 255, 1, 0, 5, 255, 1, 1, 6, 255, 1, 1, 8, 255, 2, 1, 9, 255, 2, 2, 11, 255, 2, 2, 13, 255, 3, 3, 15, 255, 3, 3, 18, 255, 4, 4, 20, 255, 5, 4, 22, 255, 6, 5, 24, 255, 6, 5, 26, 255, 7, 6, 28, 255, 8, 7, 30, 255, 9, 7, 32, 255, 10, 8, 34, 255, 11, 9, 36, 255, 12, 9, 38, 255, 13, 10, 41, 255, 14, 11, 43, 255, 16, 11, 45, 255, 17, 12, 47, 255, 18, 13, 49, 255, 19, 13, 52, 255, 20, 14, 54, 255, 21, 14, 56, 255, 22, 15, 59, 255, 24, 15, 61, 255, 25, 16, 63, 255, 26, 16, 66, 255, 28, 16, 68, 255, 29, 17, 71, 255, 30, 17, 73, 255, 32, 17, 75, 255, 33, 17, 78, 255, 34, 17, 80, 255, 36, 18, 83, 255, 37, 18, 85, 255, 39, 18, 88, 255, 41, 17, 90, 255, 42, 17, 92, 255, 44, 17, 95, 255, 45, 17, 97, 255, 47, 17, 99, 255, 49, 17, 101, 255, 51, 16, 103, 255, 52, 16, 105, 255, 54, 16, 107, 255, 56, 16, 108, 255, 57, 15, 110, 255, 59, 15, 112, 255, 61, 15, 113, 255, 63, 15, 114, 255, 64, 15, 116, 255, 66, 15, 117, 255, 68, 15, 118, 255, 69, 16, 119, 255, 71, 16, 120, 255, 73, 16, 120, 255, 74, 16, 121, 255, 76, 17, 122, 255, 78, 17, 123, 255, 79, 18, 123, 255, 81, 18, 124, 255, 82, 19, 124, 255, 84, 19, 125, 255, 86, 20, 125, 255, 87, 21, 126, 255, 89, 21, 126, 255, 90, 22, 126, 255, 92, 22, 127, 255, 93, 23, 127, 255, 95, 24, 127, 255, 96, 24, 128, 255, 98, 25, 128, 255, 100, 26, 128, 255, 101, 26, 128, 255, 103, 27, 128, 255, 104, 28, 129, 255, 106, 28, 129, 255, 107, 29, 129, 255, 109, 29, 129, 255, 110, 30, 129, 255, 112, 31, 129, 255, 114, 31, 129, 255, 115, 32, 129, 255, 117, 33, 129, 255, 118, 33, 129, 255, 120, 34, 129, 255, 121, 34, 130, 255, 123, 35, 130, 255, 124, 35, 130, 255, 126, 36, 130, 255, 128, 37, 130, 255, 129, 37, 129, 255, 131, 38, 129, 255, 132, 38, 129, 255, 134, 39, 129, 255, 136, 39, 129, 255, 137, 40, 129, 255, 139, 41, 129, 255, 140, 41, 129, 255, 142, 42, 129, 255, 144, 42, 129, 255, 145, 43, 129, 255, 147, 43, 128, 255, 148, 44, 128, 255, 150, 44, 128, 255, 152, 45, 128, 255, 153, 45, 128, 255, 155, 46, 127, 255, 156, 46, 127, 255, 158, 47, 127, 255, 160, 47, 127, 255, 161, 48, 126, 255, 163, 48, 126, 255, 165, 49, 126, 255, 166, 49, 125, 255, 168, 50, 125, 255, 170, 51, 125, 255, 171, 51, 124, 255, 173, 52, 124, 255, 174, 52, 123, 255, 176, 53, 123, 255, 178, 53, 123, 255, 179, 54, 122, 255, 181, 54, 122, 255, 183, 55, 121, 255, 184, 55, 121, 255, 186, 56, 120, 255, 188, 57, 120, 255, 189, 57, 119, 255, 191, 58, 119, 255, 192, 58, 118, 255, 194, 59, 117, 255, 196, 60, 117, 255, 197, 60, 116, 255, 199, 61, 115, 255, 200, 62, 115, 255, 202, 62, 114, 255, 204, 63, 113, 255, 205, 64, 113, 255, 207, 64, 112, 255, 208, 65, 111, 255, 210, 66, 111, 255, 211, 67, 110, 255, 213, 68, 109, 255, 214, 69, 108, 255, 216, 69, 108, 255, 217, 70, 107, 255, 219, 71, 106, 255, 220, 72, 105, 255, 222, 73, 104, 255, 223, 74, 104, 255, 224, 76, 103, 255, 226, 77, 102, 255, 227, 78, 101, 255, 228, 79, 100, 255, 229, 80, 100, 255, 231, 82, 99, 255, 232, 83, 98, 255, 233, 84, 98, 255, 234, 86, 97, 255, 235, 87, 96, 255, 236, 88, 96, 255, 237, 90, 95, 255, 238, 91, 94, 255, 239, 93, 94, 255, 240, 95, 94, 255, 241, 96, 93, 255, 242, 98, 93, 255, 242, 100, 92, 255, 243, 101, 92, 255, 244, 103, 92, 255, 244, 105, 92, 255, 245, 107, 92, 255, 246, 108, 92, 255, 246, 110, 92, 255, 247, 112, 92, 255, 247, 114, 92, 255, 248, 116, 92, 255, 248, 118, 92, 255, 249, 120, 93, 255, 249, 121, 93, 255, 249, 123, 93, 255, 250, 125, 94, 255, 250, 127, 94, 255, 250, 129, 95, 255, 251, 131, 95, 255, 251, 133, 96, 255, 251, 135, 97, 255, 252, 137, 97, 255, 252, 138, 98, 255, 252, 140, 99, 255, 252, 142, 100, 255, 252, 144, 101, 255, 253, 146, 102, 255, 253, 148, 103, 255, 253, 150, 104, 255, 253, 152, 105, 255, 253, 154, 106, 255, 253, 155, 107, 255, 254, 157, 108, 255, 254, 159, 109, 255, 254, 161, 110, 255, 254, 163, 111, 255, 254, 165, 113, 255, 254, 167, 114, 255, 254, 169, 115, 255, 254, 170, 116, 255, 254, 172, 118, 255, 254, 174, 119, 255, 254, 176, 120, 255, 254, 178, 122, 255, 254, 180, 123, 255, 254, 182, 124, 255, 254, 183, 126, 255, 254, 185, 127, 255, 254, 187, 129, 255, 254, 189, 130, 255, 254, 191, 132, 255, 254, 193, 133, 255, 254, 194, 135, 255, 254, 196, 136, 255, 254, 198, 138, 255, 254, 200, 140, 255, 254, 202, 141, 255, 254, 204, 143, 255, 254, 205, 144, 255, 254, 207, 146, 255, 254, 209, 148, 255, 254, 211, 149, 255, 254, 213, 151, 255, 254, 215, 153, 255, 254, 216, 154, 255, 253, 218, 156, 255, 253, 220, 158, 255, 253, 222, 160, 255, 253, 224, 161, 255, 253, 226, 163, 255, 253, 227, 165, 255, 253, 229, 167, 255, 253, 231, 169, 255, 253, 233, 170, 255, 253, 235, 172, 255, 252, 236, 174, 255, 252, 238, 176, 255, 252, 240, 178, 255, 252, 242, 180, 255, 252, 244, 182, 255, 252, 246, 184, 255, 252, 247, 185, 255, 252, 249, 187, 255, 252, 251, 189, 255, 252, 253, 191, 255]),\n  plasma: new Uint8Array([13, 8, 135, 255, 16, 7, 136, 255, 19, 7, 137, 255, 22, 7, 138, 255, 25, 6, 140, 255, 27, 6, 141, 255, 29, 6, 142, 255, 32, 6, 143, 255, 34, 6, 144, 255, 36, 6, 145, 255, 38, 5, 145, 255, 40, 5, 146, 255, 42, 5, 147, 255, 44, 5, 148, 255, 46, 5, 149, 255, 47, 5, 150, 255, 49, 5, 151, 255, 51, 5, 151, 255, 53, 4, 152, 255, 55, 4, 153, 255, 56, 4, 154, 255, 58, 4, 154, 255, 60, 4, 155, 255, 62, 4, 156, 255, 63, 4, 156, 255, 65, 4, 157, 255, 67, 3, 158, 255, 68, 3, 158, 255, 70, 3, 159, 255, 72, 3, 159, 255, 73, 3, 160, 255, 75, 3, 161, 255, 76, 2, 161, 255, 78, 2, 162, 255, 80, 2, 162, 255, 81, 2, 163, 255, 83, 2, 163, 255, 85, 2, 164, 255, 86, 1, 164, 255, 88, 1, 164, 255, 89, 1, 165, 255, 91, 1, 165, 255, 92, 1, 166, 255, 94, 1, 166, 255, 96, 1, 166, 255, 97, 0, 167, 255, 99, 0, 167, 255, 100, 0, 167, 255, 102, 0, 167, 255, 103, 0, 168, 255, 105, 0, 168, 255, 106, 0, 168, 255, 108, 0, 168, 255, 110, 0, 168, 255, 111, 0, 168, 255, 113, 0, 168, 255, 114, 1, 168, 255, 116, 1, 168, 255, 117, 1, 168, 255, 119, 1, 168, 255, 120, 1, 168, 255, 122, 2, 168, 255, 123, 2, 168, 255, 125, 3, 168, 255, 126, 3, 168, 255, 128, 4, 168, 255, 129, 4, 167, 255, 131, 5, 167, 255, 132, 5, 167, 255, 134, 6, 166, 255, 135, 7, 166, 255, 136, 8, 166, 255, 138, 9, 165, 255, 139, 10, 165, 255, 141, 11, 165, 255, 142, 12, 164, 255, 143, 13, 164, 255, 145, 14, 163, 255, 146, 15, 163, 255, 148, 16, 162, 255, 149, 17, 161, 255, 150, 19, 161, 255, 152, 20, 160, 255, 153, 21, 159, 255, 154, 22, 159, 255, 156, 23, 158, 255, 157, 24, 157, 255, 158, 25, 157, 255, 160, 26, 156, 255, 161, 27, 155, 255, 162, 29, 154, 255, 163, 30, 154, 255, 165, 31, 153, 255, 166, 32, 152, 255, 167, 33, 151, 255, 168, 34, 150, 255, 170, 35, 149, 255, 171, 36, 148, 255, 172, 38, 148, 255, 173, 39, 147, 255, 174, 40, 146, 255, 176, 41, 145, 255, 177, 42, 144, 255, 178, 43, 143, 255, 179, 44, 142, 255, 180, 46, 141, 255, 181, 47, 140, 255, 182, 48, 139, 255, 183, 49, 138, 255, 184, 50, 137, 255, 186, 51, 136, 255, 187, 52, 136, 255, 188, 53, 135, 255, 189, 55, 134, 255, 190, 56, 133, 255, 191, 57, 132, 255, 192, 58, 131, 255, 193, 59, 130, 255, 194, 60, 129, 255, 195, 61, 128, 255, 196, 62, 127, 255, 197, 64, 126, 255, 198, 65, 125, 255, 199, 66, 124, 255, 200, 67, 123, 255, 201, 68, 122, 255, 202, 69, 122, 255, 203, 70, 121, 255, 204, 71, 120, 255, 204, 73, 119, 255, 205, 74, 118, 255, 206, 75, 117, 255, 207, 76, 116, 255, 208, 77, 115, 255, 209, 78, 114, 255, 210, 79, 113, 255, 211, 81, 113, 255, 212, 82, 112, 255, 213, 83, 111, 255, 213, 84, 110, 255, 214, 85, 109, 255, 215, 86, 108, 255, 216, 87, 107, 255, 217, 88, 106, 255, 218, 90, 106, 255, 218, 91, 105, 255, 219, 92, 104, 255, 220, 93, 103, 255, 221, 94, 102, 255, 222, 95, 101, 255, 222, 97, 100, 255, 223, 98, 99, 255, 224, 99, 99, 255, 225, 100, 98, 255, 226, 101, 97, 255, 226, 102, 96, 255, 227, 104, 95, 255, 228, 105, 94, 255, 229, 106, 93, 255, 229, 107, 93, 255, 230, 108, 92, 255, 231, 110, 91, 255, 231, 111, 90, 255, 232, 112, 89, 255, 233, 113, 88, 255, 233, 114, 87, 255, 234, 116, 87, 255, 235, 117, 86, 255, 235, 118, 85, 255, 236, 119, 84, 255, 237, 121, 83, 255, 237, 122, 82, 255, 238, 123, 81, 255, 239, 124, 81, 255, 239, 126, 80, 255, 240, 127, 79, 255, 240, 128, 78, 255, 241, 129, 77, 255, 241, 131, 76, 255, 242, 132, 75, 255, 243, 133, 75, 255, 243, 135, 74, 255, 244, 136, 73, 255, 244, 137, 72, 255, 245, 139, 71, 255, 245, 140, 70, 255, 246, 141, 69, 255, 246, 143, 68, 255, 247, 144, 68, 255, 247, 145, 67, 255, 247, 147, 66, 255, 248, 148, 65, 255, 248, 149, 64, 255, 249, 151, 63, 255, 249, 152, 62, 255, 249, 154, 62, 255, 250, 155, 61, 255, 250, 156, 60, 255, 250, 158, 59, 255, 251, 159, 58, 255, 251, 161, 57, 255, 251, 162, 56, 255, 252, 163, 56, 255, 252, 165, 55, 255, 252, 166, 54, 255, 252, 168, 53, 255, 252, 169, 52, 255, 253, 171, 51, 255, 253, 172, 51, 255, 253, 174, 50, 255, 253, 175, 49, 255, 253, 177, 48, 255, 253, 178, 47, 255, 253, 180, 47, 255, 253, 181, 46, 255, 254, 183, 45, 255, 254, 184, 44, 255, 254, 186, 44, 255, 254, 187, 43, 255, 254, 189, 42, 255, 254, 190, 42, 255, 254, 192, 41, 255, 253, 194, 41, 255, 253, 195, 40, 255, 253, 197, 39, 255, 253, 198, 39, 255, 253, 200, 39, 255, 253, 202, 38, 255, 253, 203, 38, 255, 252, 205, 37, 255, 252, 206, 37, 255, 252, 208, 37, 255, 252, 210, 37, 255, 251, 211, 36, 255, 251, 213, 36, 255, 251, 215, 36, 255, 250, 216, 36, 255, 250, 218, 36, 255, 249, 220, 36, 255, 249, 221, 37, 255, 248, 223, 37, 255, 248, 225, 37, 255, 247, 226, 37, 255, 247, 228, 37, 255, 246, 230, 38, 255, 246, 232, 38, 255, 245, 233, 38, 255, 245, 235, 39, 255, 244, 237, 39, 255, 243, 238, 39, 255, 243, 240, 39, 255, 242, 242, 39, 255, 241, 244, 38, 255, 241, 245, 37, 255, 240, 247, 36, 255, 240, 249, 33, 255]),\n  redblue: {\n    colors: [\"#ff0000\", \"#0000ff\"],\n    positions: [0, 1]\n  },\n  coolwarm: {\n    colors: [\"#0000ff\", \"#ffffff\", \"#ff0000\"],\n    positions: [0, 0.5, 1]\n  },\n  diverging_1: {\n    colors: [\"#400040\", \"#3b004d\", \"#36005b\", \"#320068\", \"#2d0076\", \"#290084\", \"#240091\", \"#20009f\", \"#1b00ad\", \"#1600ba\", \"#1200c8\", \"#0d00d6\", \"#0900e3\", \"#0400f1\", \"#0000ff\", \"#0217ff\", \"#042eff\", \"#0645ff\", \"#095cff\", \"#0b73ff\", \"#0d8bff\", \"#10a2ff\", \"#12b9ff\", \"#14d0ff\", \"#17e7ff\", \"#19ffff\", \"#3fffff\", \"#66ffff\", \"#8cffff\", \"#b2ffff\", \"#d8ffff\", \"#ffffff\", \"#ffffd4\", \"#ffffaa\", \"#ffff7f\", \"#ffff54\", \"#ffff2a\", \"#ffff00\", \"#ffed00\", \"#ffdd00\", \"#ffcc00\", \"#ffba00\", \"#ffaa00\", \"#ff9900\", \"#ff8700\", \"#ff7700\", \"#ff6600\", \"#ff5400\", \"#ff4400\", \"#ff3300\", \"#ff2100\", \"#ff1100\", \"#ff0000\", \"#ff0017\", \"#ff002e\", \"#ff0045\", \"#ff005c\", \"#ff0073\", \"#ff008b\", \"#ff00a2\", \"#ff00b9\", \"#ff00d0\", \"#ff00e7\", \"#ff00ff\"],\n    positions: [0, 0.01587301587, 0.03174603174, 0.04761904761, 0.06349206348, 0.07936507935, 0.09523809522, 0.11111111109, 0.12698412696, 0.14285714283, 0.1587301587, 0.17460317457, 0.19047619044, 0.20634920631, 0.22222222218, 0.23809523805, 0.25396825392, 0.26984126979, 0.28571428566, 0.30158730153, 0.3174603174, 0.33333333327, 0.34920634914, 0.36507936501, 0.38095238088, 0.39682539675, 0.41269841262, 0.42857142849, 0.44444444436, 0.46031746023, 0.4761904761, 0.49206349197, 0.50793650784, 0.52380952371, 0.53968253958, 0.55555555545, 0.57142857132, 0.58730158719, 0.60317460306, 0.61904761893, 0.6349206348, 0.65079365067, 0.66666666654, 0.68253968241, 0.69841269828, 0.71428571415, 0.73015873002, 0.74603174589, 0.76190476176, 0.77777777763, 0.7936507935, 0.80952380937, 0.82539682524, 0.84126984111, 0.85714285698, 0.87301587285, 0.88888888872, 0.90476190459, 0.92063492046, 0.93650793633, 0.9523809522, 0.96825396807, 0.98412698394, 1]\n  },\n  diverging_2: {\n    colors: [\"#000000\", \"#030aff\", \"#204aff\", \"#3c8aff\", \"#77c4ff\", \"#f0ffff\", \"#f0ffff\", \"#f2ff7f\", \"#ffff00\", \"#ff831e\", \"#ff083d\", \"#ff00ff\"],\n    positions: [0, 1e-10, 0.1, 0.2, 0.3333, 0.4666, 0.5333, 0.6666, 0.8, 0.9, 0.999999999999, 1]\n  },\n  blackwhite: {\n    colors: [\"#000000\", \"#ffffff\"],\n    positions: [0, 1]\n  },\n  twilight: {\n    colors: [\"#E2D9E2\", \"#E0D9E2\", \"#DDD9E0\", \"#DAD8DF\", \"#D6D7DD\", \"#D2D5DB\", \"#CDD3D8\", \"#C8D0D6\", \"#C2CED4\", \"#BCCBD1\", \"#B6C8CF\", \"#B0C5CD\", \"#AAC2CC\", \"#A4BECA\", \"#9EBBC9\", \"#99B8C8\", \"#93B4C6\", \"#8EB1C5\", \"#89ADC5\", \"#85A9C4\", \"#80A5C3\", \"#7CA2C2\", \"#789EC2\", \"#759AC1\", \"#7196C1\", \"#6E92C0\", \"#6C8EBF\", \"#698ABF\", \"#6786BE\", \"#6682BD\", \"#647DBC\", \"#6379BB\", \"#6275BA\", \"#6170B9\", \"#606CB8\", \"#6067B6\", \"#5F62B4\", \"#5F5EB3\", \"#5F59B1\", \"#5E54AE\", \"#5E4FAC\", \"#5E4BA9\", \"#5E46A6\", \"#5D41A3\", \"#5D3CA0\", \"#5C379C\", \"#5B3298\", \"#5A2E93\", \"#59298E\", \"#572588\", \"#562182\", \"#531E7C\", \"#511A75\", \"#4E186F\", \"#4B1668\", \"#471461\", \"#44135A\", \"#411254\", \"#3D114E\", \"#3A1149\", \"#371144\", \"#351140\", \"#33113C\", \"#311339\", \"#301437\", \"#331237\", \"#351138\", \"#381139\", \"#3B113B\", \"#3F123D\", \"#43123E\", \"#481341\", \"#4D1443\", \"#521545\", \"#571647\", \"#5C1749\", \"#61184B\", \"#67194C\", \"#6C1B4E\", \"#711D4F\", \"#761F4F\", \"#7B2150\", \"#802350\", \"#852650\", \"#8A2950\", \"#8E2C50\", \"#922F50\", \"#963350\", \"#9A3750\", \"#9E3B50\", \"#A13F50\", \"#A54350\", \"#A84750\", \"#AB4B50\", \"#AE5051\", \"#B15452\", \"#B35953\", \"#B65D54\", \"#B86255\", \"#BA6657\", \"#BC6B59\", \"#BE705B\", \"#C0755E\", \"#C27A61\", \"#C37F64\", \"#C58468\", \"#C6896C\", \"#C78E71\", \"#C89275\", \"#C9977B\", \"#CA9C80\", \"#CCA186\", \"#CDA68C\", \"#CEAB92\", \"#CFAF99\", \"#D1B4A0\", \"#D2B8A7\", \"#D4BDAD\", \"#D6C1B4\", \"#D8C5BB\", \"#D9C9C2\", \"#DBCCC8\", \"#DDD0CE\", \"#DED3D3\", \"#DFD5D8\", \"#E0D7DB\", \"#E1D8DF\", \"#E2D9E1\"],\n    positions: [0, 0.0078740157, 0.0157480315, 0.0236220472, 0.031496063, 0.0393700787, 0.0472440945, 0.0551181102, 0.062992126, 0.0708661417, 0.0787401575, 0.0866141732, 0.094488189, 0.1023622047, 0.1102362205, 0.1181102362, 0.125984252, 0.1338582677, 0.1417322835, 0.1496062992, 0.157480315, 0.1653543307, 0.1732283465, 0.1811023622, 0.188976378, 0.1968503937, 0.2047244094, 0.2125984252, 0.2204724409, 0.2283464567, 0.2362204724, 0.2440944882, 0.2519685039, 0.2598425197, 0.2677165354, 0.2755905512, 0.2834645669, 0.2913385827, 0.2992125984, 0.3070866142, 0.3149606299, 0.3228346457, 0.3307086614, 0.3385826772, 0.3464566929, 0.3543307087, 0.3622047244, 0.3700787402, 0.3779527559, 0.3858267717, 0.3937007874, 0.4015748031, 0.4094488189, 0.4173228346, 0.4251968504, 0.4330708661, 0.4409448819, 0.4488188976, 0.4566929134, 0.4645669291, 0.4724409449, 0.4803149606, 0.4881889764, 0.4960629921, 0.5039370079, 0.5118110236, 0.5196850394, 0.5275590551, 0.5354330709, 0.5433070866, 0.5511811024, 0.5590551181, 0.5669291339, 0.5748031496, 0.5826771654, 0.5905511811, 0.5984251969, 0.6062992126, 0.6141732283, 0.6220472441, 0.6299212598, 0.6377952756, 0.6456692913, 0.6535433071, 0.6614173228, 0.6692913386, 0.6771653543, 0.6850393701, 0.6929133858, 0.7007874016, 0.7086614173, 0.7165354331, 0.7244094488, 0.7322834646, 0.7401574803, 0.7480314961, 0.7559055118, 0.7637795276, 0.7716535433, 0.7795275591, 0.7874015748, 0.7952755906, 0.8031496063, 0.811023622, 0.8188976378, 0.8267716535, 0.8346456693, 0.842519685, 0.8503937008, 0.8582677165, 0.8661417323, 0.874015748, 0.8818897638, 0.8897637795, 0.8976377953, 0.905511811, 0.9133858268, 0.9212598425, 0.9291338583, 0.937007874, 0.9448818898, 0.9527559055, 0.9606299213, 0.968503937, 0.9763779528, 0.9842519685, 0.9921259843, 1]\n  },\n  twilight_shifted: {\n    colors: [\"#301437\", \"#32123A\", \"#34113E\", \"#361142\", \"#391146\", \"#3C114B\", \"#3F1251\", \"#421257\", \"#46145E\", \"#491564\", \"#4C176B\", \"#4F1972\", \"#521C79\", \"#551F7F\", \"#572385\", \"#58278B\", \"#5A2B90\", \"#5B3095\", \"#5C359A\", \"#5D3A9E\", \"#5D3EA1\", \"#5E43A5\", \"#5E48A8\", \"#5E4DAB\", \"#5E52AD\", \"#5F57B0\", \"#5F5BB2\", \"#5F60B4\", \"#5F65B5\", \"#6069B7\", \"#606EB8\", \"#6172BA\", \"#6277BB\", \"#637BBC\", \"#657FBD\", \"#6684BD\", \"#6888BE\", \"#6B8CBF\", \"#6D90C0\", \"#7094C0\", \"#7398C1\", \"#769CC1\", \"#7AA0C2\", \"#7EA4C3\", \"#82A7C3\", \"#87ABC4\", \"#8CAFC5\", \"#91B2C6\", \"#96B6C7\", \"#9CB9C8\", \"#A1BDC9\", \"#A7C0CB\", \"#ADC3CD\", \"#B3C6CE\", \"#B9C9D0\", \"#BFCCD3\", \"#C5CFD5\", \"#CBD2D7\", \"#D0D4D9\", \"#D4D6DC\", \"#D8D8DE\", \"#DCD9DF\", \"#DED9E1\", \"#E1D9E2\", \"#E2D9E1\", \"#E1D8DF\", \"#E0D7DB\", \"#DFD5D8\", \"#DED3D3\", \"#DDD0CE\", \"#DBCCC8\", \"#D9C9C2\", \"#D8C5BB\", \"#D6C1B4\", \"#D4BDAD\", \"#D2B8A7\", \"#D1B4A0\", \"#CFAF99\", \"#CEAB92\", \"#CDA68C\", \"#CCA186\", \"#CA9C80\", \"#C9977B\", \"#C89275\", \"#C78E71\", \"#C6896C\", \"#C58468\", \"#C37F64\", \"#C27A61\", \"#C0755E\", \"#BE705B\", \"#BC6B59\", \"#BA6657\", \"#B86255\", \"#B65D54\", \"#B35953\", \"#B15452\", \"#AE5051\", \"#AB4B50\", \"#A84750\", \"#A54350\", \"#A13F50\", \"#9E3B50\", \"#9A3750\", \"#963350\", \"#922F50\", \"#8E2C50\", \"#8A2950\", \"#852650\", \"#802350\", \"#7B2150\", \"#761F4F\", \"#711D4F\", \"#6C1B4E\", \"#67194C\", \"#61184B\", \"#5C1749\", \"#571647\", \"#521545\", \"#4D1443\", \"#481341\", \"#43123E\", \"#3F123D\", \"#3B113B\", \"#381139\", \"#351138\", \"#331237\", \"#301437\"],\n    positions: [0, 0.0078740157, 0.0157480315, 0.0236220472, 0.031496063, 0.0393700787, 0.0472440945, 0.0551181102, 0.062992126, 0.0708661417, 0.0787401575, 0.0866141732, 0.094488189, 0.1023622047, 0.1102362205, 0.1181102362, 0.125984252, 0.1338582677, 0.1417322835, 0.1496062992, 0.157480315, 0.1653543307, 0.1732283465, 0.1811023622, 0.188976378, 0.1968503937, 0.2047244094, 0.2125984252, 0.2204724409, 0.2283464567, 0.2362204724, 0.2440944882, 0.2519685039, 0.2598425197, 0.2677165354, 0.2755905512, 0.2834645669, 0.2913385827, 0.2992125984, 0.3070866142, 0.3149606299, 0.3228346457, 0.3307086614, 0.3385826772, 0.3464566929, 0.3543307087, 0.3622047244, 0.3700787402, 0.3779527559, 0.3858267717, 0.3937007874, 0.4015748031, 0.4094488189, 0.4173228346, 0.4251968504, 0.4330708661, 0.4409448819, 0.4488188976, 0.4566929134, 0.4645669291, 0.4724409449, 0.4803149606, 0.4881889764, 0.4960629921, 0.5039370079, 0.5118110236, 0.5196850394, 0.5275590551, 0.5354330709, 0.5433070866, 0.5511811024, 0.5590551181, 0.5669291339, 0.5748031496, 0.5826771654, 0.5905511811, 0.5984251969, 0.6062992126, 0.6141732283, 0.6220472441, 0.6299212598, 0.6377952756, 0.6456692913, 0.6535433071, 0.6614173228, 0.6692913386, 0.6771653543, 0.6850393701, 0.6929133858, 0.7007874016, 0.7086614173, 0.7165354331, 0.7244094488, 0.7322834646, 0.7401574803, 0.7480314961, 0.7559055118, 0.7637795276, 0.7716535433, 0.7795275591, 0.7874015748, 0.7952755906, 0.8031496063, 0.811023622, 0.8188976378, 0.8267716535, 0.8346456693, 0.842519685, 0.8503937008, 0.8582677165, 0.8661417323, 0.874015748, 0.8818897638, 0.8897637795, 0.8976377953, 0.905511811, 0.9133858268, 0.9212598425, 0.9291338583, 0.937007874, 0.9448818898, 0.9527559055, 0.9606299213, 0.968503937, 0.9763779528, 0.9842519685, 0.9921259843, 1]\n  }\n};\n\nfunction peg$subclass(child, parent) {\n  function C() {\n    this.constructor = child;\n  }\n  C.prototype = parent.prototype;\n  child.prototype = new C();\n}\nfunction peg$SyntaxError(message, expected, found, location) {\n  this.message = message;\n  this.expected = expected;\n  this.found = found;\n  this.location = location;\n  this.name = \"SyntaxError\";\n  if (typeof Error.captureStackTrace === \"function\") {\n    Error.captureStackTrace(this, peg$SyntaxError);\n  }\n}\npeg$subclass(peg$SyntaxError, Error);\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n    literal: function(expectation) {\n      return '\"' + literalEscape(expectation.text) + '\"';\n    },\n    class: function(expectation) {\n      var escapedParts = expectation.parts.map(function(part) {\n        return Array.isArray(part) ? classEscape(part[0]) + \"-\" + classEscape(part[1]) : classEscape(part);\n      });\n      return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n    },\n    any: function() {\n      return \"any character\";\n    },\n    end: function() {\n      return \"end of input\";\n    },\n    other: function(expectation) {\n      return expectation.description;\n    },\n    not: function(expectation) {\n      return \"not \" + describeExpectation(expectation.expected);\n    }\n  };\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n  function literalEscape(s) {\n    return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"').replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n      return \"\\\\x0\" + hex(ch);\n    }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n      return \"\\\\x\" + hex(ch);\n    });\n  }\n  function classEscape(s) {\n    return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\]/g, \"\\\\]\").replace(/\\^/g, \"\\\\^\").replace(/-/g, \"\\\\-\").replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n      return \"\\\\x0\" + hex(ch);\n    }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n      return \"\\\\x\" + hex(ch);\n    });\n  }\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n  function describeExpected(expected2) {\n    var descriptions = expected2.map(describeExpectation);\n    var i, j;\n    descriptions.sort();\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n      default:\n        return descriptions.slice(0, -1).join(\", \") + \", or \" + descriptions[descriptions.length - 1];\n    }\n  }\n  function describeFound(found2) {\n    return found2 ? '\"' + literalEscape(found2) + '\"' : \"end of input\";\n  }\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\nfunction peg$parse(input, options) {\n  options = options !== void 0 ? options : {};\n  var peg$FAILED = {};\n  var peg$startRuleFunctions = { Expression: peg$parseExpression };\n  var peg$startRuleFunction = peg$parseExpression;\n  var peg$c0 = \"+\";\n  var peg$c1 = \"-\";\n  var peg$c2 = \"*\";\n  var peg$c3 = \"/\";\n  var peg$c4 = \"**\";\n  var peg$c5 = \"(\";\n  var peg$c6 = \")\";\n  var peg$r0 = /^[\\-+]/;\n  var peg$r1 = /^[0-9]/;\n  var peg$r2 = /^[a-zA-Z_$]/;\n  var peg$r3 = /^[a-zA-Z_$0-9]/;\n  var peg$r4 = /^[ \\t\\n\\r]/;\n  var peg$e0 = peg$literalExpectation(\"+\", false);\n  var peg$e1 = peg$literalExpectation(\"-\", false);\n  var peg$e2 = peg$literalExpectation(\"*\", false);\n  var peg$e3 = peg$literalExpectation(\"/\", false);\n  var peg$e4 = peg$literalExpectation(\"**\", false);\n  var peg$e5 = peg$literalExpectation(\"(\", false);\n  var peg$e6 = peg$literalExpectation(\")\", false);\n  var peg$e7 = peg$otherExpectation(\"float\");\n  var peg$e8 = peg$otherExpectation(\"integer\");\n  var peg$e9 = peg$otherExpectation(\"identifier\");\n  var peg$e10 = peg$otherExpectation(\"whitespace\");\n  var peg$f0 = function(head, tail) {\n    var lhs = head;\n    var i, op;\n    for (i = 0; i < tail.length; i++) {\n      op = tail[i][1];\n      lhs = makeNode(lhs, tail[i][3], op);\n    }\n    return lhs;\n  };\n  var peg$f1 = function(head, tail) {\n    var lhs = head;\n    var i, op;\n    for (i = 0; i < tail.length; i++) {\n      op = tail[i][1];\n      lhs = makeNode(lhs, tail[i][3], op);\n    }\n    return lhs;\n  };\n  var peg$f2 = function(expr) {\n    return expr;\n  };\n  var peg$f3 = function(n, e) {\n    return { fn: n, lhs: e };\n  };\n  var peg$f4 = function() {\n    return parseFloat(text(), 10);\n  };\n  var peg$f5 = function() {\n    return parseInt(text(), 10);\n  };\n  var peg$f6 = function() {\n    return text();\n  };\n  var peg$currPos = 0;\n  var peg$savedPos = 0;\n  var peg$posDetailsCache = [{ line: 1, column: 1 }];\n  var peg$expected = [];\n  var peg$silentFails = 0;\n  var peg$result;\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(`Can't start parsing from rule \"` + options.startRule + '\".');\n    }\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n  function peg$literalExpectation(text2, ignoreCase) {\n    return { type: \"literal\", text: text2, ignoreCase };\n  }\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description };\n  }\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos];\n    var p;\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n      details = peg$posDetailsCache[p];\n      details = {\n        line: details.line,\n        column: details.column\n      };\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n        p++;\n      }\n      peg$posDetailsCache[pos] = details;\n      return details;\n    }\n  }\n  var peg$VALIDFILENAME = typeof options.filename === \"string\" && options.filename.length > 0;\n  function peg$computeLocation(startPos, endPos) {\n    var loc = {};\n    if (peg$VALIDFILENAME)\n      loc.filename = options.filename;\n    var startPosDetails = peg$computePosDetails(startPos);\n    loc.start = {\n      offset: startPos,\n      line: startPosDetails.line,\n      column: startPosDetails.column\n    };\n    var endPosDetails = peg$computePosDetails(endPos);\n    loc.end = {\n      offset: endPos,\n      line: endPosDetails.line,\n      column: endPosDetails.column\n    };\n    return loc;\n  }\n  function peg$begin() {\n    peg$expected.push({ pos: peg$currPos, variants: [] });\n  }\n  function peg$expect(expected2) {\n    var top = peg$expected[peg$expected.length - 1];\n    if (peg$currPos < top.pos) {\n      return;\n    }\n    if (peg$currPos > top.pos) {\n      top.pos = peg$currPos;\n      top.variants = [];\n    }\n    top.variants.push(expected2);\n  }\n  function peg$buildStructuredError(expected2, found, location2) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected2, found),\n      expected2,\n      found,\n      location2\n    );\n  }\n  function peg$buildError() {\n    var expected2 = peg$expected[0];\n    var failPos = expected2.pos;\n    return peg$buildStructuredError(\n      expected2.variants,\n      failPos < input.length ? input.charAt(failPos) : null,\n      failPos < input.length ? peg$computeLocation(failPos, failPos + 1) : peg$computeLocation(failPos, failPos)\n    );\n  }\n  function peg$parseExpression() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n    var rule$expects = function(expected2) {\n      if (peg$silentFails === 0)\n        peg$expect(expected2);\n    };\n    s0 = peg$currPos;\n    s1 = peg$parseTerm();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse_();\n      rule$expects(peg$e0);\n      if (input.charCodeAt(peg$currPos) === 43) {\n        s5 = peg$c0;\n        peg$currPos++;\n      } else {\n        s5 = peg$FAILED;\n      }\n      if (s5 === peg$FAILED) {\n        rule$expects(peg$e1);\n        if (input.charCodeAt(peg$currPos) === 45) {\n          s5 = peg$c1;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n        }\n      }\n      if (s5 !== peg$FAILED) {\n        s6 = peg$parse_();\n        s7 = peg$parseTerm();\n        if (s7 !== peg$FAILED) {\n          s4 = [s4, s5, s6, s7];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parse_();\n        rule$expects(peg$e0);\n        if (input.charCodeAt(peg$currPos) === 43) {\n          s5 = peg$c0;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n        }\n        if (s5 === peg$FAILED) {\n          rule$expects(peg$e1);\n          if (input.charCodeAt(peg$currPos) === 45) {\n            s5 = peg$c1;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n          }\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse_();\n          s7 = peg$parseTerm();\n          if (s7 !== peg$FAILED) {\n            s4 = [s4, s5, s6, s7];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      peg$savedPos = s0;\n      s0 = peg$f0(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    return s0;\n  }\n  function peg$parseTerm() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n    var rule$expects = function(expected2) {\n      if (peg$silentFails === 0)\n        peg$expect(expected2);\n    };\n    s0 = peg$currPos;\n    s1 = peg$parseExponential();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse_();\n      rule$expects(peg$e2);\n      if (input.charCodeAt(peg$currPos) === 42) {\n        s5 = peg$c2;\n        peg$currPos++;\n      } else {\n        s5 = peg$FAILED;\n      }\n      if (s5 === peg$FAILED) {\n        rule$expects(peg$e3);\n        if (input.charCodeAt(peg$currPos) === 47) {\n          s5 = peg$c3;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n        }\n      }\n      if (s5 !== peg$FAILED) {\n        s6 = peg$parse_();\n        s7 = peg$parseExponential();\n        if (s7 !== peg$FAILED) {\n          s4 = [s4, s5, s6, s7];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parse_();\n        rule$expects(peg$e2);\n        if (input.charCodeAt(peg$currPos) === 42) {\n          s5 = peg$c2;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n        }\n        if (s5 === peg$FAILED) {\n          rule$expects(peg$e3);\n          if (input.charCodeAt(peg$currPos) === 47) {\n            s5 = peg$c3;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n          }\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse_();\n          s7 = peg$parseExponential();\n          if (s7 !== peg$FAILED) {\n            s4 = [s4, s5, s6, s7];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      peg$savedPos = s0;\n      s0 = peg$f1(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    return s0;\n  }\n  function peg$parseExponential() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n    var rule$expects = function(expected2) {\n      if (peg$silentFails === 0)\n        peg$expect(expected2);\n    };\n    s0 = peg$currPos;\n    s1 = peg$parseFactor();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse_();\n      rule$expects(peg$e4);\n      if (input.substr(peg$currPos, 2) === peg$c4) {\n        s5 = peg$c4;\n        peg$currPos += 2;\n      } else {\n        s5 = peg$FAILED;\n      }\n      if (s5 !== peg$FAILED) {\n        s6 = peg$parse_();\n        s7 = peg$parseFactor();\n        if (s7 !== peg$FAILED) {\n          s4 = [s4, s5, s6, s7];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parse_();\n        rule$expects(peg$e4);\n        if (input.substr(peg$currPos, 2) === peg$c4) {\n          s5 = peg$c4;\n          peg$currPos += 2;\n        } else {\n          s5 = peg$FAILED;\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse_();\n          s7 = peg$parseFactor();\n          if (s7 !== peg$FAILED) {\n            s4 = [s4, s5, s6, s7];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      peg$savedPos = s0;\n      s0 = peg$f1(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    return s0;\n  }\n  function peg$parseFactor() {\n    var s0, s1, s2, s3, s4, s5;\n    var rule$expects = function(expected2) {\n      if (peg$silentFails === 0)\n        peg$expect(expected2);\n    };\n    s0 = peg$currPos;\n    rule$expects(peg$e5);\n    if (input.charCodeAt(peg$currPos) === 40) {\n      s1 = peg$c5;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_();\n      s3 = peg$parseExpression();\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parse_();\n        rule$expects(peg$e6);\n        if (input.charCodeAt(peg$currPos) === 41) {\n          s5 = peg$c6;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n        }\n        if (s5 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f2(s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseFloat();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseInteger();\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parseIdentifier();\n          if (s1 !== peg$FAILED) {\n            rule$expects(peg$e5);\n            if (input.charCodeAt(peg$currPos) === 40) {\n              s2 = peg$c5;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseExpression();\n              if (s3 !== peg$FAILED) {\n                rule$expects(peg$e6);\n                if (input.charCodeAt(peg$currPos) === 41) {\n                  s4 = peg$c6;\n                  peg$currPos++;\n                } else {\n                  s4 = peg$FAILED;\n                }\n                if (s4 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s0 = peg$f3(s1, s3);\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseIdentifier();\n          }\n        }\n      }\n    }\n    return s0;\n  }\n  function peg$parseFloat() {\n    var s0, s1, s2, s3, s4, s5;\n    var rule$expects = function(expected2) {\n      if (peg$silentFails === 0)\n        peg$expect(expected2);\n    };\n    rule$expects(peg$e7);\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$r0.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n    }\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      if (peg$r0.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n      }\n    }\n    s2 = [];\n    if (peg$r1.test(input.charAt(peg$currPos))) {\n      s3 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s3 = peg$FAILED;\n    }\n    if (s3 !== peg$FAILED) {\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        if (peg$r1.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n        }\n      }\n    } else {\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      if (input.length > peg$currPos) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        if (peg$r1.test(input.charAt(peg$currPos))) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n        }\n        if (s5 !== peg$FAILED) {\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            if (peg$r1.test(input.charAt(peg$currPos))) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n            }\n          }\n        } else {\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f4();\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    return s0;\n  }\n  function peg$parseInteger() {\n    var s0, s1, s2, s3;\n    var rule$expects = function(expected2) {\n      if (peg$silentFails === 0)\n        peg$expect(expected2);\n    };\n    rule$expects(peg$e8);\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$r0.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n    }\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      if (peg$r0.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n      }\n    }\n    s2 = [];\n    if (peg$r1.test(input.charAt(peg$currPos))) {\n      s3 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s3 = peg$FAILED;\n    }\n    if (s3 !== peg$FAILED) {\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        if (peg$r1.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n        }\n      }\n    } else {\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s0 = peg$f5();\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    return s0;\n  }\n  function peg$parseIdentifier() {\n    var s0, s1, s2, s3, s4;\n    var rule$expects = function(expected2) {\n      if (peg$silentFails === 0)\n        peg$expect(expected2);\n    };\n    rule$expects(peg$e9);\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$r0.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n    }\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      if (peg$r0.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n      }\n    }\n    if (peg$r2.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = [];\n      if (peg$r3.test(input.charAt(peg$currPos))) {\n        s4 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s4 = peg$FAILED;\n      }\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        if (peg$r3.test(input.charAt(peg$currPos))) {\n          s4 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n        }\n      }\n      peg$savedPos = s0;\n      s0 = peg$f6();\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    return s0;\n  }\n  function peg$parse_() {\n    var s0, s1;\n    var rule$expects = function(expected2) {\n      if (peg$silentFails === 0)\n        peg$expect(expected2);\n    };\n    rule$expects(peg$e10);\n    peg$silentFails++;\n    s0 = [];\n    if (peg$r4.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      if (peg$r4.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n      }\n    }\n    peg$silentFails--;\n    return s0;\n  }\n  function makeNode(lhs, rhs, op) {\n    if (typeof lhs === \"number\" && typeof rhs === \"number\") {\n      switch (op) {\n        case \"+\":\n          return lhs + rhs;\n        case \"-\":\n          return lhs - rhs;\n        case \"*\":\n          return lhs * rhs;\n        case \"/\":\n          return lhs / rhs;\n        case \"**\":\n          return Math.pow(lhs, rhs);\n      }\n    }\n    return {\n      lhs,\n      rhs,\n      op\n    };\n  }\n  peg$begin();\n  peg$result = peg$startRuleFunction();\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$expect(peg$endExpectation());\n    }\n    throw peg$buildError();\n  }\n}\n\nvar __defProp$3 = Object.defineProperty;\nvar __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$3 = (obj, key, value) => {\n  __defNormalProp$3(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\nfunction defaultFor(arg, val) {\n  return typeof arg !== \"undefined\" ? arg : val;\n}\nfunction create3DContext(canvas, optAttribs) {\n  const names = [\"webgl\", \"experimental-webgl\"];\n  let context = null;\n  for (let ii = 0; ii < names.length; ++ii) {\n    try {\n      context = canvas.getContext(names[ii], optAttribs);\n    } catch (e) {\n    }\n    if (context) {\n      break;\n    }\n  }\n  if (!context || !context.getExtension(\"OES_texture_float\")) {\n    return null;\n  }\n  return context;\n}\nfunction createProgram(gl, vertexShaderSource2, fragmentShaderSource2) {\n  const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n  gl.shaderSource(vertexShader, vertexShaderSource2);\n  gl.compileShader(vertexShader);\n  if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n    throw new Error(gl.getShaderInfoLog(vertexShader));\n  }\n  const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n  gl.shaderSource(fragmentShader, fragmentShaderSource2);\n  gl.compileShader(fragmentShader);\n  if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n    throw new Error(gl.getShaderInfoLog(fragmentShader));\n  }\n  const program = gl.createProgram();\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n  return program;\n}\nfunction setRectangle(gl, x, y, width, height) {\n  const x1 = x;\n  const x2 = x + width;\n  const y1 = y;\n  const y2 = y + height;\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n    x1,\n    y1,\n    x2,\n    y1,\n    x1,\n    y2,\n    x1,\n    y2,\n    x2,\n    y1,\n    x2,\n    y2\n  ]), gl.STATIC_DRAW);\n}\nfunction createDataset(gl, id, data, width, height) {\n  let textureData;\n  if (gl) {\n    gl.viewport(0, 0, width, height);\n    textureData = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, textureData);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.texImage2D(\n      gl.TEXTURE_2D,\n      0,\n      gl.LUMINANCE,\n      width,\n      height,\n      0,\n      gl.LUMINANCE,\n      gl.FLOAT,\n      new Float32Array(data)\n    );\n  }\n  return { textureData, width, height, data, id };\n}\nfunction destroyDataset(gl, dataset) {\n  if (gl) {\n    gl.deleteTexture(dataset.textureData);\n  }\n}\nfunction addColorScale(name, colors, positions) {\n  if (colors.length !== positions.length) {\n    throw new Error(\"Invalid color scale.\");\n  }\n  colorscales[name] = { colors, positions };\n}\nfunction renderColorScaleToCanvas(name, canvas, type = \"continuous\") {\n  const csDef = colorscales[name];\n  canvas.height = 1;\n  const ctx = canvas.getContext(\"2d\");\n  const width = 8192;\n  if (!ctx) {\n    throw new Error(\"Unable to get canvas context.\");\n  }\n  if (Object.prototype.toString.call(csDef) === \"[object Object]\") {\n    canvas.width = width;\n    if (type === \"continuous\") {\n      const gradient = ctx.createLinearGradient(0, 0, width, 1);\n      for (let i = 0; i < csDef.colors.length; ++i) {\n        gradient.addColorStop(csDef.positions[i], csDef.colors[i]);\n      }\n      ctx.fillStyle = gradient;\n      ctx.fillRect(0, 0, width, 1);\n    } else if (type === \"discrete\") {\n      for (let i = 0; i < csDef.colors.length; ++i) {\n        const nowPos = csDef.positions[i], lastPos = csDef.positions[i + 1];\n        const startPos = nowPos * (width - 10);\n        const endPos = lastPos ? lastPos * (width - 10) : width;\n        ctx.fillStyle = csDef.colors[i];\n        ctx.fillRect(startPos, 0, endPos - startPos, 1);\n      }\n    } else {\n      throw new Error(\"Invalid color scale type.\");\n    }\n  } else if (Object.prototype.toString.call(csDef) === \"[object Uint8Array]\") {\n    canvas.width = width;\n    const imgData = ctx.createImageData(width, 1);\n    imgData.data.set(csDef);\n    ctx.putImageData(imgData, 0, 0);\n  } else {\n    throw new Error(\"Color scale not defined.\");\n  }\n}\nconst vertexShaderSource = `\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nuniform mat3 u_matrix;\nuniform vec2 u_resolution;\nvarying vec2 v_texCoord;\nvoid main() {\n  // apply transformation matrix\n  vec2 position = (u_matrix * vec3(a_position, 1)).xy;\n  // convert the rectangle from pixels to 0.0 to 1.0\n  vec2 zeroToOne = position / u_resolution;\n  // convert from 0->1 to 0->2\n  vec2 zeroToTwo = zeroToOne * 2.0;\n  // convert from 0->2 to -1->+1 (clipspace)\n  vec2 clipSpace = zeroToTwo - 1.0;\n  gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\n  // pass the texCoord to the fragment shader\n  // The GPU will interpolate this value between points.\n  v_texCoord = a_texCoord;\n}`;\nconst fragmentShaderSource = `\nprecision mediump float;\n// our texture\nuniform sampler2D u_textureData;\nuniform sampler2D u_textureScale;\nuniform vec2 u_textureSize;\nuniform vec2 u_domain;\nuniform vec2 u_display_range;\nuniform bool u_apply_display_range;\nuniform float u_noDataValue;\nuniform bool u_clampLow;\nuniform bool u_clampHigh;\n// the texCoords passed in from the vertex shader.\nvarying vec2 v_texCoord;\n\nbool isnan( float val ) {\n  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true;\n}\n\nvoid main() {\n  vec2 onePixel = vec2(1.0, 1.0) / u_textureSize;\n  float value = texture2D(u_textureData, v_texCoord)[0];\n  if(value < -3.402823466e+38) // Check for possible NaN value\n    gl_FragColor = vec4(0.0, 0, 0, 0.0);\n  else if (value == u_noDataValue || isnan(value))\n    gl_FragColor = vec4(0.0, 0, 0, 0.0);\n  else if (u_apply_display_range && (value < u_display_range[0] || value >= u_display_range[1]))\n        gl_FragColor = vec4(0.0, 0, 0, 0.0);\n  else if ((!u_clampLow && value < u_domain[0]) || (!u_clampHigh && value > u_domain[1]))\n    gl_FragColor = vec4(0, 0, 0, 0);\n  else {\n    float normalisedValue = (value - u_domain[0]) / (u_domain[1] - u_domain[0]);\n    gl_FragColor = texture2D(u_textureScale, vec2(normalisedValue, 0));\n  }\n}`;\nclass plot {\n  constructor(options) {\n    __publicField$3(this, \"canvas\");\n    __publicField$3(this, \"currentDataset\");\n    __publicField$3(this, \"datasetCollection\");\n    __publicField$3(this, \"gl\");\n    __publicField$3(this, \"program\");\n    __publicField$3(this, \"texCoordBuffer\");\n    __publicField$3(this, \"ctx\");\n    __publicField$3(this, \"displayRange\");\n    __publicField$3(this, \"applyDisplayRange\");\n    __publicField$3(this, \"matrix\");\n    __publicField$3(this, \"colorScaleImage\");\n    __publicField$3(this, \"domain\");\n    __publicField$3(this, \"colorScaleCanvas\");\n    __publicField$3(this, \"name\");\n    __publicField$3(this, \"clampLow\");\n    __publicField$3(this, \"clampHigh\");\n    __publicField$3(this, \"textureScale\");\n    __publicField$3(this, \"noDataValue\");\n    __publicField$3(this, \"expressionAst\");\n    __publicField$3(this, \"colorType\", \"continuous\");\n    __publicField$3(this, \"positionBuffer\");\n    __publicField$3(this, \"programCache\", {});\n    this.datasetCollection = {};\n    this.currentDataset = null;\n    this.setCanvas(options.canvas);\n    this.setColorType(options.type);\n    if (defaultFor(options.useWebGL, true)) {\n      const gl = create3DContext(this.canvas, { premultipliedAlpha: false });\n      if (gl !== null) {\n        this.gl = gl;\n        this.program = createProgram(gl, vertexShaderSource, fragmentShaderSource);\n        gl.useProgram(this.program);\n        const texCoordLocation = gl.getAttribLocation(this.program, \"a_texCoord\");\n        this.texCoordBuffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.texCoordBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n          0,\n          0,\n          1,\n          0,\n          0,\n          1,\n          0,\n          1,\n          1,\n          0,\n          1,\n          1\n        ]), gl.STATIC_DRAW);\n        gl.enableVertexAttribArray(texCoordLocation);\n        gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);\n        this.positionBuffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n          0,\n          0,\n          1,\n          0,\n          0,\n          1,\n          0,\n          1,\n          1,\n          0,\n          1,\n          1\n        ]), gl.STATIC_DRAW);\n        const positionLocation = gl.getAttribLocation(this.program, \"a_position\");\n        gl.enableVertexAttribArray(positionLocation);\n        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n      } else {\n        this.ctx = this.canvas.getContext(\"2d\");\n      }\n    } else {\n      this.ctx = this.canvas.getContext(\"2d\");\n    }\n    if (options.colorScaleImage) {\n      this.setColorScaleImage(options.colorScaleImage);\n    } else {\n      this.setColorScale(defaultFor(options.colorScale, \"viridis\"));\n    }\n    this.setDomain(defaultFor(options.domain, [0, 1]));\n    this.displayRange = defaultFor(options.displayRange, [0, 1]);\n    this.applyDisplayRange = defaultFor(options.applyDisplayRange, false);\n    this.setClamp(defaultFor(options.clampLow, true), options.clampHigh);\n    this.setNoDataValue(options.noDataValue);\n    if (options.data) {\n      const l = options.data.length;\n      this.setData(\n        options.data,\n        defaultFor(options.width, options.data[l - 2]),\n        defaultFor(options.height, options.data[l - 2])\n      );\n    }\n    if (options.datasets) {\n      for (let i = 0; i < options.datasets.length; ++i) {\n        const ds = options.datasets[i];\n        this.addDataset(ds.id, ds.data, ds.width, ds.height);\n      }\n    }\n    if (options.matrix) {\n      this.matrix = options.matrix;\n    } else {\n      this.matrix = [\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      ];\n    }\n  }\n  /**\n   * Get the raw data from the currently selected dataset.\n   * @returns {TypedArray} the data of the currently selected dataset.\n   */\n  getData() {\n    const dataset = this.currentDataset;\n    if (!dataset) {\n      throw new Error(\"No dataset available.\");\n    }\n    return dataset.data;\n  }\n  /**\n   * Query the raw raster data at the specified coordinates.\n   * @param {Number} x the x coordinate\n   * @param {Number} y the y coordinate\n   * @returns {Number} the value at the specified coordinates\n   */\n  atPoint(x, y) {\n    const dataset = this.currentDataset;\n    if (!dataset) {\n      throw new Error(\"No dataset available.\");\n    } else if (x >= dataset.width || y >= dataset.height) {\n      throw new Error(\"Coordinates are outside of image bounds.\");\n    }\n    return dataset.data[y * dataset.width + x];\n  }\n  /**\n   * Set the raw raster data to be rendered. This creates a new unnamed dataset.\n   * @param {TypedArray} data the raw raster data. This can be a typed array of\n   *                          any type, but will be coerced to Float32Array when\n   *                          beeing rendered.\n   * @param {number} width the width of the raster image\n   * @param {number} height the height of the data\n   */\n  setData(data, width, height) {\n    if (this.currentDataset && this.currentDataset.id === null) {\n      destroyDataset(this.gl, this.currentDataset);\n    }\n    this.currentDataset = createDataset(this.gl, null, data, width, height);\n  }\n  /**\n   * Add a new named dataset. The semantics are the same as with @see setData.\n   * @param {string} id the identifier for the dataset.\n   * @param {TypedArray} data the raw raster data. This can be a typed array of\n   *                          any type, but will be coerced to Float32Array when\n   *                          beeing rendered.\n   * @param {number} width the width of the raster image\n   * @param {number} height the height of the data\n   */\n  addDataset(id, data, width, height) {\n    if (this.datasetAvailable(id)) {\n      throw new Error(`There is already a dataset registered with id '${id}'`);\n    }\n    this.datasetCollection[id] = createDataset(this.gl, id, data, width, height);\n    if (!this.currentDataset) {\n      this.currentDataset = this.datasetCollection[id];\n    }\n  }\n  /**\n   * Set the current dataset to be rendered.\n   * @param {string} id the identifier of the dataset to be rendered.\n   */\n  setCurrentDataset(id) {\n    if (!this.datasetAvailable(id)) {\n      throw new Error(`No such dataset registered: '${id}'`);\n    }\n    if (this.currentDataset && this.currentDataset.id === null) {\n      destroyDataset(this.gl, this.currentDataset);\n    }\n    this.currentDataset = this.datasetCollection[id];\n  }\n  /**\n   * Remove the dataset.\n   * @param {string} id the identifier of the dataset to be removed.\n   */\n  removeDataset(id) {\n    const dataset = this.datasetCollection[id];\n    if (!dataset) {\n      throw new Error(`No such dataset registered: '${id}'`);\n    }\n    destroyDataset(this.gl, dataset);\n    if (this.currentDataset === dataset) {\n      this.currentDataset = null;\n    }\n    delete this.datasetCollection[id];\n  }\n  removeAllDataset() {\n    Object.keys(this.datasetCollection).forEach((id) => this.removeDataset(id));\n  }\n  /**\n   * Check if the dataset is available.\n   * @param {string} id the identifier of the dataset to check.\n   * @returns {Boolean} whether or not a dataset with that identifier is defined\n   */\n  datasetAvailable(id) {\n    return hasOwnProperty(this.datasetCollection, id);\n  }\n  /**\n   * Retrieve the rendered color scale image.\n   * @returns {(HTMLCanvasElement|HTMLImageElement)} the canvas or image element\n   *                                                 for the rendered color scale\n   */\n  getColorScaleImage() {\n    return this.colorScaleImage;\n  }\n  /**\n   * Set the canvas to draw to. When no canvas is supplied, a new canvas element\n   * is created.\n   * @param {HTMLCanvasElement | OffscreenCanvas} [canvas] the canvas element to render to.\n   */\n  setCanvas(canvas) {\n    this.canvas = canvas || document.createElement(\"canvas\");\n  }\n  setColorType(type) {\n    this.colorType = type != null ? type : \"continuous\";\n  }\n  /**\n   * Set the new value domain for the rendering.\n   * @param {number[]} domain the value domain range in the form [low, high]\n   */\n  setDomain(domain) {\n    if (!domain || domain.length !== 2) {\n      throw new Error(\"Invalid domain specified.\");\n    }\n    this.domain = domain;\n  }\n  /**\n   * Set the display range that will be rendered, values outside of the range\n   * will not be rendered (transparent)\n   * @param {number[]} displayRange range array in the form [min, max]\n   */\n  setDisplayRange(displayRange) {\n    if (!displayRange || displayRange.length !== 2) {\n      throw new Error(\"Invalid view range specified.\");\n    }\n    this.displayRange = displayRange;\n    this.applyDisplayRange = true;\n  }\n  /**\n   * Get the canvas that is currently rendered to.\n   * @returns {HTMLCanvasElement} the canvas that is currently rendered to.\n   */\n  getCanvas() {\n    return this.canvas;\n  }\n  /**\n   * Set the currently selected color scale.\n   * @param {ColorScaleNames} name the name of the colorscale. Must be registered.\n   */\n  setColorScale(name) {\n    if (!hasOwnProperty(colorscales, name)) {\n      throw new Error(`No such color scale '${name}'`);\n    }\n    if (!this.colorScaleCanvas) {\n      this.colorScaleCanvas = document.createElement(\"canvas\");\n      this.colorScaleCanvas.width = 256;\n      this.colorScaleCanvas.height = 1;\n    }\n    renderColorScaleToCanvas(name, this.colorScaleCanvas, this.colorType);\n    this.name = name;\n    this.setColorScaleImage(this.colorScaleCanvas);\n  }\n  /**\n   * Set the clamping for the lower and the upper border of the values. When\n   * clamping is enabled for either side, the values below or above will be\n   * clamped to the minimum/maximum color.\n   * @param {Boolean} clampLow whether or not the minimum shall be clamped.\n   * @param {Boolean} clampHigh whether or not the maxmimum shall be clamped.\n   *                            defaults to clampMin.\n   */\n  setClamp(clampLow, clampHigh) {\n    this.clampLow = clampLow;\n    this.clampHigh = typeof clampHigh !== \"undefined\" ? clampHigh : clampLow;\n  }\n  /**\n   * Set the currently selected color scale as an image or canvas.\n   * @param {(HTMLCanvasElement|HTMLImageElement)} colorScaleImage the new color\n   *                                                               scale image\n   */\n  setColorScaleImage(colorScaleImage) {\n    this.colorScaleImage = colorScaleImage;\n    const gl = this.gl;\n    if (gl) {\n      if (this.textureScale) {\n        gl.deleteTexture(this.textureScale);\n      }\n      this.textureScale = gl.createTexture();\n      gl.bindTexture(gl.TEXTURE_2D, this.textureScale);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, colorScaleImage);\n    }\n  }\n  /**\n   * Set the no-data-value: a special value that will be rendered transparent.\n   * @param {number} noDataValue the no-data-value. Use null to clear a\n   *                            previously set no-data-value.\n   */\n  setNoDataValue(noDataValue) {\n    this.noDataValue = noDataValue;\n  }\n  /**\n   * Render the map to the specified canvas with the given settings.\n   */\n  render() {\n    const canvas = this.canvas;\n    const dataset = this.currentDataset;\n    canvas.width = dataset.width;\n    canvas.height = dataset.height;\n    let ids = this.getExpressionIds();\n    if (this.gl) {\n      this.renderWebGL(dataset, ids);\n    } else if (this.ctx) {\n      this.render2D(dataset);\n    }\n  }\n  getExpressionIds() {\n    if (!this.expressionAst)\n      return null;\n    const idsSet = /* @__PURE__ */ new Set();\n    const getIds = (node) => {\n      if (typeof node === \"string\") {\n        idsSet.add(node.replace(/[+-]/g, \"\"));\n      }\n      if (typeof node.lhs === \"string\") {\n        idsSet.add(node.lhs.replace(/[+-]/g, \"\"));\n      } else if (typeof node.lhs === \"object\") {\n        getIds(node.lhs);\n      }\n      if (typeof node.rhs === \"string\") {\n        idsSet.add(node.rhs.replace(/[+-]/g, \"\"));\n      } else if (typeof node.rhs === \"object\") {\n        getIds(node.rhs);\n      }\n    };\n    getIds(this.expressionAst);\n    return Array.from(idsSet);\n  }\n  renderWebGL(dataset, ids) {\n    const gl = this.gl;\n    gl.viewport(0, 0, dataset.width, dataset.height);\n    const program = this.getOrCreateProgram(ids);\n    gl.useProgram(program);\n    this.setupTextures(program, ids, dataset);\n    this.setupUniforms(program);\n    this.setupAttributes(program);\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\n  }\n  getOrCreateProgram(ids) {\n    if (!this.expressionAst) {\n      return this.program;\n    }\n    const exprKey = JSON.stringify(this.expressionAst);\n    if (this.programCache[exprKey]) {\n      return this.programCache[exprKey];\n    }\n    const vertexShader = this.createVertexShader();\n    const fragmentShader = this.createFragmentShader(ids);\n    const program = createProgram(this.gl, vertexShader, fragmentShader);\n    this.programCache[exprKey] = program;\n    return program;\n  }\n  createVertexShader() {\n    return `\n      attribute vec2 a_position;\n      attribute vec2 a_texCoord;\n      uniform mat3 u_matrix;\n      uniform vec2 u_resolution;\n      varying vec2 v_texCoord;\n      void main() {\n        vec2 position = (u_matrix * vec3(a_position, 1)).xy;\n        vec2 zeroToOne = position / u_resolution;\n        vec2 zeroToTwo = zeroToOne * 2.0;\n        vec2 clipSpace = zeroToTwo - 1.0;\n        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\n        v_texCoord = a_texCoord;\n      }\n    `;\n  }\n  createFragmentShader(ids) {\n    if (!ids) {\n      return fragmentShaderSource;\n    }\n    const expressionReducer = (node) => {\n      if (typeof node === \"object\") {\n        if (node.op === \"**\") {\n          return `pow(${expressionReducer(node.lhs)}, ${expressionReducer(node.rhs)})`;\n        }\n        if (node.fn) {\n          return `(${node.fn}(${expressionReducer(node.lhs)}))`;\n        }\n        return `(${expressionReducer(node.lhs)} ${node.op} ${expressionReducer(node.rhs)})`;\n      } else if (typeof node === \"string\") {\n        return `${node}_value`;\n      }\n      return `float(${node})`;\n    };\n    const compiledExpression = expressionReducer(this.expressionAst);\n    return `\n      precision mediump float;\n      uniform sampler2D u_textureScale;\n      ${ids.map((id) => `uniform sampler2D u_texture_${id};`).join(\"\\n\")}\n      uniform vec2 u_textureSize;\n      uniform vec2 u_domain;\n      uniform vec2 u_display_range;\n      uniform bool u_apply_display_range;\n      uniform float u_noDataValue;\n      uniform bool u_clampLow;\n      uniform bool u_clampHigh;\n      varying vec2 v_texCoord;\n      void main() {\n        ${ids.map((id) => `float ${id}_value = texture2D(u_texture_${id}, v_texCoord)[0];`).join(\"\\n\")}\n        float value = ${compiledExpression};\n\n        if (value == u_noDataValue)\n          gl_FragColor = vec4(0.0, 0, 0, 0.0);\n        else if (u_apply_display_range && (value < u_display_range[0] || value >= u_display_range[1]))\n          gl_FragColor = vec4(0.0, 0, 0, 0.0);\n        else if ((!u_clampLow && value < u_domain[0]) || (!u_clampHigh && value > u_domain[1]))\n          gl_FragColor = vec4(0, 0, 0, 0);\n        else {\n          float normalisedValue = (value - u_domain[0]) / (u_domain[1] - u_domain[0]);\n          gl_FragColor = texture2D(u_textureScale, vec2(normalisedValue, 0));\n        }\n      }\n    `;\n  }\n  setupTextures(program, ids, dataset) {\n    const gl = this.gl;\n    if (ids) {\n      gl.uniform1i(gl.getUniformLocation(program, \"u_textureScale\"), 0);\n      gl.activeTexture(gl.TEXTURE0);\n      gl.bindTexture(gl.TEXTURE_2D, this.textureScale);\n      ids.forEach((id, index) => {\n        const location = index + 1;\n        const ds = this.datasetCollection[id];\n        if (!ds) {\n          throw new Error(`No such dataset registered: '${id}'`);\n        }\n        gl.uniform1i(gl.getUniformLocation(program, `u_texture_${id}`), location);\n        gl.activeTexture(gl[`TEXTURE${location}`]);\n        gl.bindTexture(gl.TEXTURE_2D, ds.textureData);\n      });\n    } else {\n      gl.uniform1i(gl.getUniformLocation(program, \"u_textureData\"), 0);\n      gl.uniform1i(gl.getUniformLocation(program, \"u_textureScale\"), 1);\n      gl.activeTexture(gl.TEXTURE0);\n      gl.bindTexture(gl.TEXTURE_2D, dataset.textureData);\n      gl.activeTexture(gl.TEXTURE1);\n      gl.bindTexture(gl.TEXTURE_2D, this.textureScale);\n    }\n  }\n  setupUniforms(program) {\n    const gl = this.gl;\n    const canvas = this.canvas;\n    gl.uniform2f(gl.getUniformLocation(program, \"u_resolution\"), canvas.width, canvas.height);\n    gl.uniform2fv(gl.getUniformLocation(program, \"u_domain\"), this.domain);\n    gl.uniform2fv(gl.getUniformLocation(program, \"u_display_range\"), this.displayRange);\n    gl.uniform1i(gl.getUniformLocation(program, \"u_apply_display_range\"), +this.applyDisplayRange);\n    gl.uniform1i(gl.getUniformLocation(program, \"u_clampLow\"), +this.clampLow);\n    gl.uniform1i(gl.getUniformLocation(program, \"u_clampHigh\"), +this.clampHigh);\n    gl.uniform1f(gl.getUniformLocation(program, \"u_noDataValue\"), this.noDataValue);\n    gl.uniformMatrix3fv(gl.getUniformLocation(program, \"u_matrix\"), false, this.matrix);\n  }\n  setupAttributes(program) {\n    const gl = this.gl;\n    const canvas = this.canvas;\n    const positionLocation = gl.getAttribLocation(program, \"a_position\");\n    const positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    gl.enableVertexAttribArray(positionLocation);\n    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n    setRectangle(gl, 0, 0, canvas.width, canvas.height);\n  }\n  render2D(dataset) {\n    const ctx = this.ctx;\n    const w = this.canvas.width;\n    const h = this.canvas.height;\n    const imageData = ctx.createImageData(w, h);\n    const trange = this.domain[1] - this.domain[0];\n    const steps = this.colorScaleCanvas.width;\n    const csImageData = this.colorScaleCanvas.getContext(\"2d\").getImageData(0, 0, steps, 1).data;\n    let alpha;\n    const data = dataset.data;\n    for (let y = 0; y < h; y++) {\n      for (let x = 0; x < w; x++) {\n        const i = y * w + x;\n        let c = Math.floor((data[i] - this.domain[0]) / trange * (steps - 1));\n        alpha = 255;\n        if (c < 0) {\n          c = 0;\n          if (!this.clampLow) {\n            alpha = 0;\n          }\n        } else if (c > 255) {\n          c = 255;\n          if (!this.clampHigh) {\n            alpha = 0;\n          }\n        }\n        if (data[i] === this.noDataValue || data[i] !== data[i]) {\n          alpha = 0;\n        } else if (this.applyDisplayRange && (data[i] < this.displayRange[0] || data[i] >= this.displayRange[1])) {\n          alpha = 0;\n        }\n        const index = (y * w + x) * 4;\n        imageData.data[index + 0] = csImageData[c * 4];\n        imageData.data[index + 1] = csImageData[c * 4 + 1];\n        imageData.data[index + 2] = csImageData[c * 4 + 2];\n        imageData.data[index + 3] = Math.min(alpha, csImageData[c * 4 + 3]);\n      }\n    }\n    ctx.putImageData(imageData, 0, 0);\n  }\n  /**\n   * Render the specified dataset with the current settings.\n   * @param {string} id the identifier of the dataset to render.\n   */\n  renderDataset(id) {\n    this.setCurrentDataset(id);\n    return this.render();\n  }\n  /**\n   * Get the color for the specified value.\n   * @param {number} val the value to query the color for.\n   * @returns {Array} the 4-tuple: red, green, blue, alpha in the range 0-255.\n   */\n  getColor(val) {\n    const steps = this.colorScaleCanvas.width;\n    const csImageData = this.colorScaleCanvas.getContext(\"2d\").getImageData(0, 0, steps, 1).data;\n    const trange = this.domain[1] - this.domain[0];\n    let c = Math.round((val - this.domain[0]) / trange * steps);\n    let alpha = 255;\n    if (c < 0) {\n      c = 0;\n      if (!this.clampLow) {\n        alpha = 0;\n      }\n    }\n    if (c > 255) {\n      c = 255;\n      if (!this.clampHigh) {\n        alpha = 0;\n      }\n    }\n    return [\n      csImageData[c * 4],\n      csImageData[c * 4 + 1],\n      csImageData[c * 4 + 2],\n      alpha\n    ];\n  }\n  /**\n   * Sets a mathematical expression to be evaluated on the plot. Expression can contain mathematical operations with integer/float values, dataset identifiers or GLSL supported functions with a single parameter.\n   * Supported mathematical operations are: add '+', subtract '-', multiply '*', divide '/', power '**', unary plus '+a', unary minus '-a'.\n   * Useful GLSL functions are for example: radians, degrees, sin, asin, cos, acos, tan, atan, log2, log, sqrt, exp2, exp, abs, sign, floor, ceil, fract.\n   * @param {string} expression Mathematical expression. Example: '-2 * sin(3.1415 - dataset1) ** 2'\n   */\n  setExpression(expression) {\n    if (!expression || !expression.length) {\n      this.expressionAst = null;\n    } else {\n      this.expressionAst = peg$parse(expression);\n    }\n  }\n  destroy() {\n    var _a;\n    (_a = this.gl) == null ? void 0 : _a.deleteProgram(this.program);\n    this.removeAllDataset();\n  }\n}\n\nfunction getMinMax(data, nodata) {\n  let min, max;\n  for (let j = 0; j < data.length; j += 1) {\n    const val = data[j];\n    if (val === nodata)\n      continue;\n    if (min === void 0 && max === void 0) {\n      min = max = val;\n      continue;\n    }\n    if (val < min) {\n      min = val;\n    } else if (val > max) {\n      max = val;\n    }\n  }\n  return {\n    min,\n    max\n  };\n}\nfunction decimal2rgb(number) {\n  return Math.round(number * 255);\n}\nfunction getRange(bands, opts) {\n  var _a, _b;\n  const band = bands[opts.band];\n  if (!band) {\n    throw new Error(`Invalid band${opts.band}`);\n  }\n  const min = (_a = opts == null ? void 0 : opts.min) != null ? _a : +band.min;\n  const max = (_b = opts == null ? void 0 : opts.max) != null ? _b : +band.max;\n  const range = max - min;\n  return { min, max, range };\n}\nfunction generateColorScale(colors, minMax) {\n  let stops;\n  if (typeof colors[0] === \"string\") {\n    stops = colors.map((color, index) => [index / colors.length, color]);\n  } else {\n    const [min, max] = minMax;\n    stops = colors.map((item) => [(item[0] - min) / (max - min), item[1]]);\n  }\n  stops.sort((a, b) => a[0] - b[0]);\n  let i = stops.length - 1;\n  while (i > 1 && stops[i][0] >= 1 && stops[i - 1][0] >= 1) {\n    stops.pop();\n    i--;\n  }\n  if (stops[0][0] > 0) {\n    stops = [[0, stops[0][1]], ...stops];\n  }\n  const colorScale = {\n    colors: stops.map((stop) => stop[1]),\n    positions: stops.map((stop) => {\n      let s = stop[0];\n      if (s < 0)\n        return 0;\n      if (s > 1)\n        return 1;\n      return s;\n    })\n  };\n  return colorScale;\n}\nfunction findAndSortBandNumbers(str) {\n  const regex = /b(\\d+)/g;\n  const bandNumbers = /* @__PURE__ */ new Set();\n  let match;\n  while ((match = regex.exec(str)) !== null) {\n    bandNumbers.add(parseInt(match[1]) - 1);\n  }\n  return Array.from(bandNumbers).sort((a, b) => a - b);\n}\nfunction stringColorToRgba(color) {\n  const newColor = terriajs_cesium_Source_Core_Color__WEBPACK_IMPORTED_MODULE_1___default.a.fromCssColorString(color);\n  const { red, green, blue, alpha } = newColor;\n  return [red, green, blue, alpha].map((val) => Math.round(val * 255));\n}\nfunction reverseArray(options) {\n  const { array, width, height } = options;\n  const reversedArray = [];\n  for (let row = height - 1; row >= 0; row--) {\n    const startIndex = row * width;\n    const endIndex = startIndex + width;\n    const rowArray = array.slice(startIndex, endIndex);\n    reversedArray.push(...rowArray);\n  }\n  return reversedArray;\n}\n\nvar __defProp$2 = Object.defineProperty;\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$2 = (obj, key, value) => {\n  __defNormalProp$2(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass TIFFImageryProviderTilingScheme extends terriajs_cesium_Source_Core_WebMercatorTilingScheme__WEBPACK_IMPORTED_MODULE_9___default.a {\n  constructor(options) {\n    super(options);\n    __publicField$2(this, \"nativeRectangle\");\n    const { project, unproject } = options;\n    this.nativeRectangle = new terriajs_cesium_Source_Core_Rectangle__WEBPACK_IMPORTED_MODULE_8___default.a(options.rectangleSouthwestInMeters.x, options.rectangleSouthwestInMeters.y, options.rectangleNortheastInMeters.x, options.rectangleNortheastInMeters.y);\n    this._projection = {\n      ellipsoid: this.ellipsoid,\n      project(cartographic, result) {\n        const [x, y] = project([cartographic.longitude, cartographic.latitude].map(terriajs_cesium_Source_Core_Math__WEBPACK_IMPORTED_MODULE_7___default.a.toDegrees));\n        const z = cartographic.height;\n        return terriajs_cesium_Source_Core_Cartesian3__WEBPACK_IMPORTED_MODULE_13___default.a.fromElements(x, y, z, result);\n      },\n      unproject(cartesian, result) {\n        const [longitude, latitude] = unproject([cartesian.x, cartesian.y]);\n        const height = cartesian.z;\n        return terriajs_cesium_Source_Core_Cartographic__WEBPACK_IMPORTED_MODULE_12___default.a.fromDegrees(longitude, latitude, height, result);\n      }\n    };\n    const swMeters = new terriajs_cesium_Source_Core_Cartesian3__WEBPACK_IMPORTED_MODULE_13___default.a();\n    options.rectangleSouthwestInMeters.clone(swMeters);\n    const neMeters = new terriajs_cesium_Source_Core_Cartesian3__WEBPACK_IMPORTED_MODULE_13___default.a();\n    options.rectangleNortheastInMeters.clone(neMeters);\n    const seMeters = new terriajs_cesium_Source_Core_Cartesian3__WEBPACK_IMPORTED_MODULE_13___default.a(neMeters.x, swMeters.y);\n    const nwMeters = new terriajs_cesium_Source_Core_Cartesian3__WEBPACK_IMPORTED_MODULE_13___default.a(swMeters.x, neMeters.y);\n    const southwest = this.projection.unproject(swMeters);\n    const southeast = this.projection.unproject(seMeters);\n    const northwest = this.projection.unproject(nwMeters);\n    const northeast = this.projection.unproject(neMeters);\n    this._rectangle = terriajs_cesium_Source_Core_Rectangle__WEBPACK_IMPORTED_MODULE_8___default.a.fromCartographicArray([southwest, southeast, northwest, northeast]);\n  }\n  tileXYToNativeRectangle2(x, y, level) {\n    const rect = this.tileXYToRectangle(x, y, level);\n    const projection = this.projection;\n    const ws = projection.project(new terriajs_cesium_Source_Core_Cartographic__WEBPACK_IMPORTED_MODULE_12___default.a(rect.west, rect.south));\n    const wn = projection.project(new terriajs_cesium_Source_Core_Cartographic__WEBPACK_IMPORTED_MODULE_12___default.a(rect.west, rect.north));\n    const en = projection.project(new terriajs_cesium_Source_Core_Cartographic__WEBPACK_IMPORTED_MODULE_12___default.a(rect.east, rect.north));\n    const es = projection.project(new terriajs_cesium_Source_Core_Cartographic__WEBPACK_IMPORTED_MODULE_12___default.a(rect.east, rect.south));\n    const positions = [ws, wn, en, es];\n    const xx = positions.map((pos) => pos.x);\n    const yy = positions.map((pos) => pos.y);\n    return new terriajs_cesium_Source_Core_Rectangle__WEBPACK_IMPORTED_MODULE_8___default.a(\n      Math.min(...xx),\n      Math.min(...yy),\n      Math.max(...xx),\n      Math.max(...yy)\n    );\n  }\n  tileXYToRectangle(x, y, level) {\n    const rect = this.tileXYToNativeRectangle(x, y, level);\n    const projection = this.projection;\n    const ws = projection.unproject(new terriajs_cesium_Source_Core_Cartesian3__WEBPACK_IMPORTED_MODULE_13___default.a(rect.west, rect.south));\n    const wn = projection.unproject(new terriajs_cesium_Source_Core_Cartesian3__WEBPACK_IMPORTED_MODULE_13___default.a(rect.west, rect.north));\n    const en = projection.unproject(new terriajs_cesium_Source_Core_Cartesian3__WEBPACK_IMPORTED_MODULE_13___default.a(rect.east, rect.north));\n    const es = projection.unproject(new terriajs_cesium_Source_Core_Cartesian3__WEBPACK_IMPORTED_MODULE_13___default.a(rect.east, rect.south));\n    const newRect = terriajs_cesium_Source_Core_Rectangle__WEBPACK_IMPORTED_MODULE_8___default.a.fromCartographicArray([ws, wn, en, es]);\n    if (newRect.east < newRect.west) {\n      newRect.east += terriajs_cesium_Source_Core_Math__WEBPACK_IMPORTED_MODULE_7___default.a.TWO_PI;\n    }\n    return newRect;\n  }\n}\n\nfunction resampleNearest(data, options) {\n  const { sourceWidth, sourceHeight, targetWidth, targetHeight, window, buffer = 0 } = options;\n  const [x0, y0, x1, y1] = window;\n  const effectiveSourceWidth = sourceWidth - 2 * buffer;\n  const effectiveSourceHeight = sourceHeight - 2 * buffer;\n  const resampledData = copyNewSize(data, targetWidth, targetHeight);\n  for (let y = 0; y < targetHeight; y++) {\n    for (let x = 0; x < targetWidth; x++) {\n      const col = buffer + (effectiveSourceWidth * (x0 + x / targetWidth * (x1 - x0)) >>> 0);\n      const row = buffer + (effectiveSourceHeight * (y0 + y / targetHeight * (y1 - y0)) >>> 0);\n      resampledData[y * targetWidth + x] = data[row * sourceWidth + col];\n    }\n  }\n  return resampledData;\n}\nfunction resampleData(data, options) {\n  const { method = \"nearest\" } = options;\n  switch (method) {\n    case \"nearest\":\n      return resampleNearest(data, options);\n    case \"bilinear\":\n      return resampleBilinear(data, options);\n  }\n}\nfunction copyNewSize(array, width, height, samplesPerPixel = 1) {\n  return new (Object.getPrototypeOf(array)).constructor(width * height * samplesPerPixel);\n}\nfunction lerp(v0, v1, t) {\n  return (1 - t) * v0 + t * v1;\n}\nfunction resampleBilinear(data, options) {\n  const { sourceWidth, sourceHeight, targetWidth, targetHeight, window, buffer = 0, nodata } = options;\n  const [x0, y0, x1, y1] = window;\n  const windowWidth = x1 - x0;\n  const windowHeight = y1 - y0;\n  const newArray = copyNewSize(data, targetWidth, targetHeight);\n  const effectiveSourceWidth = sourceWidth - 2 * buffer;\n  const effectiveSourceHeight = sourceHeight - 2 * buffer;\n  const invTargetWidth = 1 / targetWidth;\n  const invTargetHeight = 1 / targetHeight;\n  const isNodata = (value) => {\n    if (nodata === void 0)\n      return false;\n    if (nodata === 0)\n      return value === 0;\n    return Math.abs((value - nodata) / nodata) < 1e-6;\n  };\n  for (let y = 0; y < targetHeight; y++) {\n    const yRatio = y * invTargetHeight;\n    const yMapped = y0 + yRatio * windowHeight;\n    const rawY = effectiveSourceHeight * yMapped + buffer;\n    const yl = Math.floor(rawY);\n    const yh = Math.min(Math.ceil(rawY), sourceHeight - buffer - 1);\n    const ty = rawY - yl;\n    for (let x = 0; x < targetWidth; x++) {\n      const xRatio = x * invTargetWidth;\n      const xMapped = x0 + xRatio * windowWidth;\n      const rawX = effectiveSourceWidth * xMapped + buffer;\n      const xl = Math.floor(rawX);\n      const xh = Math.min(Math.ceil(rawX), sourceWidth - buffer - 1);\n      const txFraction = rawX - xl;\n      const center = data[yl * sourceWidth + xl];\n      const neighbors = [\n        data[yl * sourceWidth + xl],\n        data[yl * sourceWidth + xh],\n        data[yh * sourceWidth + xl],\n        data[yh * sourceWidth + xh]\n      ];\n      neighbors.forEach((neighbor, index) => {\n        if (isNodata(neighbor)) {\n          neighbors[index] = center;\n        }\n      });\n      if (isNodata(center)) {\n        newArray[y * targetWidth + x] = nodata;\n        continue;\n      }\n      const [ll, hl, lh, hh] = neighbors;\n      const v0 = lerp(ll, hl, txFraction);\n      const v1 = lerp(lh, hh, txFraction);\n      const value = lerp(v0, v1, ty);\n      newArray[y * targetWidth + x] = value;\n    }\n  }\n  return newArray;\n}\n\nfunction inRange(val, range) {\n  if (val < range[0] && val < range[1] || val > range[0] && val > range[1]) {\n    return false;\n  } else {\n    return true;\n  }\n}\nfunction reprojection(options) {\n  const { data, sourceBBox, targetBBox, project, sourceWidth, sourceHeight, nodata } = options;\n  const { targetWidth = sourceWidth, targetHeight = sourceHeight } = options;\n  const [minX, minY, maxX, maxY] = sourceBBox;\n  const [minLon, minLat, maxLon, maxLat] = targetBBox;\n  const stepX = Math.abs(maxX - minX) / sourceWidth;\n  const stepY = Math.abs(maxY - minY) / sourceHeight;\n  const stepLon = Math.abs(maxLon - minLon) / targetWidth;\n  const stepLat = Math.abs(maxLat - minLat) / targetHeight;\n  const result = copyNewSize(data, targetWidth, targetHeight).fill(nodata);\n  for (let i = 0; i < targetHeight; i++) {\n    for (let j = 0; j < targetWidth; j++) {\n      const lon = minLon + stepLon * (j + 0.5);\n      const lat = maxLat - stepLat * (i + 0.5);\n      const [x, y] = project([lon, lat]);\n      if (!inRange(x, [minX, maxX]) || !inRange(y, [minX, maxY])) {\n        break;\n      }\n      const indexX = ~~((x - minX) / stepX);\n      const indexY = ~~((maxY - y) / stepY);\n      const sourceVal = data[indexY * sourceWidth + indexX];\n      const index = i * targetWidth + j;\n      result[index] = sourceVal;\n    }\n  }\n  return result;\n}\n\nvar __async$2 = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nfunction generateImage(opts) {\n  return __async$2(this, null, function* () {\n    const { data, width, height, renderOptions, bands, noData, colorMapping } = opts;\n    const imageData = new Uint8ClampedArray(width * height * 4);\n    function ifNoDataFunc(...vals) {\n      if (vals.some((val) => isNaN(val) || val === noData))\n        return true;\n      return false;\n    }\n    const { r, g, b } = renderOptions != null ? renderOptions : {};\n    const ranges = [r, g, b].map((item) => getRange(bands, item));\n    const redData = data[0];\n    const greenData = data[1];\n    const blueData = data[2];\n    for (let i = 0; i < data[0].length; i++) {\n      let red = decimal2rgb((redData[i] - ranges[0].min) / ranges[0].range);\n      let green = decimal2rgb((greenData[i] - ranges[1].min) / ranges[1].range);\n      let blue = decimal2rgb((blueData[i] - ranges[2].min) / ranges[2].range);\n      let alpha = ifNoDataFunc(redData[i], greenData[i], blueData[i]) ? 0 : 255;\n      colorMapping.map(([colorFrom, colorTo]) => {\n        if (red === colorFrom[0] && green === colorFrom[1] && blue === colorFrom[2]) {\n          red = colorTo[0];\n          green = colorTo[1];\n          blue = colorTo[2];\n          alpha = colorTo[3];\n        }\n      });\n      imageData[i * 4] = red;\n      imageData[i * 4 + 1] = green;\n      imageData[i * 4 + 2] = blue;\n      imageData[i * 4 + 3] = alpha;\n    }\n    const result = new ImageData(imageData, width, height);\n    return result;\n  });\n}\n\nfunction createCanavas(width, height) {\n  if (\"OffscreenCanvas\" in window) {\n    return new OffscreenCanvas(width, height);\n  } else {\n    const canv = document.createElement(\"canvas\");\n    canv.width = width;\n    canv.height = height;\n    return canv;\n  }\n}\n\nfunction decodeBase64(base64, enableUnicode) {\n    var binaryString = atob(base64);\n    if (enableUnicode) {\n        var binaryView = new Uint8Array(binaryString.length);\n        for (var i = 0, n = binaryString.length; i < n; ++i) {\n            binaryView[i] = binaryString.charCodeAt(i);\n        }\n        return String.fromCharCode.apply(null, new Uint16Array(binaryView.buffer));\n    }\n    return binaryString;\n}\n\nfunction createURL(base64, sourcemapArg, enableUnicodeArg) {\n    var sourcemap = sourcemapArg === undefined ? null : sourcemapArg;\n    var enableUnicode = enableUnicodeArg === undefined ? false : enableUnicodeArg;\n    var source = decodeBase64(base64, enableUnicode);\n    var start = source.indexOf('\\n', 10) + 1;\n    var body = source.substring(start) + (sourcemap ? '\\/\\/# sourceMappingURL=' + sourcemap : '');\n    var blob = new Blob([body], { type: 'application/javascript' });\n    return URL.createObjectURL(blob);\n}\n\nfunction createBase64WorkerFactory(base64, sourcemapArg, enableUnicodeArg) {\n    var url;\n    return function WorkerFactory(options) {\n        url = url || createURL(base64, sourcemapArg, enableUnicodeArg);\n        return new Worker(url, options);\n    };\n}\n\nvar WorkerFactory = createBase64WorkerFactory('Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwooZnVuY3Rpb24gKCkgewogICd1c2Ugc3RyaWN0JzsKCiAgZnVuY3Rpb24gcmVzYW1wbGVOZWFyZXN0KGRhdGEsIG9wdGlvbnMpIHsKICAgIGNvbnN0IHsgc291cmNlV2lkdGgsIHNvdXJjZUhlaWdodCwgdGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCwgd2luZG93LCBidWZmZXIgPSAwIH0gPSBvcHRpb25zOwogICAgY29uc3QgW3gwLCB5MCwgeDEsIHkxXSA9IHdpbmRvdzsKICAgIGNvbnN0IGVmZmVjdGl2ZVNvdXJjZVdpZHRoID0gc291cmNlV2lkdGggLSAyICogYnVmZmVyOwogICAgY29uc3QgZWZmZWN0aXZlU291cmNlSGVpZ2h0ID0gc291cmNlSGVpZ2h0IC0gMiAqIGJ1ZmZlcjsKICAgIGNvbnN0IHJlc2FtcGxlZERhdGEgPSBjb3B5TmV3U2l6ZShkYXRhLCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0KTsKICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGFyZ2V0SGVpZ2h0OyB5KyspIHsKICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0YXJnZXRXaWR0aDsgeCsrKSB7CiAgICAgICAgY29uc3QgY29sID0gYnVmZmVyICsgKGVmZmVjdGl2ZVNvdXJjZVdpZHRoICogKHgwICsgeCAvIHRhcmdldFdpZHRoICogKHgxIC0geDApKSA+Pj4gMCk7CiAgICAgICAgY29uc3Qgcm93ID0gYnVmZmVyICsgKGVmZmVjdGl2ZVNvdXJjZUhlaWdodCAqICh5MCArIHkgLyB0YXJnZXRIZWlnaHQgKiAoeTEgLSB5MCkpID4+PiAwKTsKICAgICAgICByZXNhbXBsZWREYXRhW3kgKiB0YXJnZXRXaWR0aCArIHhdID0gZGF0YVtyb3cgKiBzb3VyY2VXaWR0aCArIGNvbF07CiAgICAgIH0KICAgIH0KICAgIHJldHVybiByZXNhbXBsZWREYXRhOwogIH0KICBmdW5jdGlvbiByZXNhbXBsZURhdGEoZGF0YSwgb3B0aW9ucykgewogICAgY29uc3QgeyBtZXRob2QgPSAibmVhcmVzdCIgfSA9IG9wdGlvbnM7CiAgICBzd2l0Y2ggKG1ldGhvZCkgewogICAgICBjYXNlICJuZWFyZXN0IjoKICAgICAgICByZXR1cm4gcmVzYW1wbGVOZWFyZXN0KGRhdGEsIG9wdGlvbnMpOwogICAgICBjYXNlICJiaWxpbmVhciI6CiAgICAgICAgcmV0dXJuIHJlc2FtcGxlQmlsaW5lYXIoZGF0YSwgb3B0aW9ucyk7CiAgICB9CiAgfQogIGZ1bmN0aW9uIGNvcHlOZXdTaXplKGFycmF5LCB3aWR0aCwgaGVpZ2h0LCBzYW1wbGVzUGVyUGl4ZWwgPSAxKSB7CiAgICByZXR1cm4gbmV3IChPYmplY3QuZ2V0UHJvdG90eXBlT2YoYXJyYXkpKS5jb25zdHJ1Y3Rvcih3aWR0aCAqIGhlaWdodCAqIHNhbXBsZXNQZXJQaXhlbCk7CiAgfQogIGZ1bmN0aW9uIGxlcnAodjAsIHYxLCB0KSB7CiAgICByZXR1cm4gKDEgLSB0KSAqIHYwICsgdCAqIHYxOwogIH0KICBmdW5jdGlvbiByZXNhbXBsZUJpbGluZWFyKGRhdGEsIG9wdGlvbnMpIHsKICAgIGNvbnN0IHsgc291cmNlV2lkdGgsIHNvdXJjZUhlaWdodCwgdGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCwgd2luZG93LCBidWZmZXIgPSAwLCBub2RhdGEgfSA9IG9wdGlvbnM7CiAgICBjb25zdCBbeDAsIHkwLCB4MSwgeTFdID0gd2luZG93OwogICAgY29uc3Qgd2luZG93V2lkdGggPSB4MSAtIHgwOwogICAgY29uc3Qgd2luZG93SGVpZ2h0ID0geTEgLSB5MDsKICAgIGNvbnN0IG5ld0FycmF5ID0gY29weU5ld1NpemUoZGF0YSwgdGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCk7CiAgICBjb25zdCBlZmZlY3RpdmVTb3VyY2VXaWR0aCA9IHNvdXJjZVdpZHRoIC0gMiAqIGJ1ZmZlcjsKICAgIGNvbnN0IGVmZmVjdGl2ZVNvdXJjZUhlaWdodCA9IHNvdXJjZUhlaWdodCAtIDIgKiBidWZmZXI7CiAgICBjb25zdCBpbnZUYXJnZXRXaWR0aCA9IDEgLyB0YXJnZXRXaWR0aDsKICAgIGNvbnN0IGludlRhcmdldEhlaWdodCA9IDEgLyB0YXJnZXRIZWlnaHQ7CiAgICBjb25zdCBpc05vZGF0YSA9ICh2YWx1ZSkgPT4gewogICAgICBpZiAobm9kYXRhID09PSB2b2lkIDApCiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICBpZiAobm9kYXRhID09PSAwKQogICAgICAgIHJldHVybiB2YWx1ZSA9PT0gMDsKICAgICAgcmV0dXJuIE1hdGguYWJzKCh2YWx1ZSAtIG5vZGF0YSkgLyBub2RhdGEpIDwgMWUtNjsKICAgIH07CiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRhcmdldEhlaWdodDsgeSsrKSB7CiAgICAgIGNvbnN0IHlSYXRpbyA9IHkgKiBpbnZUYXJnZXRIZWlnaHQ7CiAgICAgIGNvbnN0IHlNYXBwZWQgPSB5MCArIHlSYXRpbyAqIHdpbmRvd0hlaWdodDsKICAgICAgY29uc3QgcmF3WSA9IGVmZmVjdGl2ZVNvdXJjZUhlaWdodCAqIHlNYXBwZWQgKyBidWZmZXI7CiAgICAgIGNvbnN0IHlsID0gTWF0aC5mbG9vcihyYXdZKTsKICAgICAgY29uc3QgeWggPSBNYXRoLm1pbihNYXRoLmNlaWwocmF3WSksIHNvdXJjZUhlaWdodCAtIGJ1ZmZlciAtIDEpOwogICAgICBjb25zdCB0eSA9IHJhd1kgLSB5bDsKICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0YXJnZXRXaWR0aDsgeCsrKSB7CiAgICAgICAgY29uc3QgeFJhdGlvID0geCAqIGludlRhcmdldFdpZHRoOwogICAgICAgIGNvbnN0IHhNYXBwZWQgPSB4MCArIHhSYXRpbyAqIHdpbmRvd1dpZHRoOwogICAgICAgIGNvbnN0IHJhd1ggPSBlZmZlY3RpdmVTb3VyY2VXaWR0aCAqIHhNYXBwZWQgKyBidWZmZXI7CiAgICAgICAgY29uc3QgeGwgPSBNYXRoLmZsb29yKHJhd1gpOwogICAgICAgIGNvbnN0IHhoID0gTWF0aC5taW4oTWF0aC5jZWlsKHJhd1gpLCBzb3VyY2VXaWR0aCAtIGJ1ZmZlciAtIDEpOwogICAgICAgIGNvbnN0IHR4RnJhY3Rpb24gPSByYXdYIC0geGw7CiAgICAgICAgY29uc3QgY2VudGVyID0gZGF0YVt5bCAqIHNvdXJjZVdpZHRoICsgeGxdOwogICAgICAgIGNvbnN0IG5laWdoYm9ycyA9IFsKICAgICAgICAgIGRhdGFbeWwgKiBzb3VyY2VXaWR0aCArIHhsXSwKICAgICAgICAgIGRhdGFbeWwgKiBzb3VyY2VXaWR0aCArIHhoXSwKICAgICAgICAgIGRhdGFbeWggKiBzb3VyY2VXaWR0aCArIHhsXSwKICAgICAgICAgIGRhdGFbeWggKiBzb3VyY2VXaWR0aCArIHhoXQogICAgICAgIF07CiAgICAgICAgbmVpZ2hib3JzLmZvckVhY2goKG5laWdoYm9yLCBpbmRleCkgPT4gewogICAgICAgICAgaWYgKGlzTm9kYXRhKG5laWdoYm9yKSkgewogICAgICAgICAgICBuZWlnaGJvcnNbaW5kZXhdID0gY2VudGVyOwogICAgICAgICAgfQogICAgICAgIH0pOwogICAgICAgIGlmIChpc05vZGF0YShjZW50ZXIpKSB7CiAgICAgICAgICBuZXdBcnJheVt5ICogdGFyZ2V0V2lkdGggKyB4XSA9IG5vZGF0YTsKICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgIH0KICAgICAgICBjb25zdCBbbGwsIGhsLCBsaCwgaGhdID0gbmVpZ2hib3JzOwogICAgICAgIGNvbnN0IHYwID0gbGVycChsbCwgaGwsIHR4RnJhY3Rpb24pOwogICAgICAgIGNvbnN0IHYxID0gbGVycChsaCwgaGgsIHR4RnJhY3Rpb24pOwogICAgICAgIGNvbnN0IHZhbHVlID0gbGVycCh2MCwgdjEsIHR5KTsKICAgICAgICBuZXdBcnJheVt5ICogdGFyZ2V0V2lkdGggKyB4XSA9IHZhbHVlOwogICAgICB9CiAgICB9CiAgICByZXR1cm4gbmV3QXJyYXk7CiAgfQoKICBvbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7CiAgICBjb25zdCB7IGRhdGEsIG9wdGlvbnMsIGlkIH0gPSBlLmRhdGE7CiAgICBjb25zdCByZXN1bHQgPSByZXNhbXBsZURhdGEoZGF0YSwgb3B0aW9ucyk7CiAgICBwb3N0TWVzc2FnZSh7IGRhdGE6IHJlc3VsdCwgaWQgfSk7CiAgfTsKCn0pKCk7Ci8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmtlci5qcy5tYXAKCg==', null, false);\n/* eslint-enable */\n\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$1 = (obj, key, value) => {\n  __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __async$1 = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nconst defaultPoolSize = typeof navigator !== \"undefined\" ? navigator.hardwareConcurrency || 2 : 2;\nclass WorkerPool {\n  /**\n   * @constructor\n   * @param {Number} [size] The size of the pool. Defaults to the number of CPUs\n   *                      available. When this parameter is `null` or 0, then the\n   *                      decoding will be done in the main thread.\n   */\n  constructor(size = defaultPoolSize) {\n    __publicField$1(this, \"workers\");\n    __publicField$1(this, \"size\");\n    __publicField$1(this, \"messageId\");\n    this.workers = null;\n    this.size = size != null ? size : 0;\n    this.messageId = 0;\n    if (size) {\n      this.workers = [];\n      for (let i = 0; i < size; i++) {\n        this.workers.push({ worker: WorkerFactory(), idle: true });\n      }\n    }\n  }\n  resample(data, options) {\n    return __async$1(this, null, function* () {\n      return this.size === 0 ? resampleData(data, options) : new Promise((resolve) => {\n        const worker = this.workers.find((candidate) => candidate.idle) || this.workers[Math.floor(Math.random() * this.size)];\n        worker.idle = false;\n        const id = this.messageId++;\n        const onMessage = (e) => {\n          if (e.data.id === id) {\n            worker.idle = true;\n            resolve(e.data.data);\n            worker.worker.removeEventListener(\"message\", onMessage);\n          }\n        };\n        worker.worker.addEventListener(\"message\", onMessage);\n        worker.worker.postMessage({ data, options, id });\n      });\n    });\n  }\n  destroy() {\n    if (this.workers) {\n      this.workers.forEach((worker) => {\n        worker.worker.terminate();\n      });\n      this.workers = null;\n    }\n  }\n}\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nconst canvas = createCanavas(256, 256);\nclass TIFFImageryProvider {\n  constructor(options) {\n    this.options = options;\n    __publicField(this, \"ready\");\n    __publicField(this, \"tilingScheme\");\n    __publicField(this, \"rectangle\");\n    __publicField(this, \"tileSize\");\n    __publicField(this, \"tileWidth\");\n    __publicField(this, \"tileHeight\");\n    __publicField(this, \"maximumLevel\");\n    __publicField(this, \"minimumLevel\");\n    __publicField(this, \"credit\");\n    __publicField(this, \"errorEvent\");\n    __publicField(this, \"readyPromise\");\n    __publicField(this, \"bands\");\n    __publicField(this, \"noData\");\n    __publicField(this, \"hasAlphaChannel\");\n    __publicField(this, \"plot\");\n    __publicField(this, \"renderOptions\");\n    __publicField(this, \"readSamples\");\n    __publicField(this, \"requestLevels\");\n    __publicField(this, \"bbox\");\n    __publicField(this, \"_destroyed\", false);\n    __publicField(this, \"_source\");\n    __publicField(this, \"_imageCount\");\n    __publicField(this, \"_images\", []);\n    __publicField(this, \"_imagesCache\", /* @__PURE__ */ new Map());\n    __publicField(this, \"_cacheSize\");\n    __publicField(this, \"_isTiled\");\n    __publicField(this, \"_proj\");\n    __publicField(this, \"origin\");\n    __publicField(this, \"reverseY\", false);\n    __publicField(this, \"samples\");\n    __publicField(this, \"workerPool\");\n    __publicField(this, \"geotiffWorkerPool\");\n    var _a, _b, _c, _d;\n    this.hasAlphaChannel = (_a = options.hasAlphaChannel) != null ? _a : true;\n    this.maximumLevel = (_b = options.maximumLevel) != null ? _b : 18;\n    this.minimumLevel = (_c = options.minimumLevel) != null ? _c : 0;\n    this.credit = new terriajs_cesium_Source_Core_Credit__WEBPACK_IMPORTED_MODULE_2___default.a(options.credit || \"\", false);\n    this.errorEvent = new terriajs_cesium_Source_Core_Event__WEBPACK_IMPORTED_MODULE_5___default.a();\n    this._cacheSize = (_d = options.cacheSize) != null ? _d : 100;\n    this.workerPool = new WorkerPool(options.workerPoolSize);\n    this.geotiffWorkerPool = new geotiff__WEBPACK_IMPORTED_MODULE_11__[\"Pool\"](options.workerPoolSize);\n    this.ready = false;\n    if (terriajs_cesium_Source_Core_defined__WEBPACK_IMPORTED_MODULE_3___default()(options.url)) {\n      this.readyPromise = this._build(options.url, options).then(() => {\n        return true;\n      });\n    }\n  }\n  get isDestroyed() {\n    return this._destroyed;\n  }\n  _build(_0) {\n    return __async(this, arguments, function* (url, options = {}) {\n      var _a, _b, _c, _d, _e, _f, _g;\n      const { tileSize, renderOptions, projFunc, requestOptions } = options;\n      let source = yield url instanceof File || url instanceof Blob ? Object(geotiff__WEBPACK_IMPORTED_MODULE_11__[\"fromBlob\"])(url) : Object(geotiff__WEBPACK_IMPORTED_MODULE_11__[\"fromUrl\"])(url, requestOptions);\n      let image = yield source.getImage();\n      this._isTiled = image.isTiled;\n      if (!this._isTiled && typeof url === \"string\") {\n        source = yield Object(geotiff__WEBPACK_IMPORTED_MODULE_11__[\"fromBlob\"])(yield (yield fetch(url)).blob());\n        image = yield source.getImage();\n      }\n      this._source = source;\n      this.origin = this._getOrigin(image);\n      this.bbox = image.getBoundingBox();\n      this.reverseY = this._checkIfReversed(image);\n      const [west, south, east, north] = this.bbox;\n      const prjCode = +((_a = image.geoKeys.ProjectedCSTypeGeoKey) != null ? _a : image.geoKeys.GeographicTypeGeoKey);\n      this._proj = projFunc == null ? void 0 : projFunc(prjCode);\n      if (prjCode === 3857 || prjCode === 900913) {\n        this.tilingScheme = new terriajs_cesium_Source_Core_WebMercatorTilingScheme__WEBPACK_IMPORTED_MODULE_9___default.a({\n          rectangleNortheastInMeters: new terriajs_cesium_Source_Core_Cartesian2__WEBPACK_IMPORTED_MODULE_0___default.a(east, north),\n          rectangleSouthwestInMeters: new terriajs_cesium_Source_Core_Cartesian2__WEBPACK_IMPORTED_MODULE_0___default.a(west, south)\n        });\n      } else if (prjCode === 4326) {\n        this.tilingScheme = new terriajs_cesium_Source_Core_GeographicTilingScheme__WEBPACK_IMPORTED_MODULE_6___default.a({\n          rectangle: terriajs_cesium_Source_Core_Rectangle__WEBPACK_IMPORTED_MODULE_8___default.a.fromDegrees(...this.bbox),\n          numberOfLevelZeroTilesX: 1,\n          numberOfLevelZeroTilesY: 1\n        });\n      } else if (typeof ((_b = this._proj) == null ? void 0 : _b.project) === \"function\" && typeof ((_c = this._proj) == null ? void 0 : _c.unproject) === \"function\") {\n        console.warn(`[Experimental] Reprojection EPSG:${prjCode}`);\n        this.tilingScheme = new TIFFImageryProviderTilingScheme(__spreadValues({\n          rectangleNortheastInMeters: new terriajs_cesium_Source_Core_Cartesian2__WEBPACK_IMPORTED_MODULE_0___default.a(east, north),\n          rectangleSouthwestInMeters: new terriajs_cesium_Source_Core_Cartesian2__WEBPACK_IMPORTED_MODULE_0___default.a(west, south)\n        }, this._proj));\n      } else {\n        const error = new terriajs_cesium_Source_Core_DeveloperError__WEBPACK_IMPORTED_MODULE_4___default.a(`Unspported projection type: EPSG:${prjCode}, please add projFunc parameter to handle projection`);\n        throw error;\n      }\n      this.rectangle = this.tilingScheme.rectangle;\n      if (this.rectangle.east < this.rectangle.west) {\n        this.rectangle.east += terriajs_cesium_Source_Core_Math__WEBPACK_IMPORTED_MODULE_7___default.a.TWO_PI;\n      }\n      this._imageCount = yield source.getImageCount();\n      this.tileSize = this.tileWidth = tileSize || (this._isTiled ? image.getTileWidth() : image.getWidth()) || 256;\n      this.tileHeight = tileSize || (this._isTiled ? image.getTileHeight() : image.getHeight()) || 256;\n      console.log(this.tileWidth, this.tileHeight);\n      this.requestLevels = this._isTiled ? yield this._getCogLevels() : [0];\n      this._images = new Array(this._imageCount).fill(null);\n      const samples = image.getSamplesPerPixel();\n      this.samples = samples;\n      this.renderOptions = renderOptions != null ? renderOptions : {};\n      const noData = image.getGDALNoData();\n      this.noData = (_d = this.renderOptions.nodata) != null ? _d : noData;\n      if (samples < 3 && this.renderOptions.convertToRGB) {\n        const error = new terriajs_cesium_Source_Core_DeveloperError__WEBPACK_IMPORTED_MODULE_4___default.a(\"Can not render the image as RGB, please check the convertToRGB parameter\");\n        throw error;\n      }\n      if (!this.renderOptions.single && !this.renderOptions.multi && !this.renderOptions.convertToRGB) {\n        if (samples > 2) {\n          this.renderOptions = __spreadValues({\n            convertToRGB: true\n          }, this.renderOptions);\n        } else {\n          this.renderOptions = __spreadValues({\n            single: {\n              band: 1\n            }\n          }, this.renderOptions);\n        }\n      }\n      if (this.renderOptions.single) {\n        this.renderOptions.single.band = (_e = this.renderOptions.single.band) != null ? _e : 1;\n      }\n      const { single, multi, convertToRGB } = this.renderOptions;\n      this.readSamples = multi ? [multi.r.band - 1, multi.g.band - 1, multi.b.band - 1] : convertToRGB ? [0, 1, 2] : [single.band - 1];\n      if (single == null ? void 0 : single.expression) {\n        this.readSamples = findAndSortBandNumbers(single.expression);\n      }\n      const bands = {};\n      yield Promise.all(this.readSamples.map((i) => __async(this, null, function* () {\n        const element = image.getGDALMetadata(i);\n        const bandNum = i + 1;\n        if ((element == null ? void 0 : element.STATISTICS_MINIMUM) && (element == null ? void 0 : element.STATISTICS_MAXIMUM)) {\n          bands[bandNum] = {\n            min: +element.STATISTICS_MINIMUM,\n            max: +element.STATISTICS_MAXIMUM\n          };\n        } else {\n          if (convertToRGB) {\n            bands[bandNum] = {\n              min: 0,\n              max: 255\n            };\n          }\n          if (multi) {\n            const inputBand = multi[Object.keys(multi).find((key) => {\n              var _a2;\n              return ((_a2 = multi[key]) == null ? void 0 : _a2.band) === bandNum;\n            })];\n            if ((inputBand == null ? void 0 : inputBand.min) !== void 0 && (inputBand == null ? void 0 : inputBand.max) !== void 0) {\n              const { min, max } = inputBand;\n              bands[bandNum] = {\n                min,\n                max\n              };\n            }\n          }\n          if (single && !single.expression && single.band === bandNum && single.domain) {\n            bands[bandNum] = {\n              min: single.domain[0],\n              max: single.domain[1]\n            };\n          }\n          if (!(single == null ? void 0 : single.expression) && !bands[bandNum]) {\n            console.warn(`Can not get band${bandNum} min/max, try to calculate min/max values, or setting ${single ? \"domain\" : \"min / max\"}`);\n            const previewImage = yield source.getImage(this.requestLevels[0]);\n            const data = (yield previewImage.readRasters({\n              samples: [i],\n              pool: this.geotiffWorkerPool\n            }))[0].filter((item) => !isNaN(item));\n            bands[bandNum] = getMinMax(data, noData);\n          }\n        }\n      })));\n      this.bands = bands;\n      try {\n        if (this.renderOptions.single) {\n          const band = this.bands[single.band];\n          if (!single.expression && !band) {\n            throw new terriajs_cesium_Source_Core_DeveloperError__WEBPACK_IMPORTED_MODULE_4___default.a(`Invalid band${single.band}`);\n          }\n          const domain = (_f = single.domain) != null ? _f : [band.min, band.max];\n          this.plot = new plot(__spreadProps(__spreadValues({\n            canvas\n          }, single), {\n            domain\n          }));\n          this.plot.setNoDataValue(this.noData);\n          const { expression, colors, colorScaleImage } = single;\n          this.plot.setExpression(expression);\n          if (colors) {\n            const colorScale = generateColorScale(colors, (single == null ? void 0 : single.useRealValue) ? domain : [0, 1]);\n            addColorScale(\"temp\", colorScale.colors, colorScale.positions);\n            this.plot.setColorScale(\"temp\");\n          } else if (!colorScaleImage) {\n            this.plot.setColorScale((_g = single == null ? void 0 : single.colorScale) != null ? _g : \"blackwhite\");\n          }\n        }\n      } catch (e) {\n        console.error(e);\n        this.errorEvent.raiseEvent(e);\n      }\n      this.readyPromise = Promise.resolve(true);\n      this.ready = true;\n    });\n  }\n  static fromUrl(_0) {\n    return __async(this, arguments, function* (url, options = {}) {\n      const provider = new TIFFImageryProvider(options);\n      yield provider._build(url, __spreadProps(__spreadValues({}, options), {\n        url: void 0\n      }));\n      return provider;\n    });\n  }\n  /**\n   * Get the origin of an image.  If the image does not have an affine transform,\n   * the top-left corner of the pixel bounds is returned.\n   * @param {GeoTIFFImage} image The image.\n   * @return {Array<number>} The image origin.\n   */\n  _getOrigin(image) {\n    try {\n      return image.getOrigin().slice(0, 2);\n    } catch (_) {\n      return [0, image.fileDirectory.ImageLength];\n    }\n  }\n  _checkIfReversed(image) {\n    const pixelScale = image.getFileDirectory().ModelPixelScale;\n    if (pixelScale) {\n      const pixelScaleY = pixelScale[1];\n      if (pixelScaleY < 0)\n        return true;\n    }\n    const transformation = image.getFileDirectory().ModelTransformation;\n    if (transformation) {\n      const originX = transformation[3];\n      const originY = transformation[7];\n      if (originY > originX)\n        return true;\n    }\n    return false;\n  }\n  /**\n   * get suitable cog levels\n   */\n  _getCogLevels() {\n    return __async(this, null, function* () {\n      const levels = [];\n      let maximumLevel = this._imageCount - 1;\n      for (let i = this._imageCount - 1; i >= 0; i--) {\n        const image = this._images[i] = yield this._source.getImage(i);\n        const width = image.getWidth();\n        const height = image.getHeight();\n        const size = Math.max(width, height);\n        if (i === this._imageCount - 1) {\n          const firstImageLevel = Math.ceil((size - this.tileSize) / this.tileSize);\n          levels.push(...new Array(firstImageLevel).fill(i));\n        }\n        if (size > this.tileSize * 0.5) {\n          maximumLevel = i;\n          break;\n        }\n      }\n      let nowCogLevel = maximumLevel;\n      while (nowCogLevel >= 0) {\n        levels.push(nowCogLevel--);\n      }\n      return levels;\n    });\n  }\n  /**\n   * Get tile data\n   * @param x \n   * @param y \n   * @param z \n   */\n  _loadTile(reqx, reqy, reqz) {\n    return __async(this, null, function* () {\n      var _a;\n      let x = reqx, y = reqy, z = reqz, startX = reqx, startY = reqy;\n      const maxCogLevel = this.requestLevels.length - 1;\n      if (z > maxCogLevel) {\n        z = maxCogLevel;\n        x = x >> reqz - maxCogLevel;\n        y = y >> reqz - maxCogLevel;\n        startX = x << reqz - z;\n        startY = y << reqz - z;\n      }\n      const index = this.requestLevels[z];\n      let image = this._images[index];\n      if (!image) {\n        image = this._images[index] = yield this._source.getImage(index);\n      }\n      const width = image.getWidth();\n      const height = image.getHeight();\n      const tileXNum = this.tilingScheme.getNumberOfXTilesAtLevel(z);\n      const tileYNum = this.tilingScheme.getNumberOfYTilesAtLevel(z);\n      const tilePixel = {\n        xWidth: width / tileXNum,\n        yWidth: height / tileYNum\n      };\n      let window = [\n        Math.round(x * tilePixel.xWidth),\n        Math.round(y * tilePixel.yWidth),\n        Math.round((x + 1) * tilePixel.xWidth),\n        Math.round((y + 1) * tilePixel.yWidth)\n      ];\n      if (this._proj && this.tilingScheme instanceof TIFFImageryProviderTilingScheme) {\n        const targetRect = this.tilingScheme.tileXYToNativeRectangle2(x, y, z);\n        const nativeRect = this.tilingScheme.nativeRectangle;\n        targetRect.west -= nativeRect.width / width;\n        targetRect.east += nativeRect.width / width;\n        targetRect.south -= nativeRect.height / height;\n        targetRect.north += nativeRect.height / height;\n        window = [\n          ~~((targetRect.west - nativeRect.west) / nativeRect.width * width),\n          ~~((nativeRect.north - targetRect.north) / nativeRect.height * height),\n          ~~((targetRect.east - nativeRect.west) / nativeRect.width * width),\n          ~~((nativeRect.north - targetRect.south) / nativeRect.height * height)\n        ];\n      }\n      if (this.reverseY) {\n        window = [window[0], height - window[3], window[2], height - window[1]];\n      }\n      const buffer = 1;\n      window = [window[0] - buffer, window[1] - buffer, window[2] + buffer, window[3] + buffer];\n      const sourceWidth = window[2] - window[0], sourceHeight = window[3] - window[1];\n      const options = {\n        window,\n        pool: this.geotiffWorkerPool,\n        samples: this.readSamples,\n        fillValue: this.noData,\n        interleave: false\n      };\n      let res;\n      try {\n        if (this.renderOptions.convertToRGB) {\n          res = yield image.readRGB(options);\n        } else {\n          res = yield image.readRasters(options);\n          if (this.reverseY) {\n            res = yield Promise.all(res.map((array) => reverseArray({ array, width: res.width, height: res.height })));\n          }\n        }\n        if (((_a = this._proj) == null ? void 0 : _a.project) && this.tilingScheme instanceof TIFFImageryProviderTilingScheme) {\n          const sourceRect = this.tilingScheme.tileXYToNativeRectangle2(x, y, z);\n          const targetRect = this.tilingScheme.tileXYToRectangle(x, y, z);\n          const sourceBBox = [sourceRect.west, sourceRect.south, sourceRect.east, sourceRect.north];\n          const targetBBox = [targetRect.west, targetRect.south, targetRect.east, targetRect.north].map(terriajs_cesium_Source_Core_Math__WEBPACK_IMPORTED_MODULE_7___default.a.toDegrees);\n          const result = [];\n          for (let i = 0; i < res.length; i++) {\n            const prjData = reprojection({\n              data: res[i],\n              sourceWidth,\n              sourceHeight,\n              nodata: this.noData,\n              project: this._proj.project,\n              sourceBBox,\n              targetBBox\n            });\n            result.push(prjData);\n          }\n          res = result;\n        }\n        const tileNum = 1 << reqz - z;\n        const x0 = (reqx - startX) / tileNum;\n        const y0 = (reqy - startY) / tileNum;\n        const step = 1 / (1 << reqz - z);\n        const x1 = x0 + step;\n        const y1 = y0 + step;\n        res = yield Promise.all(res.map((data) => __async(this, null, function* () {\n          return this.workerPool.resample(data, {\n            sourceWidth,\n            sourceHeight,\n            targetWidth: this.tileWidth,\n            targetHeight: this.tileHeight,\n            window: [x0, y0, x1, y1],\n            method: this.renderOptions.resampleMethod,\n            buffer,\n            nodata: this.noData\n          });\n        })));\n        return {\n          data: res,\n          width: this.tileWidth,\n          height: this.tileHeight\n        };\n      } catch (error) {\n        this.errorEvent.raiseEvent(error);\n        throw error;\n      }\n    });\n  }\n  requestImage(x, y, z) {\n    return __async(this, null, function* () {\n      var _a;\n      if (!this.ready) {\n        throw new terriajs_cesium_Source_Core_DeveloperError__WEBPACK_IMPORTED_MODULE_4___default.a(\n          \"requestImage must not be called before the imagery provider is ready.\"\n        );\n      }\n      if (z < this.minimumLevel || z > this.maximumLevel)\n        return void 0;\n      const cacheKey = `${x}_${y}_${z}`;\n      if (this._imagesCache.has(cacheKey)) {\n        return this._imagesCache.get(cacheKey);\n      }\n      const { single, multi, convertToRGB } = this.renderOptions;\n      try {\n        const { width, height, data } = yield this._loadTile(x, y, z);\n        if (this._destroyed || !width || !height) {\n          return void 0;\n        }\n        let result;\n        if (multi || convertToRGB) {\n          const opts = {\n            data,\n            width,\n            height,\n            renderOptions: multi != null ? multi : [\"r\", \"g\", \"b\"].reduce((pre, val, index) => __spreadProps(__spreadValues({}, pre), {\n              [val]: {\n                band: index + 1,\n                min: 0,\n                max: 255\n              }\n            }), {}),\n            bands: this.bands,\n            noData: this.noData,\n            colorMapping: Object.entries((_a = this.renderOptions.colorMapping) != null ? _a : { \"black\": \"transparent\" }).map((val) => val.map(stringColorToRgba))\n          };\n          result = yield generateImage(opts);\n        } else if (single && this.plot) {\n          const { band = 1 } = single;\n          this.plot.removeAllDataset();\n          this.readSamples.forEach((sample, index) => {\n            this.plot.addDataset(`b${sample + 1}`, data[index], width, height);\n          });\n          if (single.expression) {\n            this.plot.render();\n          } else {\n            this.plot.renderDataset(`b${band}`);\n          }\n          const canv = createCanavas(this.tileWidth, this.tileHeight);\n          const ctx = canv.getContext(\"2d\");\n          ctx.drawImage(this.plot.canvas, 0, 0);\n          result = canv;\n        }\n        if (result) {\n          if (this._imagesCache.size >= this._cacheSize) {\n            const oldestKey = this._imagesCache.keys().next().value;\n            this._imagesCache.delete(oldestKey);\n          }\n          this._imagesCache.set(cacheKey, result);\n        }\n        return result;\n      } catch (e) {\n        console.error(e);\n        this.errorEvent.raiseEvent(e);\n        throw e;\n      }\n    });\n  }\n  pickFeatures(x, y, zoom, longitude, latitude) {\n    return __async(this, null, function* () {\n      if (!this.options.enablePickFeatures)\n        return void 0;\n      const z = zoom > this.maximumLevel ? this.maximumLevel : zoom;\n      const index = this.requestLevels[z];\n      let image = this._images[index];\n      if (!image) {\n        image = this._images[index] = yield this._source.getImage(index);\n      }\n      const width = image.getWidth();\n      const height = image.getHeight();\n      let posX, posY, window;\n      const { west, south, north, width: lonWidth } = this.rectangle;\n      let lonGap = longitude - west;\n      if (longitude < west) {\n        lonGap += terriajs_cesium_Source_Core_Math__WEBPACK_IMPORTED_MODULE_7___default.a.TWO_PI;\n      }\n      posX = ~~(Math.abs(lonGap / lonWidth) * width);\n      posY = ~~(Math.abs((north - latitude) / (north - south)) * height);\n      window = [posX, posY, posX + 1, posY + 1];\n      if (this.reverseY) {\n        posY = height - posY;\n        window = [posX, posY - 1, posX + 1, posY];\n      }\n      const options = {\n        window,\n        height: 1,\n        width: 1,\n        pool: this.geotiffWorkerPool,\n        interleave: false\n      };\n      let res;\n      if (this.renderOptions.convertToRGB) {\n        res = yield image.readRGB(options);\n      } else {\n        res = yield image.readRasters(options);\n      }\n      const featureInfo = new terriajs_cesium_Source_Scene_ImageryLayerFeatureInfo__WEBPACK_IMPORTED_MODULE_10___default.a();\n      featureInfo.name = `lon:${(longitude / Math.PI * 180).toFixed(6)}, lat:${(latitude / Math.PI * 180).toFixed(6)}`;\n      const data = {};\n      res == null ? void 0 : res.forEach((item, index2) => {\n        data[index2] = item == null ? void 0 : item[0];\n      });\n      featureInfo.data = data;\n      if (res) {\n        featureInfo.configureDescriptionFromProperties(data);\n      }\n      return [featureInfo];\n    });\n  }\n  destroy() {\n    var _a;\n    if (this._imagesCache) {\n      for (const key in this._imagesCache) {\n        delete this._imagesCache[key];\n      }\n      this._imagesCache.clear();\n    }\n    if (this.workerPool) {\n      this.workerPool.destroy();\n    }\n    if (this.plot && this.plot.gl) {\n      for (const programKey in this.plot.programCache) {\n        this.plot.gl.deleteProgram(this.plot.programCache[programKey]);\n      }\n      this.plot.gl.deleteBuffer(this.plot.positionBuffer);\n    }\n    (_a = this.plot) == null ? void 0 : _a.destroy();\n    this._images = [];\n    this._source = void 0;\n    this._destroyed = true;\n  }\n}\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGVycmlhanMtdGlmZi1pbWFnZXJ5LXByb3ZpZGVyL2Rpc3QvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGVycmlhanMtdGlmZi1pbWFnZXJ5LXByb3ZpZGVyL2Rpc3QvaW5kZXguanM/OGFjNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ2FydGVzaWFuMiBmcm9tICd0ZXJyaWFqcy1jZXNpdW0vU291cmNlL0NvcmUvQ2FydGVzaWFuMic7XG5pbXBvcnQgQ29sb3IgZnJvbSAndGVycmlhanMtY2VzaXVtL1NvdXJjZS9Db3JlL0NvbG9yJztcbmltcG9ydCBDcmVkaXQgZnJvbSAndGVycmlhanMtY2VzaXVtL1NvdXJjZS9Db3JlL0NyZWRpdCc7XG5pbXBvcnQgZGVmaW5lZCBmcm9tICd0ZXJyaWFqcy1jZXNpdW0vU291cmNlL0NvcmUvZGVmaW5lZCc7XG5pbXBvcnQgRGV2ZWxvcGVyRXJyb3IgZnJvbSAndGVycmlhanMtY2VzaXVtL1NvdXJjZS9Db3JlL0RldmVsb3BlckVycm9yJztcbmltcG9ydCBFdmVudCBmcm9tICd0ZXJyaWFqcy1jZXNpdW0vU291cmNlL0NvcmUvRXZlbnQnO1xuaW1wb3J0IEdlb2dyYXBoaWNUaWxpbmdTY2hlbWUgZnJvbSAndGVycmlhanMtY2VzaXVtL1NvdXJjZS9Db3JlL0dlb2dyYXBoaWNUaWxpbmdTY2hlbWUnO1xuaW1wb3J0IENlc2l1bU1hdGggZnJvbSAndGVycmlhanMtY2VzaXVtL1NvdXJjZS9Db3JlL01hdGgnO1xuaW1wb3J0IFJlY3RhbmdsZSBmcm9tICd0ZXJyaWFqcy1jZXNpdW0vU291cmNlL0NvcmUvUmVjdGFuZ2xlJztcbmltcG9ydCBXZWJNZXJjYXRvclRpbGluZ1NjaGVtZSBmcm9tICd0ZXJyaWFqcy1jZXNpdW0vU291cmNlL0NvcmUvV2ViTWVyY2F0b3JUaWxpbmdTY2hlbWUnO1xuaW1wb3J0IEltYWdlcnlMYXllckZlYXR1cmVJbmZvIGZyb20gJ3RlcnJpYWpzLWNlc2l1bS9Tb3VyY2UvU2NlbmUvSW1hZ2VyeUxheWVyRmVhdHVyZUluZm8nO1xuaW1wb3J0IHsgUG9vbCwgZnJvbUJsb2IsIGZyb21VcmwgfSBmcm9tICdnZW90aWZmJztcbmltcG9ydCBDYXJ0b2dyYXBoaWMgZnJvbSAndGVycmlhanMtY2VzaXVtL1NvdXJjZS9Db3JlL0NhcnRvZ3JhcGhpYyc7XG5pbXBvcnQgQ2FydGVzaWFuMyBmcm9tICd0ZXJyaWFqcy1jZXNpdW0vU291cmNlL0NvcmUvQ2FydGVzaWFuMyc7XG5cbmNvbnN0IGNvbG9yc2NhbGVzID0ge1xuICB2aXJpZGlzOiBuZXcgVWludDhBcnJheShbNjgsIDEsIDg0LCAyNTUsIDY4LCAyLCA4NiwgMjU1LCA2OSwgNCwgODcsIDI1NSwgNjksIDUsIDg5LCAyNTUsIDcwLCA3LCA5MCwgMjU1LCA3MCwgOCwgOTIsIDI1NSwgNzAsIDEwLCA5MywgMjU1LCA3MCwgMTEsIDk0LCAyNTUsIDcxLCAxMywgOTYsIDI1NSwgNzEsIDE0LCA5NywgMjU1LCA3MSwgMTYsIDk5LCAyNTUsIDcxLCAxNywgMTAwLCAyNTUsIDcxLCAxOSwgMTAxLCAyNTUsIDcyLCAyMCwgMTAzLCAyNTUsIDcyLCAyMiwgMTA0LCAyNTUsIDcyLCAyMywgMTA1LCAyNTUsIDcyLCAyNCwgMTA2LCAyNTUsIDcyLCAyNiwgMTA4LCAyNTUsIDcyLCAyNywgMTA5LCAyNTUsIDcyLCAyOCwgMTEwLCAyNTUsIDcyLCAyOSwgMTExLCAyNTUsIDcyLCAzMSwgMTEyLCAyNTUsIDcyLCAzMiwgMTEzLCAyNTUsIDcyLCAzMywgMTE1LCAyNTUsIDcyLCAzNSwgMTE2LCAyNTUsIDcyLCAzNiwgMTE3LCAyNTUsIDcyLCAzNywgMTE4LCAyNTUsIDcyLCAzOCwgMTE5LCAyNTUsIDcyLCA0MCwgMTIwLCAyNTUsIDcyLCA0MSwgMTIxLCAyNTUsIDcxLCA0MiwgMTIyLCAyNTUsIDcxLCA0NCwgMTIyLCAyNTUsIDcxLCA0NSwgMTIzLCAyNTUsIDcxLCA0NiwgMTI0LCAyNTUsIDcxLCA0NywgMTI1LCAyNTUsIDcwLCA0OCwgMTI2LCAyNTUsIDcwLCA1MCwgMTI2LCAyNTUsIDcwLCA1MSwgMTI3LCAyNTUsIDcwLCA1MiwgMTI4LCAyNTUsIDY5LCA1MywgMTI5LCAyNTUsIDY5LCA1NSwgMTI5LCAyNTUsIDY5LCA1NiwgMTMwLCAyNTUsIDY4LCA1NywgMTMxLCAyNTUsIDY4LCA1OCwgMTMxLCAyNTUsIDY4LCA1OSwgMTMyLCAyNTUsIDY3LCA2MSwgMTMyLCAyNTUsIDY3LCA2MiwgMTMzLCAyNTUsIDY2LCA2MywgMTMzLCAyNTUsIDY2LCA2NCwgMTM0LCAyNTUsIDY2LCA2NSwgMTM0LCAyNTUsIDY1LCA2NiwgMTM1LCAyNTUsIDY1LCA2OCwgMTM1LCAyNTUsIDY0LCA2OSwgMTM2LCAyNTUsIDY0LCA3MCwgMTM2LCAyNTUsIDYzLCA3MSwgMTM2LCAyNTUsIDYzLCA3MiwgMTM3LCAyNTUsIDYyLCA3MywgMTM3LCAyNTUsIDYyLCA3NCwgMTM3LCAyNTUsIDYyLCA3NiwgMTM4LCAyNTUsIDYxLCA3NywgMTM4LCAyNTUsIDYxLCA3OCwgMTM4LCAyNTUsIDYwLCA3OSwgMTM4LCAyNTUsIDYwLCA4MCwgMTM5LCAyNTUsIDU5LCA4MSwgMTM5LCAyNTUsIDU5LCA4MiwgMTM5LCAyNTUsIDU4LCA4MywgMTM5LCAyNTUsIDU4LCA4NCwgMTQwLCAyNTUsIDU3LCA4NSwgMTQwLCAyNTUsIDU3LCA4NiwgMTQwLCAyNTUsIDU2LCA4OCwgMTQwLCAyNTUsIDU2LCA4OSwgMTQwLCAyNTUsIDU1LCA5MCwgMTQwLCAyNTUsIDU1LCA5MSwgMTQxLCAyNTUsIDU0LCA5MiwgMTQxLCAyNTUsIDU0LCA5MywgMTQxLCAyNTUsIDUzLCA5NCwgMTQxLCAyNTUsIDUzLCA5NSwgMTQxLCAyNTUsIDUyLCA5NiwgMTQxLCAyNTUsIDUyLCA5NywgMTQxLCAyNTUsIDUxLCA5OCwgMTQxLCAyNTUsIDUxLCA5OSwgMTQxLCAyNTUsIDUwLCAxMDAsIDE0MiwgMjU1LCA1MCwgMTAxLCAxNDIsIDI1NSwgNDksIDEwMiwgMTQyLCAyNTUsIDQ5LCAxMDMsIDE0MiwgMjU1LCA0OSwgMTA0LCAxNDIsIDI1NSwgNDgsIDEwNSwgMTQyLCAyNTUsIDQ4LCAxMDYsIDE0MiwgMjU1LCA0NywgMTA3LCAxNDIsIDI1NSwgNDcsIDEwOCwgMTQyLCAyNTUsIDQ2LCAxMDksIDE0MiwgMjU1LCA0NiwgMTEwLCAxNDIsIDI1NSwgNDYsIDExMSwgMTQyLCAyNTUsIDQ1LCAxMTIsIDE0MiwgMjU1LCA0NSwgMTEzLCAxNDIsIDI1NSwgNDQsIDExMywgMTQyLCAyNTUsIDQ0LCAxMTQsIDE0MiwgMjU1LCA0NCwgMTE1LCAxNDIsIDI1NSwgNDMsIDExNiwgMTQyLCAyNTUsIDQzLCAxMTcsIDE0MiwgMjU1LCA0MiwgMTE4LCAxNDIsIDI1NSwgNDIsIDExOSwgMTQyLCAyNTUsIDQyLCAxMjAsIDE0MiwgMjU1LCA0MSwgMTIxLCAxNDIsIDI1NSwgNDEsIDEyMiwgMTQyLCAyNTUsIDQxLCAxMjMsIDE0MiwgMjU1LCA0MCwgMTI0LCAxNDIsIDI1NSwgNDAsIDEyNSwgMTQyLCAyNTUsIDM5LCAxMjYsIDE0MiwgMjU1LCAzOSwgMTI3LCAxNDIsIDI1NSwgMzksIDEyOCwgMTQyLCAyNTUsIDM4LCAxMjksIDE0MiwgMjU1LCAzOCwgMTMwLCAxNDIsIDI1NSwgMzgsIDEzMCwgMTQyLCAyNTUsIDM3LCAxMzEsIDE0MiwgMjU1LCAzNywgMTMyLCAxNDIsIDI1NSwgMzcsIDEzMywgMTQyLCAyNTUsIDM2LCAxMzQsIDE0MiwgMjU1LCAzNiwgMTM1LCAxNDIsIDI1NSwgMzUsIDEzNiwgMTQyLCAyNTUsIDM1LCAxMzcsIDE0MiwgMjU1LCAzNSwgMTM4LCAxNDEsIDI1NSwgMzQsIDEzOSwgMTQxLCAyNTUsIDM0LCAxNDAsIDE0MSwgMjU1LCAzNCwgMTQxLCAxNDEsIDI1NSwgMzMsIDE0MiwgMTQxLCAyNTUsIDMzLCAxNDMsIDE0MSwgMjU1LCAzMywgMTQ0LCAxNDEsIDI1NSwgMzMsIDE0NSwgMTQwLCAyNTUsIDMyLCAxNDYsIDE0MCwgMjU1LCAzMiwgMTQ2LCAxNDAsIDI1NSwgMzIsIDE0NywgMTQwLCAyNTUsIDMxLCAxNDgsIDE0MCwgMjU1LCAzMSwgMTQ5LCAxMzksIDI1NSwgMzEsIDE1MCwgMTM5LCAyNTUsIDMxLCAxNTEsIDEzOSwgMjU1LCAzMSwgMTUyLCAxMzksIDI1NSwgMzEsIDE1MywgMTM4LCAyNTUsIDMxLCAxNTQsIDEzOCwgMjU1LCAzMCwgMTU1LCAxMzgsIDI1NSwgMzAsIDE1NiwgMTM3LCAyNTUsIDMwLCAxNTcsIDEzNywgMjU1LCAzMSwgMTU4LCAxMzcsIDI1NSwgMzEsIDE1OSwgMTM2LCAyNTUsIDMxLCAxNjAsIDEzNiwgMjU1LCAzMSwgMTYxLCAxMzYsIDI1NSwgMzEsIDE2MSwgMTM1LCAyNTUsIDMxLCAxNjIsIDEzNSwgMjU1LCAzMiwgMTYzLCAxMzQsIDI1NSwgMzIsIDE2NCwgMTM0LCAyNTUsIDMzLCAxNjUsIDEzMywgMjU1LCAzMywgMTY2LCAxMzMsIDI1NSwgMzQsIDE2NywgMTMzLCAyNTUsIDM0LCAxNjgsIDEzMiwgMjU1LCAzNSwgMTY5LCAxMzEsIDI1NSwgMzYsIDE3MCwgMTMxLCAyNTUsIDM3LCAxNzEsIDEzMCwgMjU1LCAzNywgMTcyLCAxMzAsIDI1NSwgMzgsIDE3MywgMTI5LCAyNTUsIDM5LCAxNzMsIDEyOSwgMjU1LCA0MCwgMTc0LCAxMjgsIDI1NSwgNDEsIDE3NSwgMTI3LCAyNTUsIDQyLCAxNzYsIDEyNywgMjU1LCA0NCwgMTc3LCAxMjYsIDI1NSwgNDUsIDE3OCwgMTI1LCAyNTUsIDQ2LCAxNzksIDEyNCwgMjU1LCA0NywgMTgwLCAxMjQsIDI1NSwgNDksIDE4MSwgMTIzLCAyNTUsIDUwLCAxODIsIDEyMiwgMjU1LCA1MiwgMTgyLCAxMjEsIDI1NSwgNTMsIDE4MywgMTIxLCAyNTUsIDU1LCAxODQsIDEyMCwgMjU1LCA1NiwgMTg1LCAxMTksIDI1NSwgNTgsIDE4NiwgMTE4LCAyNTUsIDU5LCAxODcsIDExNywgMjU1LCA2MSwgMTg4LCAxMTYsIDI1NSwgNjMsIDE4OCwgMTE1LCAyNTUsIDY0LCAxODksIDExNCwgMjU1LCA2NiwgMTkwLCAxMTMsIDI1NSwgNjgsIDE5MSwgMTEyLCAyNTUsIDcwLCAxOTIsIDExMSwgMjU1LCA3MiwgMTkzLCAxMTAsIDI1NSwgNzQsIDE5MywgMTA5LCAyNTUsIDc2LCAxOTQsIDEwOCwgMjU1LCA3OCwgMTk1LCAxMDcsIDI1NSwgODAsIDE5NiwgMTA2LCAyNTUsIDgyLCAxOTcsIDEwNSwgMjU1LCA4NCwgMTk3LCAxMDQsIDI1NSwgODYsIDE5OCwgMTAzLCAyNTUsIDg4LCAxOTksIDEwMSwgMjU1LCA5MCwgMjAwLCAxMDAsIDI1NSwgOTIsIDIwMCwgOTksIDI1NSwgOTQsIDIwMSwgOTgsIDI1NSwgOTYsIDIwMiwgOTYsIDI1NSwgOTksIDIwMywgOTUsIDI1NSwgMTAxLCAyMDMsIDk0LCAyNTUsIDEwMywgMjA0LCA5MiwgMjU1LCAxMDUsIDIwNSwgOTEsIDI1NSwgMTA4LCAyMDUsIDkwLCAyNTUsIDExMCwgMjA2LCA4OCwgMjU1LCAxMTIsIDIwNywgODcsIDI1NSwgMTE1LCAyMDgsIDg2LCAyNTUsIDExNywgMjA4LCA4NCwgMjU1LCAxMTksIDIwOSwgODMsIDI1NSwgMTIyLCAyMDksIDgxLCAyNTUsIDEyNCwgMjEwLCA4MCwgMjU1LCAxMjcsIDIxMSwgNzgsIDI1NSwgMTI5LCAyMTEsIDc3LCAyNTUsIDEzMiwgMjEyLCA3NSwgMjU1LCAxMzQsIDIxMywgNzMsIDI1NSwgMTM3LCAyMTMsIDcyLCAyNTUsIDEzOSwgMjE0LCA3MCwgMjU1LCAxNDIsIDIxNCwgNjksIDI1NSwgMTQ0LCAyMTUsIDY3LCAyNTUsIDE0NywgMjE1LCA2NSwgMjU1LCAxNDksIDIxNiwgNjQsIDI1NSwgMTUyLCAyMTYsIDYyLCAyNTUsIDE1NSwgMjE3LCA2MCwgMjU1LCAxNTcsIDIxNywgNTksIDI1NSwgMTYwLCAyMTgsIDU3LCAyNTUsIDE2MiwgMjE4LCA1NSwgMjU1LCAxNjUsIDIxOSwgNTQsIDI1NSwgMTY4LCAyMTksIDUyLCAyNTUsIDE3MCwgMjIwLCA1MCwgMjU1LCAxNzMsIDIyMCwgNDgsIDI1NSwgMTc2LCAyMjEsIDQ3LCAyNTUsIDE3OCwgMjIxLCA0NSwgMjU1LCAxODEsIDIyMiwgNDMsIDI1NSwgMTg0LCAyMjIsIDQxLCAyNTUsIDE4NiwgMjIyLCA0MCwgMjU1LCAxODksIDIyMywgMzgsIDI1NSwgMTkyLCAyMjMsIDM3LCAyNTUsIDE5NCwgMjIzLCAzNSwgMjU1LCAxOTcsIDIyNCwgMzMsIDI1NSwgMjAwLCAyMjQsIDMyLCAyNTUsIDIwMiwgMjI1LCAzMSwgMjU1LCAyMDUsIDIyNSwgMjksIDI1NSwgMjA4LCAyMjUsIDI4LCAyNTUsIDIxMCwgMjI2LCAyNywgMjU1LCAyMTMsIDIyNiwgMjYsIDI1NSwgMjE2LCAyMjYsIDI1LCAyNTUsIDIxOCwgMjI3LCAyNSwgMjU1LCAyMjEsIDIyNywgMjQsIDI1NSwgMjIzLCAyMjcsIDI0LCAyNTUsIDIyNiwgMjI4LCAyNCwgMjU1LCAyMjksIDIyOCwgMjUsIDI1NSwgMjMxLCAyMjgsIDI1LCAyNTUsIDIzNCwgMjI5LCAyNiwgMjU1LCAyMzYsIDIyOSwgMjcsIDI1NSwgMjM5LCAyMjksIDI4LCAyNTUsIDI0MSwgMjI5LCAyOSwgMjU1LCAyNDQsIDIzMCwgMzAsIDI1NSwgMjQ2LCAyMzAsIDMyLCAyNTUsIDI0OCwgMjMwLCAzMywgMjU1LCAyNTEsIDIzMSwgMzUsIDI1NSwgMjUzLCAyMzEsIDM3LCAyNTVdKSxcbiAgaW5mZXJubzogbmV3IFVpbnQ4QXJyYXkoWzAsIDAsIDQsIDI1NSwgMSwgMCwgNSwgMjU1LCAxLCAxLCA2LCAyNTUsIDEsIDEsIDgsIDI1NSwgMiwgMSwgMTAsIDI1NSwgMiwgMiwgMTIsIDI1NSwgMiwgMiwgMTQsIDI1NSwgMywgMiwgMTYsIDI1NSwgNCwgMywgMTgsIDI1NSwgNCwgMywgMjAsIDI1NSwgNSwgNCwgMjMsIDI1NSwgNiwgNCwgMjUsIDI1NSwgNywgNSwgMjcsIDI1NSwgOCwgNSwgMjksIDI1NSwgOSwgNiwgMzEsIDI1NSwgMTAsIDcsIDM0LCAyNTUsIDExLCA3LCAzNiwgMjU1LCAxMiwgOCwgMzgsIDI1NSwgMTMsIDgsIDQxLCAyNTUsIDE0LCA5LCA0MywgMjU1LCAxNiwgOSwgNDUsIDI1NSwgMTcsIDEwLCA0OCwgMjU1LCAxOCwgMTAsIDUwLCAyNTUsIDIwLCAxMSwgNTIsIDI1NSwgMjEsIDExLCA1NSwgMjU1LCAyMiwgMTEsIDU3LCAyNTUsIDI0LCAxMiwgNjAsIDI1NSwgMjUsIDEyLCA2MiwgMjU1LCAyNywgMTIsIDY1LCAyNTUsIDI4LCAxMiwgNjcsIDI1NSwgMzAsIDEyLCA2OSwgMjU1LCAzMSwgMTIsIDcyLCAyNTUsIDMzLCAxMiwgNzQsIDI1NSwgMzUsIDEyLCA3NiwgMjU1LCAzNiwgMTIsIDc5LCAyNTUsIDM4LCAxMiwgODEsIDI1NSwgNDAsIDExLCA4MywgMjU1LCA0MSwgMTEsIDg1LCAyNTUsIDQzLCAxMSwgODcsIDI1NSwgNDUsIDExLCA4OSwgMjU1LCA0NywgMTAsIDkxLCAyNTUsIDQ5LCAxMCwgOTIsIDI1NSwgNTAsIDEwLCA5NCwgMjU1LCA1MiwgMTAsIDk1LCAyNTUsIDU0LCA5LCA5NywgMjU1LCA1NiwgOSwgOTgsIDI1NSwgNTcsIDksIDk5LCAyNTUsIDU5LCA5LCAxMDAsIDI1NSwgNjEsIDksIDEwMSwgMjU1LCA2MiwgOSwgMTAyLCAyNTUsIDY0LCAxMCwgMTAzLCAyNTUsIDY2LCAxMCwgMTA0LCAyNTUsIDY4LCAxMCwgMTA0LCAyNTUsIDY5LCAxMCwgMTA1LCAyNTUsIDcxLCAxMSwgMTA2LCAyNTUsIDczLCAxMSwgMTA2LCAyNTUsIDc0LCAxMiwgMTA3LCAyNTUsIDc2LCAxMiwgMTA3LCAyNTUsIDc3LCAxMywgMTA4LCAyNTUsIDc5LCAxMywgMTA4LCAyNTUsIDgxLCAxNCwgMTA4LCAyNTUsIDgyLCAxNCwgMTA5LCAyNTUsIDg0LCAxNSwgMTA5LCAyNTUsIDg1LCAxNSwgMTA5LCAyNTUsIDg3LCAxNiwgMTEwLCAyNTUsIDg5LCAxNiwgMTEwLCAyNTUsIDkwLCAxNywgMTEwLCAyNTUsIDkyLCAxOCwgMTEwLCAyNTUsIDkzLCAxOCwgMTEwLCAyNTUsIDk1LCAxOSwgMTEwLCAyNTUsIDk3LCAxOSwgMTEwLCAyNTUsIDk4LCAyMCwgMTEwLCAyNTUsIDEwMCwgMjEsIDExMCwgMjU1LCAxMDEsIDIxLCAxMTAsIDI1NSwgMTAzLCAyMiwgMTEwLCAyNTUsIDEwNSwgMjIsIDExMCwgMjU1LCAxMDYsIDIzLCAxMTAsIDI1NSwgMTA4LCAyNCwgMTEwLCAyNTUsIDEwOSwgMjQsIDExMCwgMjU1LCAxMTEsIDI1LCAxMTAsIDI1NSwgMTEzLCAyNSwgMTEwLCAyNTUsIDExNCwgMjYsIDExMCwgMjU1LCAxMTYsIDI2LCAxMTAsIDI1NSwgMTE3LCAyNywgMTEwLCAyNTUsIDExOSwgMjgsIDEwOSwgMjU1LCAxMjAsIDI4LCAxMDksIDI1NSwgMTIyLCAyOSwgMTA5LCAyNTUsIDEyNCwgMjksIDEwOSwgMjU1LCAxMjUsIDMwLCAxMDksIDI1NSwgMTI3LCAzMCwgMTA4LCAyNTUsIDEyOCwgMzEsIDEwOCwgMjU1LCAxMzAsIDMyLCAxMDgsIDI1NSwgMTMyLCAzMiwgMTA3LCAyNTUsIDEzMywgMzMsIDEwNywgMjU1LCAxMzUsIDMzLCAxMDcsIDI1NSwgMTM2LCAzNCwgMTA2LCAyNTUsIDEzOCwgMzQsIDEwNiwgMjU1LCAxNDAsIDM1LCAxMDUsIDI1NSwgMTQxLCAzNSwgMTA1LCAyNTUsIDE0MywgMzYsIDEwNSwgMjU1LCAxNDQsIDM3LCAxMDQsIDI1NSwgMTQ2LCAzNywgMTA0LCAyNTUsIDE0NywgMzgsIDEwMywgMjU1LCAxNDksIDM4LCAxMDMsIDI1NSwgMTUxLCAzOSwgMTAyLCAyNTUsIDE1MiwgMzksIDEwMiwgMjU1LCAxNTQsIDQwLCAxMDEsIDI1NSwgMTU1LCA0MSwgMTAwLCAyNTUsIDE1NywgNDEsIDEwMCwgMjU1LCAxNTksIDQyLCA5OSwgMjU1LCAxNjAsIDQyLCA5OSwgMjU1LCAxNjIsIDQzLCA5OCwgMjU1LCAxNjMsIDQ0LCA5NywgMjU1LCAxNjUsIDQ0LCA5NiwgMjU1LCAxNjYsIDQ1LCA5NiwgMjU1LCAxNjgsIDQ2LCA5NSwgMjU1LCAxNjksIDQ2LCA5NCwgMjU1LCAxNzEsIDQ3LCA5NCwgMjU1LCAxNzMsIDQ4LCA5MywgMjU1LCAxNzQsIDQ4LCA5MiwgMjU1LCAxNzYsIDQ5LCA5MSwgMjU1LCAxNzcsIDUwLCA5MCwgMjU1LCAxNzksIDUwLCA5MCwgMjU1LCAxODAsIDUxLCA4OSwgMjU1LCAxODIsIDUyLCA4OCwgMjU1LCAxODMsIDUzLCA4NywgMjU1LCAxODUsIDUzLCA4NiwgMjU1LCAxODYsIDU0LCA4NSwgMjU1LCAxODgsIDU1LCA4NCwgMjU1LCAxODksIDU2LCA4MywgMjU1LCAxOTEsIDU3LCA4MiwgMjU1LCAxOTIsIDU4LCA4MSwgMjU1LCAxOTMsIDU4LCA4MCwgMjU1LCAxOTUsIDU5LCA3OSwgMjU1LCAxOTYsIDYwLCA3OCwgMjU1LCAxOTgsIDYxLCA3NywgMjU1LCAxOTksIDYyLCA3NiwgMjU1LCAyMDAsIDYzLCA3NSwgMjU1LCAyMDIsIDY0LCA3NCwgMjU1LCAyMDMsIDY1LCA3MywgMjU1LCAyMDQsIDY2LCA3MiwgMjU1LCAyMDYsIDY3LCA3MSwgMjU1LCAyMDcsIDY4LCA3MCwgMjU1LCAyMDgsIDY5LCA2OSwgMjU1LCAyMTAsIDcwLCA2OCwgMjU1LCAyMTEsIDcxLCA2NywgMjU1LCAyMTIsIDcyLCA2NiwgMjU1LCAyMTMsIDc0LCA2NSwgMjU1LCAyMTUsIDc1LCA2MywgMjU1LCAyMTYsIDc2LCA2MiwgMjU1LCAyMTcsIDc3LCA2MSwgMjU1LCAyMTgsIDc4LCA2MCwgMjU1LCAyMTksIDgwLCA1OSwgMjU1LCAyMjEsIDgxLCA1OCwgMjU1LCAyMjIsIDgyLCA1NiwgMjU1LCAyMjMsIDgzLCA1NSwgMjU1LCAyMjQsIDg1LCA1NCwgMjU1LCAyMjUsIDg2LCA1MywgMjU1LCAyMjYsIDg3LCA1MiwgMjU1LCAyMjcsIDg5LCA1MSwgMjU1LCAyMjgsIDkwLCA0OSwgMjU1LCAyMjksIDkyLCA0OCwgMjU1LCAyMzAsIDkzLCA0NywgMjU1LCAyMzEsIDk0LCA0NiwgMjU1LCAyMzIsIDk2LCA0NSwgMjU1LCAyMzMsIDk3LCA0MywgMjU1LCAyMzQsIDk5LCA0MiwgMjU1LCAyMzUsIDEwMCwgNDEsIDI1NSwgMjM1LCAxMDIsIDQwLCAyNTUsIDIzNiwgMTAzLCAzOCwgMjU1LCAyMzcsIDEwNSwgMzcsIDI1NSwgMjM4LCAxMDYsIDM2LCAyNTUsIDIzOSwgMTA4LCAzNSwgMjU1LCAyMzksIDExMCwgMzMsIDI1NSwgMjQwLCAxMTEsIDMyLCAyNTUsIDI0MSwgMTEzLCAzMSwgMjU1LCAyNDEsIDExNSwgMjksIDI1NSwgMjQyLCAxMTYsIDI4LCAyNTUsIDI0MywgMTE4LCAyNywgMjU1LCAyNDMsIDEyMCwgMjUsIDI1NSwgMjQ0LCAxMjEsIDI0LCAyNTUsIDI0NSwgMTIzLCAyMywgMjU1LCAyNDUsIDEyNSwgMjEsIDI1NSwgMjQ2LCAxMjYsIDIwLCAyNTUsIDI0NiwgMTI4LCAxOSwgMjU1LCAyNDcsIDEzMCwgMTgsIDI1NSwgMjQ3LCAxMzIsIDE2LCAyNTUsIDI0OCwgMTMzLCAxNSwgMjU1LCAyNDgsIDEzNSwgMTQsIDI1NSwgMjQ4LCAxMzcsIDEyLCAyNTUsIDI0OSwgMTM5LCAxMSwgMjU1LCAyNDksIDE0MCwgMTAsIDI1NSwgMjQ5LCAxNDIsIDksIDI1NSwgMjUwLCAxNDQsIDgsIDI1NSwgMjUwLCAxNDYsIDcsIDI1NSwgMjUwLCAxNDgsIDcsIDI1NSwgMjUxLCAxNTAsIDYsIDI1NSwgMjUxLCAxNTEsIDYsIDI1NSwgMjUxLCAxNTMsIDYsIDI1NSwgMjUxLCAxNTUsIDYsIDI1NSwgMjUxLCAxNTcsIDcsIDI1NSwgMjUyLCAxNTksIDcsIDI1NSwgMjUyLCAxNjEsIDgsIDI1NSwgMjUyLCAxNjMsIDksIDI1NSwgMjUyLCAxNjUsIDEwLCAyNTUsIDI1MiwgMTY2LCAxMiwgMjU1LCAyNTIsIDE2OCwgMTMsIDI1NSwgMjUyLCAxNzAsIDE1LCAyNTUsIDI1MiwgMTcyLCAxNywgMjU1LCAyNTIsIDE3NCwgMTgsIDI1NSwgMjUyLCAxNzYsIDIwLCAyNTUsIDI1MiwgMTc4LCAyMiwgMjU1LCAyNTIsIDE4MCwgMjQsIDI1NSwgMjUxLCAxODIsIDI2LCAyNTUsIDI1MSwgMTg0LCAyOSwgMjU1LCAyNTEsIDE4NiwgMzEsIDI1NSwgMjUxLCAxODgsIDMzLCAyNTUsIDI1MSwgMTkwLCAzNSwgMjU1LCAyNTAsIDE5MiwgMzgsIDI1NSwgMjUwLCAxOTQsIDQwLCAyNTUsIDI1MCwgMTk2LCA0MiwgMjU1LCAyNTAsIDE5OCwgNDUsIDI1NSwgMjQ5LCAxOTksIDQ3LCAyNTUsIDI0OSwgMjAxLCA1MCwgMjU1LCAyNDksIDIwMywgNTMsIDI1NSwgMjQ4LCAyMDUsIDU1LCAyNTUsIDI0OCwgMjA3LCA1OCwgMjU1LCAyNDcsIDIwOSwgNjEsIDI1NSwgMjQ3LCAyMTEsIDY0LCAyNTUsIDI0NiwgMjEzLCA2NywgMjU1LCAyNDYsIDIxNSwgNzAsIDI1NSwgMjQ1LCAyMTcsIDczLCAyNTUsIDI0NSwgMjE5LCA3NiwgMjU1LCAyNDQsIDIyMSwgNzksIDI1NSwgMjQ0LCAyMjMsIDgzLCAyNTUsIDI0NCwgMjI1LCA4NiwgMjU1LCAyNDMsIDIyNywgOTAsIDI1NSwgMjQzLCAyMjksIDkzLCAyNTUsIDI0MiwgMjMwLCA5NywgMjU1LCAyNDIsIDIzMiwgMTAxLCAyNTUsIDI0MiwgMjM0LCAxMDUsIDI1NSwgMjQxLCAyMzYsIDEwOSwgMjU1LCAyNDEsIDIzNywgMTEzLCAyNTUsIDI0MSwgMjM5LCAxMTcsIDI1NSwgMjQxLCAyNDEsIDEyMSwgMjU1LCAyNDIsIDI0MiwgMTI1LCAyNTUsIDI0MiwgMjQ0LCAxMzAsIDI1NSwgMjQzLCAyNDUsIDEzNCwgMjU1LCAyNDMsIDI0NiwgMTM4LCAyNTUsIDI0NCwgMjQ4LCAxNDIsIDI1NSwgMjQ1LCAyNDksIDE0NiwgMjU1LCAyNDYsIDI1MCwgMTUwLCAyNTUsIDI0OCwgMjUxLCAxNTQsIDI1NSwgMjQ5LCAyNTIsIDE1NywgMjU1LCAyNTAsIDI1MywgMTYxLCAyNTUsIDI1MiwgMjU1LCAxNjQsIDI1NV0pLFxuICB0dXJibzogbmV3IFVpbnQ4QXJyYXkoWzQ4LCAxOCwgNTksIDI1NSwgNTAsIDIxLCA2NywgMjU1LCA1MSwgMjQsIDc0LCAyNTUsIDUyLCAyNywgODEsIDI1NSwgNTMsIDMwLCA4OCwgMjU1LCA1NCwgMzMsIDk1LCAyNTUsIDU1LCAzNiwgMTAyLCAyNTUsIDU2LCAzOSwgMTA5LCAyNTUsIDU3LCA0MiwgMTE1LCAyNTUsIDU4LCA0NSwgMTIxLCAyNTUsIDU5LCA0NywgMTI4LCAyNTUsIDYwLCA1MCwgMTM0LCAyNTUsIDYxLCA1MywgMTM5LCAyNTUsIDYyLCA1NiwgMTQ1LCAyNTUsIDYzLCA1OSwgMTUxLCAyNTUsIDYzLCA2MiwgMTU2LCAyNTUsIDY0LCA2NCwgMTYyLCAyNTUsIDY1LCA2NywgMTY3LCAyNTUsIDY1LCA3MCwgMTcyLCAyNTUsIDY2LCA3MywgMTc3LCAyNTUsIDY2LCA3NSwgMTgxLCAyNTUsIDY3LCA3OCwgMTg2LCAyNTUsIDY4LCA4MSwgMTkxLCAyNTUsIDY4LCA4NCwgMTk1LCAyNTUsIDY4LCA4NiwgMTk5LCAyNTUsIDY5LCA4OSwgMjAzLCAyNTUsIDY5LCA5MiwgMjA3LCAyNTUsIDY5LCA5NCwgMjExLCAyNTUsIDcwLCA5NywgMjE0LCAyNTUsIDcwLCAxMDAsIDIxOCwgMjU1LCA3MCwgMTAyLCAyMjEsIDI1NSwgNzAsIDEwNSwgMjI0LCAyNTUsIDcwLCAxMDcsIDIyNywgMjU1LCA3MSwgMTEwLCAyMzAsIDI1NSwgNzEsIDExMywgMjMzLCAyNTUsIDcxLCAxMTUsIDIzNSwgMjU1LCA3MSwgMTE4LCAyMzgsIDI1NSwgNzEsIDEyMCwgMjQwLCAyNTUsIDcxLCAxMjMsIDI0MiwgMjU1LCA3MCwgMTI1LCAyNDQsIDI1NSwgNzAsIDEyOCwgMjQ2LCAyNTUsIDcwLCAxMzAsIDI0OCwgMjU1LCA3MCwgMTMzLCAyNTAsIDI1NSwgNzAsIDEzNSwgMjUxLCAyNTUsIDY5LCAxMzgsIDI1MiwgMjU1LCA2OSwgMTQwLCAyNTMsIDI1NSwgNjgsIDE0MywgMjU0LCAyNTUsIDY3LCAxNDUsIDI1NCwgMjU1LCA2NiwgMTQ4LCAyNTUsIDI1NSwgNjUsIDE1MCwgMjU1LCAyNTUsIDY0LCAxNTMsIDI1NSwgMjU1LCA2MiwgMTU1LCAyNTQsIDI1NSwgNjEsIDE1OCwgMjU0LCAyNTUsIDU5LCAxNjAsIDI1MywgMjU1LCA1OCwgMTYzLCAyNTIsIDI1NSwgNTYsIDE2NSwgMjUxLCAyNTUsIDU1LCAxNjgsIDI1MCwgMjU1LCA1MywgMTcxLCAyNDgsIDI1NSwgNTEsIDE3MywgMjQ3LCAyNTUsIDQ5LCAxNzUsIDI0NSwgMjU1LCA0NywgMTc4LCAyNDQsIDI1NSwgNDYsIDE4MCwgMjQyLCAyNTUsIDQ0LCAxODMsIDI0MCwgMjU1LCA0MiwgMTg1LCAyMzgsIDI1NSwgNDAsIDE4OCwgMjM1LCAyNTUsIDM5LCAxOTAsIDIzMywgMjU1LCAzNywgMTkyLCAyMzEsIDI1NSwgMzUsIDE5NSwgMjI4LCAyNTUsIDM0LCAxOTcsIDIyNiwgMjU1LCAzMiwgMTk5LCAyMjMsIDI1NSwgMzEsIDIwMSwgMjIxLCAyNTUsIDMwLCAyMDMsIDIxOCwgMjU1LCAyOCwgMjA1LCAyMTYsIDI1NSwgMjcsIDIwOCwgMjEzLCAyNTUsIDI2LCAyMTAsIDIxMCwgMjU1LCAyNiwgMjEyLCAyMDgsIDI1NSwgMjUsIDIxMywgMjA1LCAyNTUsIDI0LCAyMTUsIDIwMiwgMjU1LCAyNCwgMjE3LCAyMDAsIDI1NSwgMjQsIDIxOSwgMTk3LCAyNTUsIDI0LCAyMjEsIDE5NCwgMjU1LCAyNCwgMjIyLCAxOTIsIDI1NSwgMjQsIDIyNCwgMTg5LCAyNTUsIDI1LCAyMjYsIDE4NywgMjU1LCAyNSwgMjI3LCAxODUsIDI1NSwgMjYsIDIyOCwgMTgyLCAyNTUsIDI4LCAyMzAsIDE4MCwgMjU1LCAyOSwgMjMxLCAxNzgsIDI1NSwgMzEsIDIzMywgMTc1LCAyNTUsIDMyLCAyMzQsIDE3MiwgMjU1LCAzNCwgMjM1LCAxNzAsIDI1NSwgMzcsIDIzNiwgMTY3LCAyNTUsIDM5LCAyMzgsIDE2NCwgMjU1LCA0MiwgMjM5LCAxNjEsIDI1NSwgNDQsIDI0MCwgMTU4LCAyNTUsIDQ3LCAyNDEsIDE1NSwgMjU1LCA1MCwgMjQyLCAxNTIsIDI1NSwgNTMsIDI0MywgMTQ4LCAyNTUsIDU2LCAyNDQsIDE0NSwgMjU1LCA2MCwgMjQ1LCAxNDIsIDI1NSwgNjMsIDI0NiwgMTM4LCAyNTUsIDY3LCAyNDcsIDEzNSwgMjU1LCA3MCwgMjQ4LCAxMzIsIDI1NSwgNzQsIDI0OCwgMTI4LCAyNTUsIDc4LCAyNDksIDEyNSwgMjU1LCA4MiwgMjUwLCAxMjIsIDI1NSwgODUsIDI1MCwgMTE4LCAyNTUsIDg5LCAyNTEsIDExNSwgMjU1LCA5MywgMjUyLCAxMTEsIDI1NSwgOTcsIDI1MiwgMTA4LCAyNTUsIDEwMSwgMjUzLCAxMDUsIDI1NSwgMTA1LCAyNTMsIDEwMiwgMjU1LCAxMDksIDI1NCwgOTgsIDI1NSwgMTEzLCAyNTQsIDk1LCAyNTUsIDExNywgMjU0LCA5MiwgMjU1LCAxMjEsIDI1NCwgODksIDI1NSwgMTI1LCAyNTUsIDg2LCAyNTUsIDEyOCwgMjU1LCA4MywgMjU1LCAxMzIsIDI1NSwgODEsIDI1NSwgMTM2LCAyNTUsIDc4LCAyNTUsIDEzOSwgMjU1LCA3NSwgMjU1LCAxNDMsIDI1NSwgNzMsIDI1NSwgMTQ2LCAyNTUsIDcxLCAyNTUsIDE1MCwgMjU0LCA2OCwgMjU1LCAxNTMsIDI1NCwgNjYsIDI1NSwgMTU2LCAyNTQsIDY0LCAyNTUsIDE1OSwgMjUzLCA2MywgMjU1LCAxNjEsIDI1MywgNjEsIDI1NSwgMTY0LCAyNTIsIDYwLCAyNTUsIDE2NywgMjUyLCA1OCwgMjU1LCAxNjksIDI1MSwgNTcsIDI1NSwgMTcyLCAyNTEsIDU2LCAyNTUsIDE3NSwgMjUwLCA1NSwgMjU1LCAxNzcsIDI0OSwgNTQsIDI1NSwgMTgwLCAyNDgsIDU0LCAyNTUsIDE4MywgMjQ3LCA1MywgMjU1LCAxODUsIDI0NiwgNTMsIDI1NSwgMTg4LCAyNDUsIDUyLCAyNTUsIDE5MCwgMjQ0LCA1MiwgMjU1LCAxOTMsIDI0MywgNTIsIDI1NSwgMTk1LCAyNDEsIDUyLCAyNTUsIDE5OCwgMjQwLCA1MiwgMjU1LCAyMDAsIDIzOSwgNTIsIDI1NSwgMjAzLCAyMzcsIDUyLCAyNTUsIDIwNSwgMjM2LCA1MiwgMjU1LCAyMDgsIDIzNCwgNTIsIDI1NSwgMjEwLCAyMzMsIDUzLCAyNTUsIDIxMiwgMjMxLCA1MywgMjU1LCAyMTUsIDIyOSwgNTMsIDI1NSwgMjE3LCAyMjgsIDU0LCAyNTUsIDIxOSwgMjI2LCA1NCwgMjU1LCAyMjEsIDIyNCwgNTUsIDI1NSwgMjIzLCAyMjMsIDU1LCAyNTUsIDIyNSwgMjIxLCA1NSwgMjU1LCAyMjcsIDIxOSwgNTYsIDI1NSwgMjI5LCAyMTcsIDU2LCAyNTUsIDIzMSwgMjE1LCA1NywgMjU1LCAyMzMsIDIxMywgNTcsIDI1NSwgMjM1LCAyMTEsIDU3LCAyNTUsIDIzNiwgMjA5LCA1OCwgMjU1LCAyMzgsIDIwNywgNTgsIDI1NSwgMjM5LCAyMDUsIDU4LCAyNTUsIDI0MSwgMjAzLCA1OCwgMjU1LCAyNDIsIDIwMSwgNTgsIDI1NSwgMjQ0LCAxOTksIDU4LCAyNTUsIDI0NSwgMTk3LCA1OCwgMjU1LCAyNDYsIDE5NSwgNTgsIDI1NSwgMjQ3LCAxOTMsIDU4LCAyNTUsIDI0OCwgMTkwLCA1NywgMjU1LCAyNDksIDE4OCwgNTcsIDI1NSwgMjUwLCAxODYsIDU3LCAyNTUsIDI1MSwgMTg0LCA1NiwgMjU1LCAyNTEsIDE4MiwgNTUsIDI1NSwgMjUyLCAxNzksIDU0LCAyNTUsIDI1MiwgMTc3LCA1NCwgMjU1LCAyNTMsIDE3NCwgNTMsIDI1NSwgMjUzLCAxNzIsIDUyLCAyNTUsIDI1NCwgMTY5LCA1MSwgMjU1LCAyNTQsIDE2NywgNTAsIDI1NSwgMjU0LCAxNjQsIDQ5LCAyNTUsIDI1NCwgMTYxLCA0OCwgMjU1LCAyNTQsIDE1OCwgNDcsIDI1NSwgMjU0LCAxNTUsIDQ1LCAyNTUsIDI1NCwgMTUzLCA0NCwgMjU1LCAyNTQsIDE1MCwgNDMsIDI1NSwgMjU0LCAxNDcsIDQyLCAyNTUsIDI1NCwgMTQ0LCA0MSwgMjU1LCAyNTMsIDE0MSwgMzksIDI1NSwgMjUzLCAxMzgsIDM4LCAyNTUsIDI1MiwgMTM1LCAzNywgMjU1LCAyNTIsIDEzMiwgMzUsIDI1NSwgMjUxLCAxMjksIDM0LCAyNTUsIDI1MSwgMTI2LCAzMywgMjU1LCAyNTAsIDEyMywgMzEsIDI1NSwgMjQ5LCAxMjAsIDMwLCAyNTUsIDI0OSwgMTE3LCAyOSwgMjU1LCAyNDgsIDExNCwgMjgsIDI1NSwgMjQ3LCAxMTEsIDI2LCAyNTUsIDI0NiwgMTA4LCAyNSwgMjU1LCAyNDUsIDEwNSwgMjQsIDI1NSwgMjQ0LCAxMDIsIDIzLCAyNTUsIDI0MywgOTksIDIxLCAyNTUsIDI0MiwgOTYsIDIwLCAyNTUsIDI0MSwgOTMsIDE5LCAyNTUsIDI0MCwgOTEsIDE4LCAyNTUsIDIzOSwgODgsIDE3LCAyNTUsIDIzNywgODUsIDE2LCAyNTUsIDIzNiwgODMsIDE1LCAyNTUsIDIzNSwgODAsIDE0LCAyNTUsIDIzNCwgNzgsIDEzLCAyNTUsIDIzMiwgNzUsIDEyLCAyNTUsIDIzMSwgNzMsIDEyLCAyNTUsIDIyOSwgNzEsIDExLCAyNTUsIDIyOCwgNjksIDEwLCAyNTUsIDIyNiwgNjcsIDEwLCAyNTUsIDIyNSwgNjUsIDksIDI1NSwgMjIzLCA2MywgOCwgMjU1LCAyMjEsIDYxLCA4LCAyNTUsIDIyMCwgNTksIDcsIDI1NSwgMjE4LCA1NywgNywgMjU1LCAyMTYsIDU1LCA2LCAyNTUsIDIxNCwgNTMsIDYsIDI1NSwgMjEyLCA1MSwgNSwgMjU1LCAyMTAsIDQ5LCA1LCAyNTUsIDIwOCwgNDcsIDUsIDI1NSwgMjA2LCA0NSwgNCwgMjU1LCAyMDQsIDQzLCA0LCAyNTUsIDIwMiwgNDIsIDQsIDI1NSwgMjAwLCA0MCwgMywgMjU1LCAxOTcsIDM4LCAzLCAyNTUsIDE5NSwgMzcsIDMsIDI1NSwgMTkzLCAzNSwgMiwgMjU1LCAxOTAsIDMzLCAyLCAyNTUsIDE4OCwgMzIsIDIsIDI1NSwgMTg1LCAzMCwgMiwgMjU1LCAxODMsIDI5LCAyLCAyNTUsIDE4MCwgMjcsIDEsIDI1NSwgMTc4LCAyNiwgMSwgMjU1LCAxNzUsIDI0LCAxLCAyNTUsIDE3MiwgMjMsIDEsIDI1NSwgMTY5LCAyMiwgMSwgMjU1LCAxNjcsIDIwLCAxLCAyNTUsIDE2NCwgMTksIDEsIDI1NSwgMTYxLCAxOCwgMSwgMjU1LCAxNTgsIDE2LCAxLCAyNTUsIDE1NSwgMTUsIDEsIDI1NSwgMTUyLCAxNCwgMSwgMjU1LCAxNDksIDEzLCAxLCAyNTUsIDE0NiwgMTEsIDEsIDI1NSwgMTQyLCAxMCwgMSwgMjU1LCAxMzksIDksIDIsIDI1NSwgMTM2LCA4LCAyLCAyNTUsIDEzMywgNywgMiwgMjU1LCAxMjksIDYsIDIsIDI1NSwgMTI2LCA1LCAyLCAyNTUsIDEyMiwgNCwgMywgMjU1XSksXG4gIHJhaW5ib3c6IHtcbiAgICBjb2xvcnM6IFtcIiM5NjAwNUFcIiwgXCIjMDAwMEM4XCIsIFwiIzAwMTlGRlwiLCBcIiMwMDk4RkZcIiwgXCIjMkNGRjk2XCIsIFwiIzk3RkYwMFwiLCBcIiNGRkVBMDBcIiwgXCIjRkY2RjAwXCIsIFwiI0ZGMDAwMFwiXSxcbiAgICBwb3NpdGlvbnM6IFswLCAwLjEyNSwgMC4yNSwgMC4zNzUsIDAuNSwgMC42MjUsIDAuNzUsIDAuODc1LCAxXVxuICB9LFxuICBqZXQ6IHtcbiAgICBjb2xvcnM6IFtcIiMwMDAwODNcIiwgXCIjMDAzQ0FBXCIsIFwiIzA1RkZGRlwiLCBcIiNGRkZGMDBcIiwgXCIjRkEwMDAwXCIsIFwiIzgwMDAwMFwiXSxcbiAgICBwb3NpdGlvbnM6IFswLCAwLjEyNSwgMC4zNzUsIDAuNjI1LCAwLjg3NSwgMV1cbiAgfSxcbiAgaHN2OiB7XG4gICAgY29sb3JzOiBbXCIjZmYwMDAwXCIsIFwiI2ZkZmYwMlwiLCBcIiNmN2ZmMDJcIiwgXCIjMDBmYzA0XCIsIFwiIzAwZmMwYVwiLCBcIiMwMWY5ZmZcIiwgXCIjMDIwMGZkXCIsIFwiIzA4MDBmZFwiLCBcIiNmZjAwZmJcIiwgXCIjZmYwMGY1XCIsIFwiI2ZmMDAwNlwiXSxcbiAgICBwb3NpdGlvbnM6IFswLCAwLjE2OSwgMC4xNzMsIDAuMzM3LCAwLjM0MSwgMC41MDYsIDAuNjcxLCAwLjY3NSwgMC44MzksIDAuODQzLCAxXVxuICB9LFxuICBob3Q6IHtcbiAgICBjb2xvcnM6IFtcIiMwMDAwMDBcIiwgXCIjZTYwMDAwXCIsIFwiI2ZmZDIwMFwiLCBcIiNmZmZmZmZcIl0sXG4gICAgcG9zaXRpb25zOiBbMCwgMC4zLCAwLjYsIDFdXG4gIH0sXG4gIGNvb2w6IHtcbiAgICBjb2xvcnM6IFtcIiMwMGZmZmZcIiwgXCIjZmYwMGZmXCJdLFxuICAgIHBvc2l0aW9uczogWzAsIDFdXG4gIH0sXG4gIHNwcmluZzoge1xuICAgIGNvbG9yczogW1wiI2ZmMDBmZlwiLCBcIiNmZmZmMDBcIl0sXG4gICAgcG9zaXRpb25zOiBbMCwgMV1cbiAgfSxcbiAgc3VtbWVyOiB7XG4gICAgY29sb3JzOiBbXCIjMDA4MDY2XCIsIFwiI2ZmZmY2NlwiXSxcbiAgICBwb3NpdGlvbnM6IFswLCAxXVxuICB9LFxuICBhdXR1bW46IHtcbiAgICBjb2xvcnM6IFtcIiNmZjAwMDBcIiwgXCIjZmZmZjAwXCJdLFxuICAgIHBvc2l0aW9uczogWzAsIDFdXG4gIH0sXG4gIHdpbnRlcjoge1xuICAgIGNvbG9yczogW1wiIzAwMDBmZlwiLCBcIiMwMGZmODBcIl0sXG4gICAgcG9zaXRpb25zOiBbMCwgMV1cbiAgfSxcbiAgYm9uZToge1xuICAgIGNvbG9yczogW1wiIzAwMDAwMFwiLCBcIiM1NDU0NzRcIiwgXCIjYTljOGM4XCIsIFwiI2ZmZmZmZlwiXSxcbiAgICBwb3NpdGlvbnM6IFswLCAwLjM3NiwgMC43NTMsIDFdXG4gIH0sXG4gIGNvcHBlcjoge1xuICAgIGNvbG9yczogW1wiIzAwMDAwMFwiLCBcIiNmZmEwNjZcIiwgXCIjZmZjNzdmXCJdLFxuICAgIHBvc2l0aW9uczogWzAsIDAuODA0LCAxXVxuICB9LFxuICBncmV5czoge1xuICAgIGNvbG9yczogW1wiIzAwMDAwMFwiLCBcIiNmZmZmZmZcIl0sXG4gICAgcG9zaXRpb25zOiBbMCwgMV1cbiAgfSxcbiAgeWxnbmJ1OiB7XG4gICAgY29sb3JzOiBbXCIjMDgxZDU4XCIsIFwiIzI1MzQ5NFwiLCBcIiMyMjVlYThcIiwgXCIjMWQ5MWMwXCIsIFwiIzQxYjZjNFwiLCBcIiM3ZmNkYmJcIiwgXCIjYzdlOWI0XCIsIFwiI2VkZjhkOVwiLCBcIiNmZmZmZDlcIl0sXG4gICAgcG9zaXRpb25zOiBbMCwgMC4xMjUsIDAuMjUsIDAuMzc1LCAwLjUsIDAuNjI1LCAwLjc1LCAwLjg3NSwgMV1cbiAgfSxcbiAgZ3JlZW5zOiB7XG4gICAgY29sb3JzOiBbXCIjMDA0NDFiXCIsIFwiIzAwNmQyY1wiLCBcIiMyMzhiNDVcIiwgXCIjNDFhYjVkXCIsIFwiIzc0YzQ3NlwiLCBcIiNhMWQ5OWJcIiwgXCIjYzdlOWMwXCIsIFwiI2U1ZjVlMFwiLCBcIiNmN2ZjZjVcIl0sXG4gICAgcG9zaXRpb25zOiBbMCwgMC4xMjUsIDAuMjUsIDAuMzc1LCAwLjUsIDAuNjI1LCAwLjc1LCAwLjg3NSwgMV1cbiAgfSxcbiAgeWxvcnJkOiB7XG4gICAgY29sb3JzOiBbXCIjODAwMDI2XCIsIFwiI2JkMDAyNlwiLCBcIiNlMzFhMWNcIiwgXCIjZmM0ZTJhXCIsIFwiI2ZkOGQzY1wiLCBcIiNmZWIyNGNcIiwgXCIjZmVkOTc2XCIsIFwiI2ZmZWRhMFwiLCBcIiNmZmZmY2NcIl0sXG4gICAgcG9zaXRpb25zOiBbMCwgMC4xMjUsIDAuMjUsIDAuMzc1LCAwLjUsIDAuNjI1LCAwLjc1LCAwLjg3NSwgMV1cbiAgfSxcbiAgYmx1ZXJlZDoge1xuICAgIGNvbG9yczogW1wiIzAwMDBmZlwiLCBcIiNmZjAwMDBcIl0sXG4gICAgcG9zaXRpb25zOiBbMCwgMV1cbiAgfSxcbiAgcmRidToge1xuICAgIGNvbG9yczogW1wiIzA1MGFhY1wiLCBcIiM2YTg5ZjdcIiwgXCIjYmViZWJlXCIsIFwiI2RjYWE4NFwiLCBcIiNlNjkxNWFcIiwgXCIjYjIwYTFjXCJdLFxuICAgIHBvc2l0aW9uczogWzAsIDAuMzUsIDAuNSwgMC42LCAwLjcsIDFdXG4gIH0sXG4gIHBpY25pYzoge1xuICAgIGNvbG9yczogW1wiIzAwMDBmZlwiLCBcIiMzMzk5ZmZcIiwgXCIjNjZjY2ZmXCIsIFwiIzk5Y2NmZlwiLCBcIiNjY2NjZmZcIiwgXCIjZmZmZmZmXCIsIFwiI2ZmY2NmZlwiLCBcIiNmZjk5ZmZcIiwgXCIjZmY2NmNjXCIsIFwiI2ZmNjY2NlwiLCBcIiNmZjAwMDBcIl0sXG4gICAgcG9zaXRpb25zOiBbMCwgMC4xLCAwLjIsIDAuMywgMC40LCAwLjUsIDAuNiwgMC43LCAwLjgsIDAuOSwgMV1cbiAgfSxcbiAgcG9ydGxhbmQ6IHtcbiAgICBjb2xvcnM6IFtcIiMwYzMzODNcIiwgXCIjMGE4OGJhXCIsIFwiI2YyZDMzOFwiLCBcIiNmMjhmMzhcIiwgXCIjZDkxZTFlXCJdLFxuICAgIHBvc2l0aW9uczogWzAsIDAuMjUsIDAuNSwgMC43NSwgMV1cbiAgfSxcbiAgYmxhY2tib2R5OiB7XG4gICAgY29sb3JzOiBbXCIjMDAwMDAwXCIsIFwiI2U2MDAwMFwiLCBcIiNlNmQyMDBcIiwgXCIjZmZmZmZmXCIsIFwiI2EwYzhmZlwiXSxcbiAgICBwb3NpdGlvbnM6IFswLCAwLjIsIDAuNCwgMC43LCAxXVxuICB9LFxuICBlYXJ0aDoge1xuICAgIGNvbG9yczogW1wiIzAwMDA4MlwiLCBcIiMwMGI0YjRcIiwgXCIjMjhkMjI4XCIsIFwiI2U2ZTYzMlwiLCBcIiM3ODQ2MTRcIiwgXCIjZmZmZmZmXCJdLFxuICAgIHBvc2l0aW9uczogWzAsIDAuMSwgMC4yLCAwLjQsIDAuNiwgMV1cbiAgfSxcbiAgZWxlY3RyaWM6IHtcbiAgICBjb2xvcnM6IFtcIiMwMDAwMDBcIiwgXCIjMWUwMDY0XCIsIFwiIzc4MDA2NFwiLCBcIiNhMDVhMDBcIiwgXCIjZTZjODAwXCIsIFwiI2ZmZmFkY1wiXSxcbiAgICBwb3NpdGlvbnM6IFswLCAwLjE1LCAwLjQsIDAuNiwgMC44LCAxXVxuICB9LFxuICBtYWdtYTogbmV3IFVpbnQ4QXJyYXkoWzAsIDAsIDQsIDI1NSwgMSwgMCwgNSwgMjU1LCAxLCAxLCA2LCAyNTUsIDEsIDEsIDgsIDI1NSwgMiwgMSwgOSwgMjU1LCAyLCAyLCAxMSwgMjU1LCAyLCAyLCAxMywgMjU1LCAzLCAzLCAxNSwgMjU1LCAzLCAzLCAxOCwgMjU1LCA0LCA0LCAyMCwgMjU1LCA1LCA0LCAyMiwgMjU1LCA2LCA1LCAyNCwgMjU1LCA2LCA1LCAyNiwgMjU1LCA3LCA2LCAyOCwgMjU1LCA4LCA3LCAzMCwgMjU1LCA5LCA3LCAzMiwgMjU1LCAxMCwgOCwgMzQsIDI1NSwgMTEsIDksIDM2LCAyNTUsIDEyLCA5LCAzOCwgMjU1LCAxMywgMTAsIDQxLCAyNTUsIDE0LCAxMSwgNDMsIDI1NSwgMTYsIDExLCA0NSwgMjU1LCAxNywgMTIsIDQ3LCAyNTUsIDE4LCAxMywgNDksIDI1NSwgMTksIDEzLCA1MiwgMjU1LCAyMCwgMTQsIDU0LCAyNTUsIDIxLCAxNCwgNTYsIDI1NSwgMjIsIDE1LCA1OSwgMjU1LCAyNCwgMTUsIDYxLCAyNTUsIDI1LCAxNiwgNjMsIDI1NSwgMjYsIDE2LCA2NiwgMjU1LCAyOCwgMTYsIDY4LCAyNTUsIDI5LCAxNywgNzEsIDI1NSwgMzAsIDE3LCA3MywgMjU1LCAzMiwgMTcsIDc1LCAyNTUsIDMzLCAxNywgNzgsIDI1NSwgMzQsIDE3LCA4MCwgMjU1LCAzNiwgMTgsIDgzLCAyNTUsIDM3LCAxOCwgODUsIDI1NSwgMzksIDE4LCA4OCwgMjU1LCA0MSwgMTcsIDkwLCAyNTUsIDQyLCAxNywgOTIsIDI1NSwgNDQsIDE3LCA5NSwgMjU1LCA0NSwgMTcsIDk3LCAyNTUsIDQ3LCAxNywgOTksIDI1NSwgNDksIDE3LCAxMDEsIDI1NSwgNTEsIDE2LCAxMDMsIDI1NSwgNTIsIDE2LCAxMDUsIDI1NSwgNTQsIDE2LCAxMDcsIDI1NSwgNTYsIDE2LCAxMDgsIDI1NSwgNTcsIDE1LCAxMTAsIDI1NSwgNTksIDE1LCAxMTIsIDI1NSwgNjEsIDE1LCAxMTMsIDI1NSwgNjMsIDE1LCAxMTQsIDI1NSwgNjQsIDE1LCAxMTYsIDI1NSwgNjYsIDE1LCAxMTcsIDI1NSwgNjgsIDE1LCAxMTgsIDI1NSwgNjksIDE2LCAxMTksIDI1NSwgNzEsIDE2LCAxMjAsIDI1NSwgNzMsIDE2LCAxMjAsIDI1NSwgNzQsIDE2LCAxMjEsIDI1NSwgNzYsIDE3LCAxMjIsIDI1NSwgNzgsIDE3LCAxMjMsIDI1NSwgNzksIDE4LCAxMjMsIDI1NSwgODEsIDE4LCAxMjQsIDI1NSwgODIsIDE5LCAxMjQsIDI1NSwgODQsIDE5LCAxMjUsIDI1NSwgODYsIDIwLCAxMjUsIDI1NSwgODcsIDIxLCAxMjYsIDI1NSwgODksIDIxLCAxMjYsIDI1NSwgOTAsIDIyLCAxMjYsIDI1NSwgOTIsIDIyLCAxMjcsIDI1NSwgOTMsIDIzLCAxMjcsIDI1NSwgOTUsIDI0LCAxMjcsIDI1NSwgOTYsIDI0LCAxMjgsIDI1NSwgOTgsIDI1LCAxMjgsIDI1NSwgMTAwLCAyNiwgMTI4LCAyNTUsIDEwMSwgMjYsIDEyOCwgMjU1LCAxMDMsIDI3LCAxMjgsIDI1NSwgMTA0LCAyOCwgMTI5LCAyNTUsIDEwNiwgMjgsIDEyOSwgMjU1LCAxMDcsIDI5LCAxMjksIDI1NSwgMTA5LCAyOSwgMTI5LCAyNTUsIDExMCwgMzAsIDEyOSwgMjU1LCAxMTIsIDMxLCAxMjksIDI1NSwgMTE0LCAzMSwgMTI5LCAyNTUsIDExNSwgMzIsIDEyOSwgMjU1LCAxMTcsIDMzLCAxMjksIDI1NSwgMTE4LCAzMywgMTI5LCAyNTUsIDEyMCwgMzQsIDEyOSwgMjU1LCAxMjEsIDM0LCAxMzAsIDI1NSwgMTIzLCAzNSwgMTMwLCAyNTUsIDEyNCwgMzUsIDEzMCwgMjU1LCAxMjYsIDM2LCAxMzAsIDI1NSwgMTI4LCAzNywgMTMwLCAyNTUsIDEyOSwgMzcsIDEyOSwgMjU1LCAxMzEsIDM4LCAxMjksIDI1NSwgMTMyLCAzOCwgMTI5LCAyNTUsIDEzNCwgMzksIDEyOSwgMjU1LCAxMzYsIDM5LCAxMjksIDI1NSwgMTM3LCA0MCwgMTI5LCAyNTUsIDEzOSwgNDEsIDEyOSwgMjU1LCAxNDAsIDQxLCAxMjksIDI1NSwgMTQyLCA0MiwgMTI5LCAyNTUsIDE0NCwgNDIsIDEyOSwgMjU1LCAxNDUsIDQzLCAxMjksIDI1NSwgMTQ3LCA0MywgMTI4LCAyNTUsIDE0OCwgNDQsIDEyOCwgMjU1LCAxNTAsIDQ0LCAxMjgsIDI1NSwgMTUyLCA0NSwgMTI4LCAyNTUsIDE1MywgNDUsIDEyOCwgMjU1LCAxNTUsIDQ2LCAxMjcsIDI1NSwgMTU2LCA0NiwgMTI3LCAyNTUsIDE1OCwgNDcsIDEyNywgMjU1LCAxNjAsIDQ3LCAxMjcsIDI1NSwgMTYxLCA0OCwgMTI2LCAyNTUsIDE2MywgNDgsIDEyNiwgMjU1LCAxNjUsIDQ5LCAxMjYsIDI1NSwgMTY2LCA0OSwgMTI1LCAyNTUsIDE2OCwgNTAsIDEyNSwgMjU1LCAxNzAsIDUxLCAxMjUsIDI1NSwgMTcxLCA1MSwgMTI0LCAyNTUsIDE3MywgNTIsIDEyNCwgMjU1LCAxNzQsIDUyLCAxMjMsIDI1NSwgMTc2LCA1MywgMTIzLCAyNTUsIDE3OCwgNTMsIDEyMywgMjU1LCAxNzksIDU0LCAxMjIsIDI1NSwgMTgxLCA1NCwgMTIyLCAyNTUsIDE4MywgNTUsIDEyMSwgMjU1LCAxODQsIDU1LCAxMjEsIDI1NSwgMTg2LCA1NiwgMTIwLCAyNTUsIDE4OCwgNTcsIDEyMCwgMjU1LCAxODksIDU3LCAxMTksIDI1NSwgMTkxLCA1OCwgMTE5LCAyNTUsIDE5MiwgNTgsIDExOCwgMjU1LCAxOTQsIDU5LCAxMTcsIDI1NSwgMTk2LCA2MCwgMTE3LCAyNTUsIDE5NywgNjAsIDExNiwgMjU1LCAxOTksIDYxLCAxMTUsIDI1NSwgMjAwLCA2MiwgMTE1LCAyNTUsIDIwMiwgNjIsIDExNCwgMjU1LCAyMDQsIDYzLCAxMTMsIDI1NSwgMjA1LCA2NCwgMTEzLCAyNTUsIDIwNywgNjQsIDExMiwgMjU1LCAyMDgsIDY1LCAxMTEsIDI1NSwgMjEwLCA2NiwgMTExLCAyNTUsIDIxMSwgNjcsIDExMCwgMjU1LCAyMTMsIDY4LCAxMDksIDI1NSwgMjE0LCA2OSwgMTA4LCAyNTUsIDIxNiwgNjksIDEwOCwgMjU1LCAyMTcsIDcwLCAxMDcsIDI1NSwgMjE5LCA3MSwgMTA2LCAyNTUsIDIyMCwgNzIsIDEwNSwgMjU1LCAyMjIsIDczLCAxMDQsIDI1NSwgMjIzLCA3NCwgMTA0LCAyNTUsIDIyNCwgNzYsIDEwMywgMjU1LCAyMjYsIDc3LCAxMDIsIDI1NSwgMjI3LCA3OCwgMTAxLCAyNTUsIDIyOCwgNzksIDEwMCwgMjU1LCAyMjksIDgwLCAxMDAsIDI1NSwgMjMxLCA4MiwgOTksIDI1NSwgMjMyLCA4MywgOTgsIDI1NSwgMjMzLCA4NCwgOTgsIDI1NSwgMjM0LCA4NiwgOTcsIDI1NSwgMjM1LCA4NywgOTYsIDI1NSwgMjM2LCA4OCwgOTYsIDI1NSwgMjM3LCA5MCwgOTUsIDI1NSwgMjM4LCA5MSwgOTQsIDI1NSwgMjM5LCA5MywgOTQsIDI1NSwgMjQwLCA5NSwgOTQsIDI1NSwgMjQxLCA5NiwgOTMsIDI1NSwgMjQyLCA5OCwgOTMsIDI1NSwgMjQyLCAxMDAsIDkyLCAyNTUsIDI0MywgMTAxLCA5MiwgMjU1LCAyNDQsIDEwMywgOTIsIDI1NSwgMjQ0LCAxMDUsIDkyLCAyNTUsIDI0NSwgMTA3LCA5MiwgMjU1LCAyNDYsIDEwOCwgOTIsIDI1NSwgMjQ2LCAxMTAsIDkyLCAyNTUsIDI0NywgMTEyLCA5MiwgMjU1LCAyNDcsIDExNCwgOTIsIDI1NSwgMjQ4LCAxMTYsIDkyLCAyNTUsIDI0OCwgMTE4LCA5MiwgMjU1LCAyNDksIDEyMCwgOTMsIDI1NSwgMjQ5LCAxMjEsIDkzLCAyNTUsIDI0OSwgMTIzLCA5MywgMjU1LCAyNTAsIDEyNSwgOTQsIDI1NSwgMjUwLCAxMjcsIDk0LCAyNTUsIDI1MCwgMTI5LCA5NSwgMjU1LCAyNTEsIDEzMSwgOTUsIDI1NSwgMjUxLCAxMzMsIDk2LCAyNTUsIDI1MSwgMTM1LCA5NywgMjU1LCAyNTIsIDEzNywgOTcsIDI1NSwgMjUyLCAxMzgsIDk4LCAyNTUsIDI1MiwgMTQwLCA5OSwgMjU1LCAyNTIsIDE0MiwgMTAwLCAyNTUsIDI1MiwgMTQ0LCAxMDEsIDI1NSwgMjUzLCAxNDYsIDEwMiwgMjU1LCAyNTMsIDE0OCwgMTAzLCAyNTUsIDI1MywgMTUwLCAxMDQsIDI1NSwgMjUzLCAxNTIsIDEwNSwgMjU1LCAyNTMsIDE1NCwgMTA2LCAyNTUsIDI1MywgMTU1LCAxMDcsIDI1NSwgMjU0LCAxNTcsIDEwOCwgMjU1LCAyNTQsIDE1OSwgMTA5LCAyNTUsIDI1NCwgMTYxLCAxMTAsIDI1NSwgMjU0LCAxNjMsIDExMSwgMjU1LCAyNTQsIDE2NSwgMTEzLCAyNTUsIDI1NCwgMTY3LCAxMTQsIDI1NSwgMjU0LCAxNjksIDExNSwgMjU1LCAyNTQsIDE3MCwgMTE2LCAyNTUsIDI1NCwgMTcyLCAxMTgsIDI1NSwgMjU0LCAxNzQsIDExOSwgMjU1LCAyNTQsIDE3NiwgMTIwLCAyNTUsIDI1NCwgMTc4LCAxMjIsIDI1NSwgMjU0LCAxODAsIDEyMywgMjU1LCAyNTQsIDE4MiwgMTI0LCAyNTUsIDI1NCwgMTgzLCAxMjYsIDI1NSwgMjU0LCAxODUsIDEyNywgMjU1LCAyNTQsIDE4NywgMTI5LCAyNTUsIDI1NCwgMTg5LCAxMzAsIDI1NSwgMjU0LCAxOTEsIDEzMiwgMjU1LCAyNTQsIDE5MywgMTMzLCAyNTUsIDI1NCwgMTk0LCAxMzUsIDI1NSwgMjU0LCAxOTYsIDEzNiwgMjU1LCAyNTQsIDE5OCwgMTM4LCAyNTUsIDI1NCwgMjAwLCAxNDAsIDI1NSwgMjU0LCAyMDIsIDE0MSwgMjU1LCAyNTQsIDIwNCwgMTQzLCAyNTUsIDI1NCwgMjA1LCAxNDQsIDI1NSwgMjU0LCAyMDcsIDE0NiwgMjU1LCAyNTQsIDIwOSwgMTQ4LCAyNTUsIDI1NCwgMjExLCAxNDksIDI1NSwgMjU0LCAyMTMsIDE1MSwgMjU1LCAyNTQsIDIxNSwgMTUzLCAyNTUsIDI1NCwgMjE2LCAxNTQsIDI1NSwgMjUzLCAyMTgsIDE1NiwgMjU1LCAyNTMsIDIyMCwgMTU4LCAyNTUsIDI1MywgMjIyLCAxNjAsIDI1NSwgMjUzLCAyMjQsIDE2MSwgMjU1LCAyNTMsIDIyNiwgMTYzLCAyNTUsIDI1MywgMjI3LCAxNjUsIDI1NSwgMjUzLCAyMjksIDE2NywgMjU1LCAyNTMsIDIzMSwgMTY5LCAyNTUsIDI1MywgMjMzLCAxNzAsIDI1NSwgMjUzLCAyMzUsIDE3MiwgMjU1LCAyNTIsIDIzNiwgMTc0LCAyNTUsIDI1MiwgMjM4LCAxNzYsIDI1NSwgMjUyLCAyNDAsIDE3OCwgMjU1LCAyNTIsIDI0MiwgMTgwLCAyNTUsIDI1MiwgMjQ0LCAxODIsIDI1NSwgMjUyLCAyNDYsIDE4NCwgMjU1LCAyNTIsIDI0NywgMTg1LCAyNTUsIDI1MiwgMjQ5LCAxODcsIDI1NSwgMjUyLCAyNTEsIDE4OSwgMjU1LCAyNTIsIDI1MywgMTkxLCAyNTVdKSxcbiAgcGxhc21hOiBuZXcgVWludDhBcnJheShbMTMsIDgsIDEzNSwgMjU1LCAxNiwgNywgMTM2LCAyNTUsIDE5LCA3LCAxMzcsIDI1NSwgMjIsIDcsIDEzOCwgMjU1LCAyNSwgNiwgMTQwLCAyNTUsIDI3LCA2LCAxNDEsIDI1NSwgMjksIDYsIDE0MiwgMjU1LCAzMiwgNiwgMTQzLCAyNTUsIDM0LCA2LCAxNDQsIDI1NSwgMzYsIDYsIDE0NSwgMjU1LCAzOCwgNSwgMTQ1LCAyNTUsIDQwLCA1LCAxNDYsIDI1NSwgNDIsIDUsIDE0NywgMjU1LCA0NCwgNSwgMTQ4LCAyNTUsIDQ2LCA1LCAxNDksIDI1NSwgNDcsIDUsIDE1MCwgMjU1LCA0OSwgNSwgMTUxLCAyNTUsIDUxLCA1LCAxNTEsIDI1NSwgNTMsIDQsIDE1MiwgMjU1LCA1NSwgNCwgMTUzLCAyNTUsIDU2LCA0LCAxNTQsIDI1NSwgNTgsIDQsIDE1NCwgMjU1LCA2MCwgNCwgMTU1LCAyNTUsIDYyLCA0LCAxNTYsIDI1NSwgNjMsIDQsIDE1NiwgMjU1LCA2NSwgNCwgMTU3LCAyNTUsIDY3LCAzLCAxNTgsIDI1NSwgNjgsIDMsIDE1OCwgMjU1LCA3MCwgMywgMTU5LCAyNTUsIDcyLCAzLCAxNTksIDI1NSwgNzMsIDMsIDE2MCwgMjU1LCA3NSwgMywgMTYxLCAyNTUsIDc2LCAyLCAxNjEsIDI1NSwgNzgsIDIsIDE2MiwgMjU1LCA4MCwgMiwgMTYyLCAyNTUsIDgxLCAyLCAxNjMsIDI1NSwgODMsIDIsIDE2MywgMjU1LCA4NSwgMiwgMTY0LCAyNTUsIDg2LCAxLCAxNjQsIDI1NSwgODgsIDEsIDE2NCwgMjU1LCA4OSwgMSwgMTY1LCAyNTUsIDkxLCAxLCAxNjUsIDI1NSwgOTIsIDEsIDE2NiwgMjU1LCA5NCwgMSwgMTY2LCAyNTUsIDk2LCAxLCAxNjYsIDI1NSwgOTcsIDAsIDE2NywgMjU1LCA5OSwgMCwgMTY3LCAyNTUsIDEwMCwgMCwgMTY3LCAyNTUsIDEwMiwgMCwgMTY3LCAyNTUsIDEwMywgMCwgMTY4LCAyNTUsIDEwNSwgMCwgMTY4LCAyNTUsIDEwNiwgMCwgMTY4LCAyNTUsIDEwOCwgMCwgMTY4LCAyNTUsIDExMCwgMCwgMTY4LCAyNTUsIDExMSwgMCwgMTY4LCAyNTUsIDExMywgMCwgMTY4LCAyNTUsIDExNCwgMSwgMTY4LCAyNTUsIDExNiwgMSwgMTY4LCAyNTUsIDExNywgMSwgMTY4LCAyNTUsIDExOSwgMSwgMTY4LCAyNTUsIDEyMCwgMSwgMTY4LCAyNTUsIDEyMiwgMiwgMTY4LCAyNTUsIDEyMywgMiwgMTY4LCAyNTUsIDEyNSwgMywgMTY4LCAyNTUsIDEyNiwgMywgMTY4LCAyNTUsIDEyOCwgNCwgMTY4LCAyNTUsIDEyOSwgNCwgMTY3LCAyNTUsIDEzMSwgNSwgMTY3LCAyNTUsIDEzMiwgNSwgMTY3LCAyNTUsIDEzNCwgNiwgMTY2LCAyNTUsIDEzNSwgNywgMTY2LCAyNTUsIDEzNiwgOCwgMTY2LCAyNTUsIDEzOCwgOSwgMTY1LCAyNTUsIDEzOSwgMTAsIDE2NSwgMjU1LCAxNDEsIDExLCAxNjUsIDI1NSwgMTQyLCAxMiwgMTY0LCAyNTUsIDE0MywgMTMsIDE2NCwgMjU1LCAxNDUsIDE0LCAxNjMsIDI1NSwgMTQ2LCAxNSwgMTYzLCAyNTUsIDE0OCwgMTYsIDE2MiwgMjU1LCAxNDksIDE3LCAxNjEsIDI1NSwgMTUwLCAxOSwgMTYxLCAyNTUsIDE1MiwgMjAsIDE2MCwgMjU1LCAxNTMsIDIxLCAxNTksIDI1NSwgMTU0LCAyMiwgMTU5LCAyNTUsIDE1NiwgMjMsIDE1OCwgMjU1LCAxNTcsIDI0LCAxNTcsIDI1NSwgMTU4LCAyNSwgMTU3LCAyNTUsIDE2MCwgMjYsIDE1NiwgMjU1LCAxNjEsIDI3LCAxNTUsIDI1NSwgMTYyLCAyOSwgMTU0LCAyNTUsIDE2MywgMzAsIDE1NCwgMjU1LCAxNjUsIDMxLCAxNTMsIDI1NSwgMTY2LCAzMiwgMTUyLCAyNTUsIDE2NywgMzMsIDE1MSwgMjU1LCAxNjgsIDM0LCAxNTAsIDI1NSwgMTcwLCAzNSwgMTQ5LCAyNTUsIDE3MSwgMzYsIDE0OCwgMjU1LCAxNzIsIDM4LCAxNDgsIDI1NSwgMTczLCAzOSwgMTQ3LCAyNTUsIDE3NCwgNDAsIDE0NiwgMjU1LCAxNzYsIDQxLCAxNDUsIDI1NSwgMTc3LCA0MiwgMTQ0LCAyNTUsIDE3OCwgNDMsIDE0MywgMjU1LCAxNzksIDQ0LCAxNDIsIDI1NSwgMTgwLCA0NiwgMTQxLCAyNTUsIDE4MSwgNDcsIDE0MCwgMjU1LCAxODIsIDQ4LCAxMzksIDI1NSwgMTgzLCA0OSwgMTM4LCAyNTUsIDE4NCwgNTAsIDEzNywgMjU1LCAxODYsIDUxLCAxMzYsIDI1NSwgMTg3LCA1MiwgMTM2LCAyNTUsIDE4OCwgNTMsIDEzNSwgMjU1LCAxODksIDU1LCAxMzQsIDI1NSwgMTkwLCA1NiwgMTMzLCAyNTUsIDE5MSwgNTcsIDEzMiwgMjU1LCAxOTIsIDU4LCAxMzEsIDI1NSwgMTkzLCA1OSwgMTMwLCAyNTUsIDE5NCwgNjAsIDEyOSwgMjU1LCAxOTUsIDYxLCAxMjgsIDI1NSwgMTk2LCA2MiwgMTI3LCAyNTUsIDE5NywgNjQsIDEyNiwgMjU1LCAxOTgsIDY1LCAxMjUsIDI1NSwgMTk5LCA2NiwgMTI0LCAyNTUsIDIwMCwgNjcsIDEyMywgMjU1LCAyMDEsIDY4LCAxMjIsIDI1NSwgMjAyLCA2OSwgMTIyLCAyNTUsIDIwMywgNzAsIDEyMSwgMjU1LCAyMDQsIDcxLCAxMjAsIDI1NSwgMjA0LCA3MywgMTE5LCAyNTUsIDIwNSwgNzQsIDExOCwgMjU1LCAyMDYsIDc1LCAxMTcsIDI1NSwgMjA3LCA3NiwgMTE2LCAyNTUsIDIwOCwgNzcsIDExNSwgMjU1LCAyMDksIDc4LCAxMTQsIDI1NSwgMjEwLCA3OSwgMTEzLCAyNTUsIDIxMSwgODEsIDExMywgMjU1LCAyMTIsIDgyLCAxMTIsIDI1NSwgMjEzLCA4MywgMTExLCAyNTUsIDIxMywgODQsIDExMCwgMjU1LCAyMTQsIDg1LCAxMDksIDI1NSwgMjE1LCA4NiwgMTA4LCAyNTUsIDIxNiwgODcsIDEwNywgMjU1LCAyMTcsIDg4LCAxMDYsIDI1NSwgMjE4LCA5MCwgMTA2LCAyNTUsIDIxOCwgOTEsIDEwNSwgMjU1LCAyMTksIDkyLCAxMDQsIDI1NSwgMjIwLCA5MywgMTAzLCAyNTUsIDIyMSwgOTQsIDEwMiwgMjU1LCAyMjIsIDk1LCAxMDEsIDI1NSwgMjIyLCA5NywgMTAwLCAyNTUsIDIyMywgOTgsIDk5LCAyNTUsIDIyNCwgOTksIDk5LCAyNTUsIDIyNSwgMTAwLCA5OCwgMjU1LCAyMjYsIDEwMSwgOTcsIDI1NSwgMjI2LCAxMDIsIDk2LCAyNTUsIDIyNywgMTA0LCA5NSwgMjU1LCAyMjgsIDEwNSwgOTQsIDI1NSwgMjI5LCAxMDYsIDkzLCAyNTUsIDIyOSwgMTA3LCA5MywgMjU1LCAyMzAsIDEwOCwgOTIsIDI1NSwgMjMxLCAxMTAsIDkxLCAyNTUsIDIzMSwgMTExLCA5MCwgMjU1LCAyMzIsIDExMiwgODksIDI1NSwgMjMzLCAxMTMsIDg4LCAyNTUsIDIzMywgMTE0LCA4NywgMjU1LCAyMzQsIDExNiwgODcsIDI1NSwgMjM1LCAxMTcsIDg2LCAyNTUsIDIzNSwgMTE4LCA4NSwgMjU1LCAyMzYsIDExOSwgODQsIDI1NSwgMjM3LCAxMjEsIDgzLCAyNTUsIDIzNywgMTIyLCA4MiwgMjU1LCAyMzgsIDEyMywgODEsIDI1NSwgMjM5LCAxMjQsIDgxLCAyNTUsIDIzOSwgMTI2LCA4MCwgMjU1LCAyNDAsIDEyNywgNzksIDI1NSwgMjQwLCAxMjgsIDc4LCAyNTUsIDI0MSwgMTI5LCA3NywgMjU1LCAyNDEsIDEzMSwgNzYsIDI1NSwgMjQyLCAxMzIsIDc1LCAyNTUsIDI0MywgMTMzLCA3NSwgMjU1LCAyNDMsIDEzNSwgNzQsIDI1NSwgMjQ0LCAxMzYsIDczLCAyNTUsIDI0NCwgMTM3LCA3MiwgMjU1LCAyNDUsIDEzOSwgNzEsIDI1NSwgMjQ1LCAxNDAsIDcwLCAyNTUsIDI0NiwgMTQxLCA2OSwgMjU1LCAyNDYsIDE0MywgNjgsIDI1NSwgMjQ3LCAxNDQsIDY4LCAyNTUsIDI0NywgMTQ1LCA2NywgMjU1LCAyNDcsIDE0NywgNjYsIDI1NSwgMjQ4LCAxNDgsIDY1LCAyNTUsIDI0OCwgMTQ5LCA2NCwgMjU1LCAyNDksIDE1MSwgNjMsIDI1NSwgMjQ5LCAxNTIsIDYyLCAyNTUsIDI0OSwgMTU0LCA2MiwgMjU1LCAyNTAsIDE1NSwgNjEsIDI1NSwgMjUwLCAxNTYsIDYwLCAyNTUsIDI1MCwgMTU4LCA1OSwgMjU1LCAyNTEsIDE1OSwgNTgsIDI1NSwgMjUxLCAxNjEsIDU3LCAyNTUsIDI1MSwgMTYyLCA1NiwgMjU1LCAyNTIsIDE2MywgNTYsIDI1NSwgMjUyLCAxNjUsIDU1LCAyNTUsIDI1MiwgMTY2LCA1NCwgMjU1LCAyNTIsIDE2OCwgNTMsIDI1NSwgMjUyLCAxNjksIDUyLCAyNTUsIDI1MywgMTcxLCA1MSwgMjU1LCAyNTMsIDE3MiwgNTEsIDI1NSwgMjUzLCAxNzQsIDUwLCAyNTUsIDI1MywgMTc1LCA0OSwgMjU1LCAyNTMsIDE3NywgNDgsIDI1NSwgMjUzLCAxNzgsIDQ3LCAyNTUsIDI1MywgMTgwLCA0NywgMjU1LCAyNTMsIDE4MSwgNDYsIDI1NSwgMjU0LCAxODMsIDQ1LCAyNTUsIDI1NCwgMTg0LCA0NCwgMjU1LCAyNTQsIDE4NiwgNDQsIDI1NSwgMjU0LCAxODcsIDQzLCAyNTUsIDI1NCwgMTg5LCA0MiwgMjU1LCAyNTQsIDE5MCwgNDIsIDI1NSwgMjU0LCAxOTIsIDQxLCAyNTUsIDI1MywgMTk0LCA0MSwgMjU1LCAyNTMsIDE5NSwgNDAsIDI1NSwgMjUzLCAxOTcsIDM5LCAyNTUsIDI1MywgMTk4LCAzOSwgMjU1LCAyNTMsIDIwMCwgMzksIDI1NSwgMjUzLCAyMDIsIDM4LCAyNTUsIDI1MywgMjAzLCAzOCwgMjU1LCAyNTIsIDIwNSwgMzcsIDI1NSwgMjUyLCAyMDYsIDM3LCAyNTUsIDI1MiwgMjA4LCAzNywgMjU1LCAyNTIsIDIxMCwgMzcsIDI1NSwgMjUxLCAyMTEsIDM2LCAyNTUsIDI1MSwgMjEzLCAzNiwgMjU1LCAyNTEsIDIxNSwgMzYsIDI1NSwgMjUwLCAyMTYsIDM2LCAyNTUsIDI1MCwgMjE4LCAzNiwgMjU1LCAyNDksIDIyMCwgMzYsIDI1NSwgMjQ5LCAyMjEsIDM3LCAyNTUsIDI0OCwgMjIzLCAzNywgMjU1LCAyNDgsIDIyNSwgMzcsIDI1NSwgMjQ3LCAyMjYsIDM3LCAyNTUsIDI0NywgMjI4LCAzNywgMjU1LCAyNDYsIDIzMCwgMzgsIDI1NSwgMjQ2LCAyMzIsIDM4LCAyNTUsIDI0NSwgMjMzLCAzOCwgMjU1LCAyNDUsIDIzNSwgMzksIDI1NSwgMjQ0LCAyMzcsIDM5LCAyNTUsIDI0MywgMjM4LCAzOSwgMjU1LCAyNDMsIDI0MCwgMzksIDI1NSwgMjQyLCAyNDIsIDM5LCAyNTUsIDI0MSwgMjQ0LCAzOCwgMjU1LCAyNDEsIDI0NSwgMzcsIDI1NSwgMjQwLCAyNDcsIDM2LCAyNTUsIDI0MCwgMjQ5LCAzMywgMjU1XSksXG4gIHJlZGJsdWU6IHtcbiAgICBjb2xvcnM6IFtcIiNmZjAwMDBcIiwgXCIjMDAwMGZmXCJdLFxuICAgIHBvc2l0aW9uczogWzAsIDFdXG4gIH0sXG4gIGNvb2x3YXJtOiB7XG4gICAgY29sb3JzOiBbXCIjMDAwMGZmXCIsIFwiI2ZmZmZmZlwiLCBcIiNmZjAwMDBcIl0sXG4gICAgcG9zaXRpb25zOiBbMCwgMC41LCAxXVxuICB9LFxuICBkaXZlcmdpbmdfMToge1xuICAgIGNvbG9yczogW1wiIzQwMDA0MFwiLCBcIiMzYjAwNGRcIiwgXCIjMzYwMDViXCIsIFwiIzMyMDA2OFwiLCBcIiMyZDAwNzZcIiwgXCIjMjkwMDg0XCIsIFwiIzI0MDA5MVwiLCBcIiMyMDAwOWZcIiwgXCIjMWIwMGFkXCIsIFwiIzE2MDBiYVwiLCBcIiMxMjAwYzhcIiwgXCIjMGQwMGQ2XCIsIFwiIzA5MDBlM1wiLCBcIiMwNDAwZjFcIiwgXCIjMDAwMGZmXCIsIFwiIzAyMTdmZlwiLCBcIiMwNDJlZmZcIiwgXCIjMDY0NWZmXCIsIFwiIzA5NWNmZlwiLCBcIiMwYjczZmZcIiwgXCIjMGQ4YmZmXCIsIFwiIzEwYTJmZlwiLCBcIiMxMmI5ZmZcIiwgXCIjMTRkMGZmXCIsIFwiIzE3ZTdmZlwiLCBcIiMxOWZmZmZcIiwgXCIjM2ZmZmZmXCIsIFwiIzY2ZmZmZlwiLCBcIiM4Y2ZmZmZcIiwgXCIjYjJmZmZmXCIsIFwiI2Q4ZmZmZlwiLCBcIiNmZmZmZmZcIiwgXCIjZmZmZmQ0XCIsIFwiI2ZmZmZhYVwiLCBcIiNmZmZmN2ZcIiwgXCIjZmZmZjU0XCIsIFwiI2ZmZmYyYVwiLCBcIiNmZmZmMDBcIiwgXCIjZmZlZDAwXCIsIFwiI2ZmZGQwMFwiLCBcIiNmZmNjMDBcIiwgXCIjZmZiYTAwXCIsIFwiI2ZmYWEwMFwiLCBcIiNmZjk5MDBcIiwgXCIjZmY4NzAwXCIsIFwiI2ZmNzcwMFwiLCBcIiNmZjY2MDBcIiwgXCIjZmY1NDAwXCIsIFwiI2ZmNDQwMFwiLCBcIiNmZjMzMDBcIiwgXCIjZmYyMTAwXCIsIFwiI2ZmMTEwMFwiLCBcIiNmZjAwMDBcIiwgXCIjZmYwMDE3XCIsIFwiI2ZmMDAyZVwiLCBcIiNmZjAwNDVcIiwgXCIjZmYwMDVjXCIsIFwiI2ZmMDA3M1wiLCBcIiNmZjAwOGJcIiwgXCIjZmYwMGEyXCIsIFwiI2ZmMDBiOVwiLCBcIiNmZjAwZDBcIiwgXCIjZmYwMGU3XCIsIFwiI2ZmMDBmZlwiXSxcbiAgICBwb3NpdGlvbnM6IFswLCAwLjAxNTg3MzAxNTg3LCAwLjAzMTc0NjAzMTc0LCAwLjA0NzYxOTA0NzYxLCAwLjA2MzQ5MjA2MzQ4LCAwLjA3OTM2NTA3OTM1LCAwLjA5NTIzODA5NTIyLCAwLjExMTExMTExMTA5LCAwLjEyNjk4NDEyNjk2LCAwLjE0Mjg1NzE0MjgzLCAwLjE1ODczMDE1ODcsIDAuMTc0NjAzMTc0NTcsIDAuMTkwNDc2MTkwNDQsIDAuMjA2MzQ5MjA2MzEsIDAuMjIyMjIyMjIyMTgsIDAuMjM4MDk1MjM4MDUsIDAuMjUzOTY4MjUzOTIsIDAuMjY5ODQxMjY5NzksIDAuMjg1NzE0Mjg1NjYsIDAuMzAxNTg3MzAxNTMsIDAuMzE3NDYwMzE3NCwgMC4zMzMzMzMzMzMyNywgMC4zNDkyMDYzNDkxNCwgMC4zNjUwNzkzNjUwMSwgMC4zODA5NTIzODA4OCwgMC4zOTY4MjUzOTY3NSwgMC40MTI2OTg0MTI2MiwgMC40Mjg1NzE0Mjg0OSwgMC40NDQ0NDQ0NDQzNiwgMC40NjAzMTc0NjAyMywgMC40NzYxOTA0NzYxLCAwLjQ5MjA2MzQ5MTk3LCAwLjUwNzkzNjUwNzg0LCAwLjUyMzgwOTUyMzcxLCAwLjUzOTY4MjUzOTU4LCAwLjU1NTU1NTU1NTQ1LCAwLjU3MTQyODU3MTMyLCAwLjU4NzMwMTU4NzE5LCAwLjYwMzE3NDYwMzA2LCAwLjYxOTA0NzYxODkzLCAwLjYzNDkyMDYzNDgsIDAuNjUwNzkzNjUwNjcsIDAuNjY2NjY2NjY2NTQsIDAuNjgyNTM5NjgyNDEsIDAuNjk4NDEyNjk4MjgsIDAuNzE0Mjg1NzE0MTUsIDAuNzMwMTU4NzMwMDIsIDAuNzQ2MDMxNzQ1ODksIDAuNzYxOTA0NzYxNzYsIDAuNzc3Nzc3Nzc3NjMsIDAuNzkzNjUwNzkzNSwgMC44MDk1MjM4MDkzNywgMC44MjUzOTY4MjUyNCwgMC44NDEyNjk4NDExMSwgMC44NTcxNDI4NTY5OCwgMC44NzMwMTU4NzI4NSwgMC44ODg4ODg4ODg3MiwgMC45MDQ3NjE5MDQ1OSwgMC45MjA2MzQ5MjA0NiwgMC45MzY1MDc5MzYzMywgMC45NTIzODA5NTIyLCAwLjk2ODI1Mzk2ODA3LCAwLjk4NDEyNjk4Mzk0LCAxXVxuICB9LFxuICBkaXZlcmdpbmdfMjoge1xuICAgIGNvbG9yczogW1wiIzAwMDAwMFwiLCBcIiMwMzBhZmZcIiwgXCIjMjA0YWZmXCIsIFwiIzNjOGFmZlwiLCBcIiM3N2M0ZmZcIiwgXCIjZjBmZmZmXCIsIFwiI2YwZmZmZlwiLCBcIiNmMmZmN2ZcIiwgXCIjZmZmZjAwXCIsIFwiI2ZmODMxZVwiLCBcIiNmZjA4M2RcIiwgXCIjZmYwMGZmXCJdLFxuICAgIHBvc2l0aW9uczogWzAsIDFlLTEwLCAwLjEsIDAuMiwgMC4zMzMzLCAwLjQ2NjYsIDAuNTMzMywgMC42NjY2LCAwLjgsIDAuOSwgMC45OTk5OTk5OTk5OTksIDFdXG4gIH0sXG4gIGJsYWNrd2hpdGU6IHtcbiAgICBjb2xvcnM6IFtcIiMwMDAwMDBcIiwgXCIjZmZmZmZmXCJdLFxuICAgIHBvc2l0aW9uczogWzAsIDFdXG4gIH0sXG4gIHR3aWxpZ2h0OiB7XG4gICAgY29sb3JzOiBbXCIjRTJEOUUyXCIsIFwiI0UwRDlFMlwiLCBcIiNEREQ5RTBcIiwgXCIjREFEOERGXCIsIFwiI0Q2RDdERFwiLCBcIiNEMkQ1REJcIiwgXCIjQ0REM0Q4XCIsIFwiI0M4RDBENlwiLCBcIiNDMkNFRDRcIiwgXCIjQkNDQkQxXCIsIFwiI0I2QzhDRlwiLCBcIiNCMEM1Q0RcIiwgXCIjQUFDMkNDXCIsIFwiI0E0QkVDQVwiLCBcIiM5RUJCQzlcIiwgXCIjOTlCOEM4XCIsIFwiIzkzQjRDNlwiLCBcIiM4RUIxQzVcIiwgXCIjODlBREM1XCIsIFwiIzg1QTlDNFwiLCBcIiM4MEE1QzNcIiwgXCIjN0NBMkMyXCIsIFwiIzc4OUVDMlwiLCBcIiM3NTlBQzFcIiwgXCIjNzE5NkMxXCIsIFwiIzZFOTJDMFwiLCBcIiM2QzhFQkZcIiwgXCIjNjk4QUJGXCIsIFwiIzY3ODZCRVwiLCBcIiM2NjgyQkRcIiwgXCIjNjQ3REJDXCIsIFwiIzYzNzlCQlwiLCBcIiM2Mjc1QkFcIiwgXCIjNjE3MEI5XCIsIFwiIzYwNkNCOFwiLCBcIiM2MDY3QjZcIiwgXCIjNUY2MkI0XCIsIFwiIzVGNUVCM1wiLCBcIiM1RjU5QjFcIiwgXCIjNUU1NEFFXCIsIFwiIzVFNEZBQ1wiLCBcIiM1RTRCQTlcIiwgXCIjNUU0NkE2XCIsIFwiIzVENDFBM1wiLCBcIiM1RDNDQTBcIiwgXCIjNUMzNzlDXCIsIFwiIzVCMzI5OFwiLCBcIiM1QTJFOTNcIiwgXCIjNTkyOThFXCIsIFwiIzU3MjU4OFwiLCBcIiM1NjIxODJcIiwgXCIjNTMxRTdDXCIsIFwiIzUxMUE3NVwiLCBcIiM0RTE4NkZcIiwgXCIjNEIxNjY4XCIsIFwiIzQ3MTQ2MVwiLCBcIiM0NDEzNUFcIiwgXCIjNDExMjU0XCIsIFwiIzNEMTE0RVwiLCBcIiMzQTExNDlcIiwgXCIjMzcxMTQ0XCIsIFwiIzM1MTE0MFwiLCBcIiMzMzExM0NcIiwgXCIjMzExMzM5XCIsIFwiIzMwMTQzN1wiLCBcIiMzMzEyMzdcIiwgXCIjMzUxMTM4XCIsIFwiIzM4MTEzOVwiLCBcIiMzQjExM0JcIiwgXCIjM0YxMjNEXCIsIFwiIzQzMTIzRVwiLCBcIiM0ODEzNDFcIiwgXCIjNEQxNDQzXCIsIFwiIzUyMTU0NVwiLCBcIiM1NzE2NDdcIiwgXCIjNUMxNzQ5XCIsIFwiIzYxMTg0QlwiLCBcIiM2NzE5NENcIiwgXCIjNkMxQjRFXCIsIFwiIzcxMUQ0RlwiLCBcIiM3NjFGNEZcIiwgXCIjN0IyMTUwXCIsIFwiIzgwMjM1MFwiLCBcIiM4NTI2NTBcIiwgXCIjOEEyOTUwXCIsIFwiIzhFMkM1MFwiLCBcIiM5MjJGNTBcIiwgXCIjOTYzMzUwXCIsIFwiIzlBMzc1MFwiLCBcIiM5RTNCNTBcIiwgXCIjQTEzRjUwXCIsIFwiI0E1NDM1MFwiLCBcIiNBODQ3NTBcIiwgXCIjQUI0QjUwXCIsIFwiI0FFNTA1MVwiLCBcIiNCMTU0NTJcIiwgXCIjQjM1OTUzXCIsIFwiI0I2NUQ1NFwiLCBcIiNCODYyNTVcIiwgXCIjQkE2NjU3XCIsIFwiI0JDNkI1OVwiLCBcIiNCRTcwNUJcIiwgXCIjQzA3NTVFXCIsIFwiI0MyN0E2MVwiLCBcIiNDMzdGNjRcIiwgXCIjQzU4NDY4XCIsIFwiI0M2ODk2Q1wiLCBcIiNDNzhFNzFcIiwgXCIjQzg5Mjc1XCIsIFwiI0M5OTc3QlwiLCBcIiNDQTlDODBcIiwgXCIjQ0NBMTg2XCIsIFwiI0NEQTY4Q1wiLCBcIiNDRUFCOTJcIiwgXCIjQ0ZBRjk5XCIsIFwiI0QxQjRBMFwiLCBcIiNEMkI4QTdcIiwgXCIjRDRCREFEXCIsIFwiI0Q2QzFCNFwiLCBcIiNEOEM1QkJcIiwgXCIjRDlDOUMyXCIsIFwiI0RCQ0NDOFwiLCBcIiNEREQwQ0VcIiwgXCIjREVEM0QzXCIsIFwiI0RGRDVEOFwiLCBcIiNFMEQ3REJcIiwgXCIjRTFEOERGXCIsIFwiI0UyRDlFMVwiXSxcbiAgICBwb3NpdGlvbnM6IFswLCAwLjAwNzg3NDAxNTcsIDAuMDE1NzQ4MDMxNSwgMC4wMjM2MjIwNDcyLCAwLjAzMTQ5NjA2MywgMC4wMzkzNzAwNzg3LCAwLjA0NzI0NDA5NDUsIDAuMDU1MTE4MTEwMiwgMC4wNjI5OTIxMjYsIDAuMDcwODY2MTQxNywgMC4wNzg3NDAxNTc1LCAwLjA4NjYxNDE3MzIsIDAuMDk0NDg4MTg5LCAwLjEwMjM2MjIwNDcsIDAuMTEwMjM2MjIwNSwgMC4xMTgxMTAyMzYyLCAwLjEyNTk4NDI1MiwgMC4xMzM4NTgyNjc3LCAwLjE0MTczMjI4MzUsIDAuMTQ5NjA2Mjk5MiwgMC4xNTc0ODAzMTUsIDAuMTY1MzU0MzMwNywgMC4xNzMyMjgzNDY1LCAwLjE4MTEwMjM2MjIsIDAuMTg4OTc2Mzc4LCAwLjE5Njg1MDM5MzcsIDAuMjA0NzI0NDA5NCwgMC4yMTI1OTg0MjUyLCAwLjIyMDQ3MjQ0MDksIDAuMjI4MzQ2NDU2NywgMC4yMzYyMjA0NzI0LCAwLjI0NDA5NDQ4ODIsIDAuMjUxOTY4NTAzOSwgMC4yNTk4NDI1MTk3LCAwLjI2NzcxNjUzNTQsIDAuMjc1NTkwNTUxMiwgMC4yODM0NjQ1NjY5LCAwLjI5MTMzODU4MjcsIDAuMjk5MjEyNTk4NCwgMC4zMDcwODY2MTQyLCAwLjMxNDk2MDYyOTksIDAuMzIyODM0NjQ1NywgMC4zMzA3MDg2NjE0LCAwLjMzODU4MjY3NzIsIDAuMzQ2NDU2NjkyOSwgMC4zNTQzMzA3MDg3LCAwLjM2MjIwNDcyNDQsIDAuMzcwMDc4NzQwMiwgMC4zNzc5NTI3NTU5LCAwLjM4NTgyNjc3MTcsIDAuMzkzNzAwNzg3NCwgMC40MDE1NzQ4MDMxLCAwLjQwOTQ0ODgxODksIDAuNDE3MzIyODM0NiwgMC40MjUxOTY4NTA0LCAwLjQzMzA3MDg2NjEsIDAuNDQwOTQ0ODgxOSwgMC40NDg4MTg4OTc2LCAwLjQ1NjY5MjkxMzQsIDAuNDY0NTY2OTI5MSwgMC40NzI0NDA5NDQ5LCAwLjQ4MDMxNDk2MDYsIDAuNDg4MTg4OTc2NCwgMC40OTYwNjI5OTIxLCAwLjUwMzkzNzAwNzksIDAuNTExODExMDIzNiwgMC41MTk2ODUwMzk0LCAwLjUyNzU1OTA1NTEsIDAuNTM1NDMzMDcwOSwgMC41NDMzMDcwODY2LCAwLjU1MTE4MTEwMjQsIDAuNTU5MDU1MTE4MSwgMC41NjY5MjkxMzM5LCAwLjU3NDgwMzE0OTYsIDAuNTgyNjc3MTY1NCwgMC41OTA1NTExODExLCAwLjU5ODQyNTE5NjksIDAuNjA2Mjk5MjEyNiwgMC42MTQxNzMyMjgzLCAwLjYyMjA0NzI0NDEsIDAuNjI5OTIxMjU5OCwgMC42Mzc3OTUyNzU2LCAwLjY0NTY2OTI5MTMsIDAuNjUzNTQzMzA3MSwgMC42NjE0MTczMjI4LCAwLjY2OTI5MTMzODYsIDAuNjc3MTY1MzU0MywgMC42ODUwMzkzNzAxLCAwLjY5MjkxMzM4NTgsIDAuNzAwNzg3NDAxNiwgMC43MDg2NjE0MTczLCAwLjcxNjUzNTQzMzEsIDAuNzI0NDA5NDQ4OCwgMC43MzIyODM0NjQ2LCAwLjc0MDE1NzQ4MDMsIDAuNzQ4MDMxNDk2MSwgMC43NTU5MDU1MTE4LCAwLjc2Mzc3OTUyNzYsIDAuNzcxNjUzNTQzMywgMC43Nzk1Mjc1NTkxLCAwLjc4NzQwMTU3NDgsIDAuNzk1Mjc1NTkwNiwgMC44MDMxNDk2MDYzLCAwLjgxMTAyMzYyMiwgMC44MTg4OTc2Mzc4LCAwLjgyNjc3MTY1MzUsIDAuODM0NjQ1NjY5MywgMC44NDI1MTk2ODUsIDAuODUwMzkzNzAwOCwgMC44NTgyNjc3MTY1LCAwLjg2NjE0MTczMjMsIDAuODc0MDE1NzQ4LCAwLjg4MTg4OTc2MzgsIDAuODg5NzYzNzc5NSwgMC44OTc2Mzc3OTUzLCAwLjkwNTUxMTgxMSwgMC45MTMzODU4MjY4LCAwLjkyMTI1OTg0MjUsIDAuOTI5MTMzODU4MywgMC45MzcwMDc4NzQsIDAuOTQ0ODgxODg5OCwgMC45NTI3NTU5MDU1LCAwLjk2MDYyOTkyMTMsIDAuOTY4NTAzOTM3LCAwLjk3NjM3Nzk1MjgsIDAuOTg0MjUxOTY4NSwgMC45OTIxMjU5ODQzLCAxXVxuICB9LFxuICB0d2lsaWdodF9zaGlmdGVkOiB7XG4gICAgY29sb3JzOiBbXCIjMzAxNDM3XCIsIFwiIzMyMTIzQVwiLCBcIiMzNDExM0VcIiwgXCIjMzYxMTQyXCIsIFwiIzM5MTE0NlwiLCBcIiMzQzExNEJcIiwgXCIjM0YxMjUxXCIsIFwiIzQyMTI1N1wiLCBcIiM0NjE0NUVcIiwgXCIjNDkxNTY0XCIsIFwiIzRDMTc2QlwiLCBcIiM0RjE5NzJcIiwgXCIjNTIxQzc5XCIsIFwiIzU1MUY3RlwiLCBcIiM1NzIzODVcIiwgXCIjNTgyNzhCXCIsIFwiIzVBMkI5MFwiLCBcIiM1QjMwOTVcIiwgXCIjNUMzNTlBXCIsIFwiIzVEM0E5RVwiLCBcIiM1RDNFQTFcIiwgXCIjNUU0M0E1XCIsIFwiIzVFNDhBOFwiLCBcIiM1RTREQUJcIiwgXCIjNUU1MkFEXCIsIFwiIzVGNTdCMFwiLCBcIiM1RjVCQjJcIiwgXCIjNUY2MEI0XCIsIFwiIzVGNjVCNVwiLCBcIiM2MDY5QjdcIiwgXCIjNjA2RUI4XCIsIFwiIzYxNzJCQVwiLCBcIiM2Mjc3QkJcIiwgXCIjNjM3QkJDXCIsIFwiIzY1N0ZCRFwiLCBcIiM2Njg0QkRcIiwgXCIjNjg4OEJFXCIsIFwiIzZCOENCRlwiLCBcIiM2RDkwQzBcIiwgXCIjNzA5NEMwXCIsIFwiIzczOThDMVwiLCBcIiM3NjlDQzFcIiwgXCIjN0FBMEMyXCIsIFwiIzdFQTRDM1wiLCBcIiM4MkE3QzNcIiwgXCIjODdBQkM0XCIsIFwiIzhDQUZDNVwiLCBcIiM5MUIyQzZcIiwgXCIjOTZCNkM3XCIsIFwiIzlDQjlDOFwiLCBcIiNBMUJEQzlcIiwgXCIjQTdDMENCXCIsIFwiI0FEQzNDRFwiLCBcIiNCM0M2Q0VcIiwgXCIjQjlDOUQwXCIsIFwiI0JGQ0NEM1wiLCBcIiNDNUNGRDVcIiwgXCIjQ0JEMkQ3XCIsIFwiI0QwRDREOVwiLCBcIiNENEQ2RENcIiwgXCIjRDhEOERFXCIsIFwiI0RDRDlERlwiLCBcIiNERUQ5RTFcIiwgXCIjRTFEOUUyXCIsIFwiI0UyRDlFMVwiLCBcIiNFMUQ4REZcIiwgXCIjRTBEN0RCXCIsIFwiI0RGRDVEOFwiLCBcIiNERUQzRDNcIiwgXCIjREREMENFXCIsIFwiI0RCQ0NDOFwiLCBcIiNEOUM5QzJcIiwgXCIjRDhDNUJCXCIsIFwiI0Q2QzFCNFwiLCBcIiNENEJEQURcIiwgXCIjRDJCOEE3XCIsIFwiI0QxQjRBMFwiLCBcIiNDRkFGOTlcIiwgXCIjQ0VBQjkyXCIsIFwiI0NEQTY4Q1wiLCBcIiNDQ0ExODZcIiwgXCIjQ0E5QzgwXCIsIFwiI0M5OTc3QlwiLCBcIiNDODkyNzVcIiwgXCIjQzc4RTcxXCIsIFwiI0M2ODk2Q1wiLCBcIiNDNTg0NjhcIiwgXCIjQzM3RjY0XCIsIFwiI0MyN0E2MVwiLCBcIiNDMDc1NUVcIiwgXCIjQkU3MDVCXCIsIFwiI0JDNkI1OVwiLCBcIiNCQTY2NTdcIiwgXCIjQjg2MjU1XCIsIFwiI0I2NUQ1NFwiLCBcIiNCMzU5NTNcIiwgXCIjQjE1NDUyXCIsIFwiI0FFNTA1MVwiLCBcIiNBQjRCNTBcIiwgXCIjQTg0NzUwXCIsIFwiI0E1NDM1MFwiLCBcIiNBMTNGNTBcIiwgXCIjOUUzQjUwXCIsIFwiIzlBMzc1MFwiLCBcIiM5NjMzNTBcIiwgXCIjOTIyRjUwXCIsIFwiIzhFMkM1MFwiLCBcIiM4QTI5NTBcIiwgXCIjODUyNjUwXCIsIFwiIzgwMjM1MFwiLCBcIiM3QjIxNTBcIiwgXCIjNzYxRjRGXCIsIFwiIzcxMUQ0RlwiLCBcIiM2QzFCNEVcIiwgXCIjNjcxOTRDXCIsIFwiIzYxMTg0QlwiLCBcIiM1QzE3NDlcIiwgXCIjNTcxNjQ3XCIsIFwiIzUyMTU0NVwiLCBcIiM0RDE0NDNcIiwgXCIjNDgxMzQxXCIsIFwiIzQzMTIzRVwiLCBcIiMzRjEyM0RcIiwgXCIjM0IxMTNCXCIsIFwiIzM4MTEzOVwiLCBcIiMzNTExMzhcIiwgXCIjMzMxMjM3XCIsIFwiIzMwMTQzN1wiXSxcbiAgICBwb3NpdGlvbnM6IFswLCAwLjAwNzg3NDAxNTcsIDAuMDE1NzQ4MDMxNSwgMC4wMjM2MjIwNDcyLCAwLjAzMTQ5NjA2MywgMC4wMzkzNzAwNzg3LCAwLjA0NzI0NDA5NDUsIDAuMDU1MTE4MTEwMiwgMC4wNjI5OTIxMjYsIDAuMDcwODY2MTQxNywgMC4wNzg3NDAxNTc1LCAwLjA4NjYxNDE3MzIsIDAuMDk0NDg4MTg5LCAwLjEwMjM2MjIwNDcsIDAuMTEwMjM2MjIwNSwgMC4xMTgxMTAyMzYyLCAwLjEyNTk4NDI1MiwgMC4xMzM4NTgyNjc3LCAwLjE0MTczMjI4MzUsIDAuMTQ5NjA2Mjk5MiwgMC4xNTc0ODAzMTUsIDAuMTY1MzU0MzMwNywgMC4xNzMyMjgzNDY1LCAwLjE4MTEwMjM2MjIsIDAuMTg4OTc2Mzc4LCAwLjE5Njg1MDM5MzcsIDAuMjA0NzI0NDA5NCwgMC4yMTI1OTg0MjUyLCAwLjIyMDQ3MjQ0MDksIDAuMjI4MzQ2NDU2NywgMC4yMzYyMjA0NzI0LCAwLjI0NDA5NDQ4ODIsIDAuMjUxOTY4NTAzOSwgMC4yNTk4NDI1MTk3LCAwLjI2NzcxNjUzNTQsIDAuMjc1NTkwNTUxMiwgMC4yODM0NjQ1NjY5LCAwLjI5MTMzODU4MjcsIDAuMjk5MjEyNTk4NCwgMC4zMDcwODY2MTQyLCAwLjMxNDk2MDYyOTksIDAuMzIyODM0NjQ1NywgMC4zMzA3MDg2NjE0LCAwLjMzODU4MjY3NzIsIDAuMzQ2NDU2NjkyOSwgMC4zNTQzMzA3MDg3LCAwLjM2MjIwNDcyNDQsIDAuMzcwMDc4NzQwMiwgMC4zNzc5NTI3NTU5LCAwLjM4NTgyNjc3MTcsIDAuMzkzNzAwNzg3NCwgMC40MDE1NzQ4MDMxLCAwLjQwOTQ0ODgxODksIDAuNDE3MzIyODM0NiwgMC40MjUxOTY4NTA0LCAwLjQzMzA3MDg2NjEsIDAuNDQwOTQ0ODgxOSwgMC40NDg4MTg4OTc2LCAwLjQ1NjY5MjkxMzQsIDAuNDY0NTY2OTI5MSwgMC40NzI0NDA5NDQ5LCAwLjQ4MDMxNDk2MDYsIDAuNDg4MTg4OTc2NCwgMC40OTYwNjI5OTIxLCAwLjUwMzkzNzAwNzksIDAuNTExODExMDIzNiwgMC41MTk2ODUwMzk0LCAwLjUyNzU1OTA1NTEsIDAuNTM1NDMzMDcwOSwgMC41NDMzMDcwODY2LCAwLjU1MTE4MTEwMjQsIDAuNTU5MDU1MTE4MSwgMC41NjY5MjkxMzM5LCAwLjU3NDgwMzE0OTYsIDAuNTgyNjc3MTY1NCwgMC41OTA1NTExODExLCAwLjU5ODQyNTE5NjksIDAuNjA2Mjk5MjEyNiwgMC42MTQxNzMyMjgzLCAwLjYyMjA0NzI0NDEsIDAuNjI5OTIxMjU5OCwgMC42Mzc3OTUyNzU2LCAwLjY0NTY2OTI5MTMsIDAuNjUzNTQzMzA3MSwgMC42NjE0MTczMjI4LCAwLjY2OTI5MTMzODYsIDAuNjc3MTY1MzU0MywgMC42ODUwMzkzNzAxLCAwLjY5MjkxMzM4NTgsIDAuNzAwNzg3NDAxNiwgMC43MDg2NjE0MTczLCAwLjcxNjUzNTQzMzEsIDAuNzI0NDA5NDQ4OCwgMC43MzIyODM0NjQ2LCAwLjc0MDE1NzQ4MDMsIDAuNzQ4MDMxNDk2MSwgMC43NTU5MDU1MTE4LCAwLjc2Mzc3OTUyNzYsIDAuNzcxNjUzNTQzMywgMC43Nzk1Mjc1NTkxLCAwLjc4NzQwMTU3NDgsIDAuNzk1Mjc1NTkwNiwgMC44MDMxNDk2MDYzLCAwLjgxMTAyMzYyMiwgMC44MTg4OTc2Mzc4LCAwLjgyNjc3MTY1MzUsIDAuODM0NjQ1NjY5MywgMC44NDI1MTk2ODUsIDAuODUwMzkzNzAwOCwgMC44NTgyNjc3MTY1LCAwLjg2NjE0MTczMjMsIDAuODc0MDE1NzQ4LCAwLjg4MTg4OTc2MzgsIDAuODg5NzYzNzc5NSwgMC44OTc2Mzc3OTUzLCAwLjkwNTUxMTgxMSwgMC45MTMzODU4MjY4LCAwLjkyMTI1OTg0MjUsIDAuOTI5MTMzODU4MywgMC45MzcwMDc4NzQsIDAuOTQ0ODgxODg5OCwgMC45NTI3NTU5MDU1LCAwLjk2MDYyOTkyMTMsIDAuOTY4NTAzOTM3LCAwLjk3NjM3Nzk1MjgsIDAuOTg0MjUxOTY4NSwgMC45OTIxMjU5ODQzLCAxXVxuICB9XG59O1xuXG5mdW5jdGlvbiBwZWckc3ViY2xhc3MoY2hpbGQsIHBhcmVudCkge1xuICBmdW5jdGlvbiBDKCkge1xuICAgIHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDtcbiAgfVxuICBDLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XG4gIGNoaWxkLnByb3RvdHlwZSA9IG5ldyBDKCk7XG59XG5mdW5jdGlvbiBwZWckU3ludGF4RXJyb3IobWVzc2FnZSwgZXhwZWN0ZWQsIGZvdW5kLCBsb2NhdGlvbikge1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB0aGlzLmV4cGVjdGVkID0gZXhwZWN0ZWQ7XG4gIHRoaXMuZm91bmQgPSBmb3VuZDtcbiAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICB0aGlzLm5hbWUgPSBcIlN5bnRheEVycm9yXCI7XG4gIGlmICh0eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHBlZyRTeW50YXhFcnJvcik7XG4gIH1cbn1cbnBlZyRzdWJjbGFzcyhwZWckU3ludGF4RXJyb3IsIEVycm9yKTtcbnBlZyRTeW50YXhFcnJvci5idWlsZE1lc3NhZ2UgPSBmdW5jdGlvbihleHBlY3RlZCwgZm91bmQpIHtcbiAgdmFyIERFU0NSSUJFX0VYUEVDVEFUSU9OX0ZOUyA9IHtcbiAgICBsaXRlcmFsOiBmdW5jdGlvbihleHBlY3RhdGlvbikge1xuICAgICAgcmV0dXJuICdcIicgKyBsaXRlcmFsRXNjYXBlKGV4cGVjdGF0aW9uLnRleHQpICsgJ1wiJztcbiAgICB9LFxuICAgIGNsYXNzOiBmdW5jdGlvbihleHBlY3RhdGlvbikge1xuICAgICAgdmFyIGVzY2FwZWRQYXJ0cyA9IGV4cGVjdGF0aW9uLnBhcnRzLm1hcChmdW5jdGlvbihwYXJ0KSB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHBhcnQpID8gY2xhc3NFc2NhcGUocGFydFswXSkgKyBcIi1cIiArIGNsYXNzRXNjYXBlKHBhcnRbMV0pIDogY2xhc3NFc2NhcGUocGFydCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBcIltcIiArIChleHBlY3RhdGlvbi5pbnZlcnRlZCA/IFwiXlwiIDogXCJcIikgKyBlc2NhcGVkUGFydHMgKyBcIl1cIjtcbiAgICB9LFxuICAgIGFueTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXCJhbnkgY2hhcmFjdGVyXCI7XG4gICAgfSxcbiAgICBlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFwiZW5kIG9mIGlucHV0XCI7XG4gICAgfSxcbiAgICBvdGhlcjogZnVuY3Rpb24oZXhwZWN0YXRpb24pIHtcbiAgICAgIHJldHVybiBleHBlY3RhdGlvbi5kZXNjcmlwdGlvbjtcbiAgICB9LFxuICAgIG5vdDogZnVuY3Rpb24oZXhwZWN0YXRpb24pIHtcbiAgICAgIHJldHVybiBcIm5vdCBcIiArIGRlc2NyaWJlRXhwZWN0YXRpb24oZXhwZWN0YXRpb24uZXhwZWN0ZWQpO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gaGV4KGNoKSB7XG4gICAgcmV0dXJuIGNoLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gIH1cbiAgZnVuY3Rpb24gbGl0ZXJhbEVzY2FwZShzKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZSgvXFxcXC9nLCBcIlxcXFxcXFxcXCIpLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKS5yZXBsYWNlKC9cXDAvZywgXCJcXFxcMFwiKS5yZXBsYWNlKC9cXHQvZywgXCJcXFxcdFwiKS5yZXBsYWNlKC9cXG4vZywgXCJcXFxcblwiKS5yZXBsYWNlKC9cXHIvZywgXCJcXFxcclwiKS5yZXBsYWNlKC9bXFx4MDAtXFx4MEZdL2csIGZ1bmN0aW9uKGNoKSB7XG4gICAgICByZXR1cm4gXCJcXFxceDBcIiArIGhleChjaCk7XG4gICAgfSkucmVwbGFjZSgvW1xceDEwLVxceDFGXFx4N0YtXFx4OUZdL2csIGZ1bmN0aW9uKGNoKSB7XG4gICAgICByZXR1cm4gXCJcXFxceFwiICsgaGV4KGNoKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBjbGFzc0VzY2FwZShzKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZSgvXFxcXC9nLCBcIlxcXFxcXFxcXCIpLnJlcGxhY2UoL1xcXS9nLCBcIlxcXFxdXCIpLnJlcGxhY2UoL1xcXi9nLCBcIlxcXFxeXCIpLnJlcGxhY2UoLy0vZywgXCJcXFxcLVwiKS5yZXBsYWNlKC9cXDAvZywgXCJcXFxcMFwiKS5yZXBsYWNlKC9cXHQvZywgXCJcXFxcdFwiKS5yZXBsYWNlKC9cXG4vZywgXCJcXFxcblwiKS5yZXBsYWNlKC9cXHIvZywgXCJcXFxcclwiKS5yZXBsYWNlKC9bXFx4MDAtXFx4MEZdL2csIGZ1bmN0aW9uKGNoKSB7XG4gICAgICByZXR1cm4gXCJcXFxceDBcIiArIGhleChjaCk7XG4gICAgfSkucmVwbGFjZSgvW1xceDEwLVxceDFGXFx4N0YtXFx4OUZdL2csIGZ1bmN0aW9uKGNoKSB7XG4gICAgICByZXR1cm4gXCJcXFxceFwiICsgaGV4KGNoKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBkZXNjcmliZUV4cGVjdGF0aW9uKGV4cGVjdGF0aW9uKSB7XG4gICAgcmV0dXJuIERFU0NSSUJFX0VYUEVDVEFUSU9OX0ZOU1tleHBlY3RhdGlvbi50eXBlXShleHBlY3RhdGlvbik7XG4gIH1cbiAgZnVuY3Rpb24gZGVzY3JpYmVFeHBlY3RlZChleHBlY3RlZDIpIHtcbiAgICB2YXIgZGVzY3JpcHRpb25zID0gZXhwZWN0ZWQyLm1hcChkZXNjcmliZUV4cGVjdGF0aW9uKTtcbiAgICB2YXIgaSwgajtcbiAgICBkZXNjcmlwdGlvbnMuc29ydCgpO1xuICAgIGlmIChkZXNjcmlwdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChpID0gMSwgaiA9IDE7IGkgPCBkZXNjcmlwdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uc1tpIC0gMV0gIT09IGRlc2NyaXB0aW9uc1tpXSkge1xuICAgICAgICAgIGRlc2NyaXB0aW9uc1tqXSA9IGRlc2NyaXB0aW9uc1tpXTtcbiAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlc2NyaXB0aW9ucy5sZW5ndGggPSBqO1xuICAgIH1cbiAgICBzd2l0Y2ggKGRlc2NyaXB0aW9ucy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uc1swXTtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uc1swXSArIFwiIG9yIFwiICsgZGVzY3JpcHRpb25zWzFdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9ucy5zbGljZSgwLCAtMSkuam9pbihcIiwgXCIpICsgXCIsIG9yIFwiICsgZGVzY3JpcHRpb25zW2Rlc2NyaXB0aW9ucy5sZW5ndGggLSAxXTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZGVzY3JpYmVGb3VuZChmb3VuZDIpIHtcbiAgICByZXR1cm4gZm91bmQyID8gJ1wiJyArIGxpdGVyYWxFc2NhcGUoZm91bmQyKSArICdcIicgOiBcImVuZCBvZiBpbnB1dFwiO1xuICB9XG4gIHJldHVybiBcIkV4cGVjdGVkIFwiICsgZGVzY3JpYmVFeHBlY3RlZChleHBlY3RlZCkgKyBcIiBidXQgXCIgKyBkZXNjcmliZUZvdW5kKGZvdW5kKSArIFwiIGZvdW5kLlwiO1xufTtcbmZ1bmN0aW9uIHBlZyRwYXJzZShpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9O1xuICB2YXIgcGVnJEZBSUxFRCA9IHt9O1xuICB2YXIgcGVnJHN0YXJ0UnVsZUZ1bmN0aW9ucyA9IHsgRXhwcmVzc2lvbjogcGVnJHBhcnNlRXhwcmVzc2lvbiB9O1xuICB2YXIgcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uID0gcGVnJHBhcnNlRXhwcmVzc2lvbjtcbiAgdmFyIHBlZyRjMCA9IFwiK1wiO1xuICB2YXIgcGVnJGMxID0gXCItXCI7XG4gIHZhciBwZWckYzIgPSBcIipcIjtcbiAgdmFyIHBlZyRjMyA9IFwiL1wiO1xuICB2YXIgcGVnJGM0ID0gXCIqKlwiO1xuICB2YXIgcGVnJGM1ID0gXCIoXCI7XG4gIHZhciBwZWckYzYgPSBcIilcIjtcbiAgdmFyIHBlZyRyMCA9IC9eW1xcLStdLztcbiAgdmFyIHBlZyRyMSA9IC9eWzAtOV0vO1xuICB2YXIgcGVnJHIyID0gL15bYS16QS1aXyRdLztcbiAgdmFyIHBlZyRyMyA9IC9eW2EtekEtWl8kMC05XS87XG4gIHZhciBwZWckcjQgPSAvXlsgXFx0XFxuXFxyXS87XG4gIHZhciBwZWckZTAgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiK1wiLCBmYWxzZSk7XG4gIHZhciBwZWckZTEgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiLVwiLCBmYWxzZSk7XG4gIHZhciBwZWckZTIgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiKlwiLCBmYWxzZSk7XG4gIHZhciBwZWckZTMgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiL1wiLCBmYWxzZSk7XG4gIHZhciBwZWckZTQgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiKipcIiwgZmFsc2UpO1xuICB2YXIgcGVnJGU1ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIihcIiwgZmFsc2UpO1xuICB2YXIgcGVnJGU2ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIilcIiwgZmFsc2UpO1xuICB2YXIgcGVnJGU3ID0gcGVnJG90aGVyRXhwZWN0YXRpb24oXCJmbG9hdFwiKTtcbiAgdmFyIHBlZyRlOCA9IHBlZyRvdGhlckV4cGVjdGF0aW9uKFwiaW50ZWdlclwiKTtcbiAgdmFyIHBlZyRlOSA9IHBlZyRvdGhlckV4cGVjdGF0aW9uKFwiaWRlbnRpZmllclwiKTtcbiAgdmFyIHBlZyRlMTAgPSBwZWckb3RoZXJFeHBlY3RhdGlvbihcIndoaXRlc3BhY2VcIik7XG4gIHZhciBwZWckZjAgPSBmdW5jdGlvbihoZWFkLCB0YWlsKSB7XG4gICAgdmFyIGxocyA9IGhlYWQ7XG4gICAgdmFyIGksIG9wO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0YWlsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvcCA9IHRhaWxbaV1bMV07XG4gICAgICBsaHMgPSBtYWtlTm9kZShsaHMsIHRhaWxbaV1bM10sIG9wKTtcbiAgICB9XG4gICAgcmV0dXJuIGxocztcbiAgfTtcbiAgdmFyIHBlZyRmMSA9IGZ1bmN0aW9uKGhlYWQsIHRhaWwpIHtcbiAgICB2YXIgbGhzID0gaGVhZDtcbiAgICB2YXIgaSwgb3A7XG4gICAgZm9yIChpID0gMDsgaSA8IHRhaWwubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9wID0gdGFpbFtpXVsxXTtcbiAgICAgIGxocyA9IG1ha2VOb2RlKGxocywgdGFpbFtpXVszXSwgb3ApO1xuICAgIH1cbiAgICByZXR1cm4gbGhzO1xuICB9O1xuICB2YXIgcGVnJGYyID0gZnVuY3Rpb24oZXhwcikge1xuICAgIHJldHVybiBleHByO1xuICB9O1xuICB2YXIgcGVnJGYzID0gZnVuY3Rpb24obiwgZSkge1xuICAgIHJldHVybiB7IGZuOiBuLCBsaHM6IGUgfTtcbiAgfTtcbiAgdmFyIHBlZyRmNCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHRleHQoKSwgMTApO1xuICB9O1xuICB2YXIgcGVnJGY1ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHRleHQoKSwgMTApO1xuICB9O1xuICB2YXIgcGVnJGY2ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRleHQoKTtcbiAgfTtcbiAgdmFyIHBlZyRjdXJyUG9zID0gMDtcbiAgdmFyIHBlZyRzYXZlZFBvcyA9IDA7XG4gIHZhciBwZWckcG9zRGV0YWlsc0NhY2hlID0gW3sgbGluZTogMSwgY29sdW1uOiAxIH1dO1xuICB2YXIgcGVnJGV4cGVjdGVkID0gW107XG4gIHZhciBwZWckc2lsZW50RmFpbHMgPSAwO1xuICB2YXIgcGVnJHJlc3VsdDtcbiAgaWYgKFwic3RhcnRSdWxlXCIgaW4gb3B0aW9ucykge1xuICAgIGlmICghKG9wdGlvbnMuc3RhcnRSdWxlIGluIHBlZyRzdGFydFJ1bGVGdW5jdGlvbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IHN0YXJ0IHBhcnNpbmcgZnJvbSBydWxlIFwiYCArIG9wdGlvbnMuc3RhcnRSdWxlICsgJ1wiLicpO1xuICAgIH1cbiAgICBwZWckc3RhcnRSdWxlRnVuY3Rpb24gPSBwZWckc3RhcnRSdWxlRnVuY3Rpb25zW29wdGlvbnMuc3RhcnRSdWxlXTtcbiAgfVxuICBmdW5jdGlvbiB0ZXh0KCkge1xuICAgIHJldHVybiBpbnB1dC5zdWJzdHJpbmcocGVnJHNhdmVkUG9zLCBwZWckY3VyclBvcyk7XG4gIH1cbiAgZnVuY3Rpb24gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbih0ZXh0MiwgaWdub3JlQ2FzZSkge1xuICAgIHJldHVybiB7IHR5cGU6IFwibGl0ZXJhbFwiLCB0ZXh0OiB0ZXh0MiwgaWdub3JlQ2FzZSB9O1xuICB9XG4gIGZ1bmN0aW9uIHBlZyRlbmRFeHBlY3RhdGlvbigpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcImVuZFwiIH07XG4gIH1cbiAgZnVuY3Rpb24gcGVnJG90aGVyRXhwZWN0YXRpb24oZGVzY3JpcHRpb24pIHtcbiAgICByZXR1cm4geyB0eXBlOiBcIm90aGVyXCIsIGRlc2NyaXB0aW9uIH07XG4gIH1cbiAgZnVuY3Rpb24gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKHBvcykge1xuICAgIHZhciBkZXRhaWxzID0gcGVnJHBvc0RldGFpbHNDYWNoZVtwb3NdO1xuICAgIHZhciBwO1xuICAgIGlmIChkZXRhaWxzKSB7XG4gICAgICByZXR1cm4gZGV0YWlscztcbiAgICB9IGVsc2Uge1xuICAgICAgcCA9IHBvcyAtIDE7XG4gICAgICB3aGlsZSAoIXBlZyRwb3NEZXRhaWxzQ2FjaGVbcF0pIHtcbiAgICAgICAgcC0tO1xuICAgICAgfVxuICAgICAgZGV0YWlscyA9IHBlZyRwb3NEZXRhaWxzQ2FjaGVbcF07XG4gICAgICBkZXRhaWxzID0ge1xuICAgICAgICBsaW5lOiBkZXRhaWxzLmxpbmUsXG4gICAgICAgIGNvbHVtbjogZGV0YWlscy5jb2x1bW5cbiAgICAgIH07XG4gICAgICB3aGlsZSAocCA8IHBvcykge1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwKSA9PT0gMTApIHtcbiAgICAgICAgICBkZXRhaWxzLmxpbmUrKztcbiAgICAgICAgICBkZXRhaWxzLmNvbHVtbiA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGV0YWlscy5jb2x1bW4rKztcbiAgICAgICAgfVxuICAgICAgICBwKys7XG4gICAgICB9XG4gICAgICBwZWckcG9zRGV0YWlsc0NhY2hlW3Bvc10gPSBkZXRhaWxzO1xuICAgICAgcmV0dXJuIGRldGFpbHM7XG4gICAgfVxuICB9XG4gIHZhciBwZWckVkFMSURGSUxFTkFNRSA9IHR5cGVvZiBvcHRpb25zLmZpbGVuYW1lID09PSBcInN0cmluZ1wiICYmIG9wdGlvbnMuZmlsZW5hbWUubGVuZ3RoID4gMDtcbiAgZnVuY3Rpb24gcGVnJGNvbXB1dGVMb2NhdGlvbihzdGFydFBvcywgZW5kUG9zKSB7XG4gICAgdmFyIGxvYyA9IHt9O1xuICAgIGlmIChwZWckVkFMSURGSUxFTkFNRSlcbiAgICAgIGxvYy5maWxlbmFtZSA9IG9wdGlvbnMuZmlsZW5hbWU7XG4gICAgdmFyIHN0YXJ0UG9zRGV0YWlscyA9IHBlZyRjb21wdXRlUG9zRGV0YWlscyhzdGFydFBvcyk7XG4gICAgbG9jLnN0YXJ0ID0ge1xuICAgICAgb2Zmc2V0OiBzdGFydFBvcyxcbiAgICAgIGxpbmU6IHN0YXJ0UG9zRGV0YWlscy5saW5lLFxuICAgICAgY29sdW1uOiBzdGFydFBvc0RldGFpbHMuY29sdW1uXG4gICAgfTtcbiAgICB2YXIgZW5kUG9zRGV0YWlscyA9IHBlZyRjb21wdXRlUG9zRGV0YWlscyhlbmRQb3MpO1xuICAgIGxvYy5lbmQgPSB7XG4gICAgICBvZmZzZXQ6IGVuZFBvcyxcbiAgICAgIGxpbmU6IGVuZFBvc0RldGFpbHMubGluZSxcbiAgICAgIGNvbHVtbjogZW5kUG9zRGV0YWlscy5jb2x1bW5cbiAgICB9O1xuICAgIHJldHVybiBsb2M7XG4gIH1cbiAgZnVuY3Rpb24gcGVnJGJlZ2luKCkge1xuICAgIHBlZyRleHBlY3RlZC5wdXNoKHsgcG9zOiBwZWckY3VyclBvcywgdmFyaWFudHM6IFtdIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHBlZyRleHBlY3QoZXhwZWN0ZWQyKSB7XG4gICAgdmFyIHRvcCA9IHBlZyRleHBlY3RlZFtwZWckZXhwZWN0ZWQubGVuZ3RoIC0gMV07XG4gICAgaWYgKHBlZyRjdXJyUG9zIDwgdG9wLnBvcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocGVnJGN1cnJQb3MgPiB0b3AucG9zKSB7XG4gICAgICB0b3AucG9zID0gcGVnJGN1cnJQb3M7XG4gICAgICB0b3AudmFyaWFudHMgPSBbXTtcbiAgICB9XG4gICAgdG9wLnZhcmlhbnRzLnB1c2goZXhwZWN0ZWQyKTtcbiAgfVxuICBmdW5jdGlvbiBwZWckYnVpbGRTdHJ1Y3R1cmVkRXJyb3IoZXhwZWN0ZWQyLCBmb3VuZCwgbG9jYXRpb24yKSB7XG4gICAgcmV0dXJuIG5ldyBwZWckU3ludGF4RXJyb3IoXG4gICAgICBwZWckU3ludGF4RXJyb3IuYnVpbGRNZXNzYWdlKGV4cGVjdGVkMiwgZm91bmQpLFxuICAgICAgZXhwZWN0ZWQyLFxuICAgICAgZm91bmQsXG4gICAgICBsb2NhdGlvbjJcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHBlZyRidWlsZEVycm9yKCkge1xuICAgIHZhciBleHBlY3RlZDIgPSBwZWckZXhwZWN0ZWRbMF07XG4gICAgdmFyIGZhaWxQb3MgPSBleHBlY3RlZDIucG9zO1xuICAgIHJldHVybiBwZWckYnVpbGRTdHJ1Y3R1cmVkRXJyb3IoXG4gICAgICBleHBlY3RlZDIudmFyaWFudHMsXG4gICAgICBmYWlsUG9zIDwgaW5wdXQubGVuZ3RoID8gaW5wdXQuY2hhckF0KGZhaWxQb3MpIDogbnVsbCxcbiAgICAgIGZhaWxQb3MgPCBpbnB1dC5sZW5ndGggPyBwZWckY29tcHV0ZUxvY2F0aW9uKGZhaWxQb3MsIGZhaWxQb3MgKyAxKSA6IHBlZyRjb21wdXRlTG9jYXRpb24oZmFpbFBvcywgZmFpbFBvcylcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHBlZyRwYXJzZUV4cHJlc3Npb24oKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczUsIHM2LCBzNztcbiAgICB2YXIgcnVsZSRleHBlY3RzID0gZnVuY3Rpb24oZXhwZWN0ZWQyKSB7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKVxuICAgICAgICBwZWckZXhwZWN0KGV4cGVjdGVkMik7XG4gICAgfTtcbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gcGVnJHBhcnNlVGVybSgpO1xuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBbXTtcbiAgICAgIHMzID0gcGVnJGN1cnJQb3M7XG4gICAgICBzNCA9IHBlZyRwYXJzZV8oKTtcbiAgICAgIHJ1bGUkZXhwZWN0cyhwZWckZTApO1xuICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0Mykge1xuICAgICAgICBzNSA9IHBlZyRjMDtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICAgIGlmIChzNSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBydWxlJGV4cGVjdHMocGVnJGUxKTtcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0NSkge1xuICAgICAgICAgIHM1ID0gcGVnJGMxO1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczUgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczYgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgIHM3ID0gcGVnJHBhcnNlVGVybSgpO1xuICAgICAgICBpZiAoczcgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzNCA9IFtzNCwgczUsIHM2LCBzN107XG4gICAgICAgICAgczMgPSBzNDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMzO1xuICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMztcbiAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgICAgd2hpbGUgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyLnB1c2goczMpO1xuICAgICAgICBzMyA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBzNCA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgcnVsZSRleHBlY3RzKHBlZyRlMCk7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDMpIHtcbiAgICAgICAgICBzNSA9IHBlZyRjMDtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczUgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBydWxlJGV4cGVjdHMocGVnJGUxKTtcbiAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ1KSB7XG4gICAgICAgICAgICBzNSA9IHBlZyRjMTtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczYgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgczcgPSBwZWckcGFyc2VUZXJtKCk7XG4gICAgICAgICAgaWYgKHM3ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzNCA9IFtzNCwgczUsIHM2LCBzN107XG4gICAgICAgICAgICBzMyA9IHM0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMzO1xuICAgICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMzO1xuICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRmMChzMSwgczIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICByZXR1cm4gczA7XG4gIH1cbiAgZnVuY3Rpb24gcGVnJHBhcnNlVGVybSgpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNSwgczYsIHM3O1xuICAgIHZhciBydWxlJGV4cGVjdHMgPSBmdW5jdGlvbihleHBlY3RlZDIpIHtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApXG4gICAgICAgIHBlZyRleHBlY3QoZXhwZWN0ZWQyKTtcbiAgICB9O1xuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBwZWckcGFyc2VFeHBvbmVudGlhbCgpO1xuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBbXTtcbiAgICAgIHMzID0gcGVnJGN1cnJQb3M7XG4gICAgICBzNCA9IHBlZyRwYXJzZV8oKTtcbiAgICAgIHJ1bGUkZXhwZWN0cyhwZWckZTIpO1xuICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0Mikge1xuICAgICAgICBzNSA9IHBlZyRjMjtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICAgIGlmIChzNSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBydWxlJGV4cGVjdHMocGVnJGUzKTtcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0Nykge1xuICAgICAgICAgIHM1ID0gcGVnJGMzO1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczUgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczYgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgIHM3ID0gcGVnJHBhcnNlRXhwb25lbnRpYWwoKTtcbiAgICAgICAgaWYgKHM3ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczQgPSBbczQsIHM1LCBzNiwgczddO1xuICAgICAgICAgIHMzID0gczQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMztcbiAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczM7XG4gICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMi5wdXNoKHMzKTtcbiAgICAgICAgczMgPSBwZWckY3VyclBvcztcbiAgICAgICAgczQgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgIHJ1bGUkZXhwZWN0cyhwZWckZTIpO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQyKSB7XG4gICAgICAgICAgczUgPSBwZWckYzI7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHM1ID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgcnVsZSRleHBlY3RzKHBlZyRlMyk7XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0Nykge1xuICAgICAgICAgICAgczUgPSBwZWckYzM7XG4gICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHM2ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgIHM3ID0gcGVnJHBhcnNlRXhwb25lbnRpYWwoKTtcbiAgICAgICAgICBpZiAoczcgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM0ID0gW3M0LCBzNSwgczYsIHM3XTtcbiAgICAgICAgICAgIHMzID0gczQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczM7XG4gICAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczM7XG4gICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJGYxKHMxLCBzMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuICAgIHJldHVybiBzMDtcbiAgfVxuICBmdW5jdGlvbiBwZWckcGFyc2VFeHBvbmVudGlhbCgpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNSwgczYsIHM3O1xuICAgIHZhciBydWxlJGV4cGVjdHMgPSBmdW5jdGlvbihleHBlY3RlZDIpIHtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApXG4gICAgICAgIHBlZyRleHBlY3QoZXhwZWN0ZWQyKTtcbiAgICB9O1xuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBwZWckcGFyc2VGYWN0b3IoKTtcbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyID0gW107XG4gICAgICBzMyA9IHBlZyRjdXJyUG9zO1xuICAgICAgczQgPSBwZWckcGFyc2VfKCk7XG4gICAgICBydWxlJGV4cGVjdHMocGVnJGU0KTtcbiAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDIpID09PSBwZWckYzQpIHtcbiAgICAgICAgczUgPSBwZWckYzQ7XG4gICAgICAgIHBlZyRjdXJyUG9zICs9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczYgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgIHM3ID0gcGVnJHBhcnNlRmFjdG9yKCk7XG4gICAgICAgIGlmIChzNyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHM0ID0gW3M0LCBzNSwgczYsIHM3XTtcbiAgICAgICAgICBzMyA9IHM0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczM7XG4gICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMzO1xuICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgICB3aGlsZSAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIucHVzaChzMyk7XG4gICAgICAgIHMzID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIHM0ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICBydWxlJGV4cGVjdHMocGVnJGU0KTtcbiAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgMikgPT09IHBlZyRjNCkge1xuICAgICAgICAgIHM1ID0gcGVnJGM0O1xuICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczUgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHM2ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgIHM3ID0gcGVnJHBhcnNlRmFjdG9yKCk7XG4gICAgICAgICAgaWYgKHM3ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzNCA9IFtzNCwgczUsIHM2LCBzN107XG4gICAgICAgICAgICBzMyA9IHM0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMzO1xuICAgICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMzO1xuICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRmMShzMSwgczIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICByZXR1cm4gczA7XG4gIH1cbiAgZnVuY3Rpb24gcGVnJHBhcnNlRmFjdG9yKCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1O1xuICAgIHZhciBydWxlJGV4cGVjdHMgPSBmdW5jdGlvbihleHBlY3RlZDIpIHtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApXG4gICAgICAgIHBlZyRleHBlY3QoZXhwZWN0ZWQyKTtcbiAgICB9O1xuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgcnVsZSRleHBlY3RzKHBlZyRlNSk7XG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0MCkge1xuICAgICAgczEgPSBwZWckYzU7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBwZWckcGFyc2VfKCk7XG4gICAgICBzMyA9IHBlZyRwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzNCA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgcnVsZSRleHBlY3RzKHBlZyRlNik7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDEpIHtcbiAgICAgICAgICBzNSA9IHBlZyRjNjtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRmMihzMyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICB9XG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMCA9IHBlZyRwYXJzZUZsb2F0KCk7XG4gICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczAgPSBwZWckcGFyc2VJbnRlZ2VyKCk7XG4gICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgICAgczEgPSBwZWckcGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBydWxlJGV4cGVjdHMocGVnJGU1KTtcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDApIHtcbiAgICAgICAgICAgICAgczIgPSBwZWckYzU7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczMgPSBwZWckcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHJ1bGUkZXhwZWN0cyhwZWckZTYpO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDEpIHtcbiAgICAgICAgICAgICAgICAgIHM0ID0gcGVnJGM2O1xuICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgczQgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgczAgPSBwZWckZjMoczEsIHMzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMCA9IHBlZyRwYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHMwO1xuICB9XG4gIGZ1bmN0aW9uIHBlZyRwYXJzZUZsb2F0KCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1O1xuICAgIHZhciBydWxlJGV4cGVjdHMgPSBmdW5jdGlvbihleHBlY3RlZDIpIHtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApXG4gICAgICAgIHBlZyRleHBlY3QoZXhwZWN0ZWQyKTtcbiAgICB9O1xuICAgIHJ1bGUkZXhwZWN0cyhwZWckZTcpO1xuICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBbXTtcbiAgICBpZiAocGVnJHIwLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgIHMyID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICB9XG4gICAgd2hpbGUgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMS5wdXNoKHMyKTtcbiAgICAgIGlmIChwZWckcjAudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgfVxuICAgIHMyID0gW107XG4gICAgaWYgKHBlZyRyMS50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICBzMyA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgd2hpbGUgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyLnB1c2goczMpO1xuICAgICAgICBpZiAocGVnJHIxLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICBzMyA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIGlmIChpbnB1dC5sZW5ndGggPiBwZWckY3VyclBvcykge1xuICAgICAgICBzMyA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczQgPSBbXTtcbiAgICAgICAgaWYgKHBlZyRyMS50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgICAgczUgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczUgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHdoaWxlIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczQucHVzaChzNSk7XG4gICAgICAgICAgICBpZiAocGVnJHIxLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICAgICAgczUgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgczUgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckZjQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICByZXR1cm4gczA7XG4gIH1cbiAgZnVuY3Rpb24gcGVnJHBhcnNlSW50ZWdlcigpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczM7XG4gICAgdmFyIHJ1bGUkZXhwZWN0cyA9IGZ1bmN0aW9uKGV4cGVjdGVkMikge1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMClcbiAgICAgICAgcGVnJGV4cGVjdChleHBlY3RlZDIpO1xuICAgIH07XG4gICAgcnVsZSRleHBlY3RzKHBlZyRlOCk7XG4gICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IFtdO1xuICAgIGlmIChwZWckcjAudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICB3aGlsZSAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMxLnB1c2goczIpO1xuICAgICAgaWYgKHBlZyRyMC50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgIHMyID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICB9XG4gICAgczIgPSBbXTtcbiAgICBpZiAocGVnJHIxLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgIHMzID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICB9XG4gICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICB3aGlsZSAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIucHVzaChzMyk7XG4gICAgICAgIGlmIChwZWckcjEudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgIHMzID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRmNSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICByZXR1cm4gczA7XG4gIH1cbiAgZnVuY3Rpb24gcGVnJHBhcnNlSWRlbnRpZmllcigpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0O1xuICAgIHZhciBydWxlJGV4cGVjdHMgPSBmdW5jdGlvbihleHBlY3RlZDIpIHtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApXG4gICAgICAgIHBlZyRleHBlY3QoZXhwZWN0ZWQyKTtcbiAgICB9O1xuICAgIHJ1bGUkZXhwZWN0cyhwZWckZTkpO1xuICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBbXTtcbiAgICBpZiAocGVnJHIwLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgIHMyID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICB9XG4gICAgd2hpbGUgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMS5wdXNoKHMyKTtcbiAgICAgIGlmIChwZWckcjAudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwZWckcjIudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMzID0gW107XG4gICAgICBpZiAocGVnJHIzLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgczQgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczQgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgICAgd2hpbGUgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMzLnB1c2goczQpO1xuICAgICAgICBpZiAocGVnJHIzLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICBzNCA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckZjYoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICB9XG4gICAgcGVnJHNpbGVudEZhaWxzLS07XG4gICAgcmV0dXJuIHMwO1xuICB9XG4gIGZ1bmN0aW9uIHBlZyRwYXJzZV8oKSB7XG4gICAgdmFyIHMwLCBzMTtcbiAgICB2YXIgcnVsZSRleHBlY3RzID0gZnVuY3Rpb24oZXhwZWN0ZWQyKSB7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKVxuICAgICAgICBwZWckZXhwZWN0KGV4cGVjdGVkMik7XG4gICAgfTtcbiAgICBydWxlJGV4cGVjdHMocGVnJGUxMCk7XG4gICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgczAgPSBbXTtcbiAgICBpZiAocGVnJHI0LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgIHMxID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICB9XG4gICAgd2hpbGUgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMC5wdXNoKHMxKTtcbiAgICAgIGlmIChwZWckcjQudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICBzMSA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgfVxuICAgIHBlZyRzaWxlbnRGYWlscy0tO1xuICAgIHJldHVybiBzMDtcbiAgfVxuICBmdW5jdGlvbiBtYWtlTm9kZShsaHMsIHJocywgb3ApIHtcbiAgICBpZiAodHlwZW9mIGxocyA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgcmhzID09PSBcIm51bWJlclwiKSB7XG4gICAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgcmV0dXJuIGxocyArIHJocztcbiAgICAgICAgY2FzZSBcIi1cIjpcbiAgICAgICAgICByZXR1cm4gbGhzIC0gcmhzO1xuICAgICAgICBjYXNlIFwiKlwiOlxuICAgICAgICAgIHJldHVybiBsaHMgKiByaHM7XG4gICAgICAgIGNhc2UgXCIvXCI6XG4gICAgICAgICAgcmV0dXJuIGxocyAvIHJocztcbiAgICAgICAgY2FzZSBcIioqXCI6XG4gICAgICAgICAgcmV0dXJuIE1hdGgucG93KGxocywgcmhzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGxocyxcbiAgICAgIHJocyxcbiAgICAgIG9wXG4gICAgfTtcbiAgfVxuICBwZWckYmVnaW4oKTtcbiAgcGVnJHJlc3VsdCA9IHBlZyRzdGFydFJ1bGVGdW5jdGlvbigpO1xuICBpZiAocGVnJHJlc3VsdCAhPT0gcGVnJEZBSUxFRCAmJiBwZWckY3VyclBvcyA9PT0gaW5wdXQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHBlZyRyZXN1bHQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHBlZyRyZXN1bHQgIT09IHBlZyRGQUlMRUQgJiYgcGVnJGN1cnJQb3MgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgIHBlZyRleHBlY3QocGVnJGVuZEV4cGVjdGF0aW9uKCkpO1xuICAgIH1cbiAgICB0aHJvdyBwZWckYnVpbGRFcnJvcigpO1xuICB9XG59XG5cbnZhciBfX2RlZlByb3AkMyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AkMyA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkMyhvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCQzID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3AkMyhvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuZnVuY3Rpb24gZGVmYXVsdEZvcihhcmcsIHZhbCkge1xuICByZXR1cm4gdHlwZW9mIGFyZyAhPT0gXCJ1bmRlZmluZWRcIiA/IGFyZyA6IHZhbDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZTNEQ29udGV4dChjYW52YXMsIG9wdEF0dHJpYnMpIHtcbiAgY29uc3QgbmFtZXMgPSBbXCJ3ZWJnbFwiLCBcImV4cGVyaW1lbnRhbC13ZWJnbFwiXTtcbiAgbGV0IGNvbnRleHQgPSBudWxsO1xuICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgbmFtZXMubGVuZ3RoOyArK2lpKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChuYW1lc1tpaV0sIG9wdEF0dHJpYnMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoIWNvbnRleHQgfHwgIWNvbnRleHQuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfZmxvYXRcIikpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY29udGV4dDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0oZ2wsIHZlcnRleFNoYWRlclNvdXJjZTIsIGZyYWdtZW50U2hhZGVyU291cmNlMikge1xuICBjb25zdCB2ZXJ0ZXhTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuVkVSVEVYX1NIQURFUik7XG4gIGdsLnNoYWRlclNvdXJjZSh2ZXJ0ZXhTaGFkZXIsIHZlcnRleFNoYWRlclNvdXJjZTIpO1xuICBnbC5jb21waWxlU2hhZGVyKHZlcnRleFNoYWRlcik7XG4gIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHZlcnRleFNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGdsLmdldFNoYWRlckluZm9Mb2codmVydGV4U2hhZGVyKSk7XG4gIH1cbiAgY29uc3QgZnJhZ21lbnRTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuRlJBR01FTlRfU0hBREVSKTtcbiAgZ2wuc2hhZGVyU291cmNlKGZyYWdtZW50U2hhZGVyLCBmcmFnbWVudFNoYWRlclNvdXJjZTIpO1xuICBnbC5jb21waWxlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcbiAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoZnJhZ21lbnRTaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihnbC5nZXRTaGFkZXJJbmZvTG9nKGZyYWdtZW50U2hhZGVyKSk7XG4gIH1cbiAgY29uc3QgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XG4gIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XG4gIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuICByZXR1cm4gcHJvZ3JhbTtcbn1cbmZ1bmN0aW9uIHNldFJlY3RhbmdsZShnbCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICBjb25zdCB4MSA9IHg7XG4gIGNvbnN0IHgyID0geCArIHdpZHRoO1xuICBjb25zdCB5MSA9IHk7XG4gIGNvbnN0IHkyID0geSArIGhlaWdodDtcbiAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgIHgxLFxuICAgIHkxLFxuICAgIHgyLFxuICAgIHkxLFxuICAgIHgxLFxuICAgIHkyLFxuICAgIHgxLFxuICAgIHkyLFxuICAgIHgyLFxuICAgIHkxLFxuICAgIHgyLFxuICAgIHkyXG4gIF0pLCBnbC5TVEFUSUNfRFJBVyk7XG59XG5mdW5jdGlvbiBjcmVhdGVEYXRhc2V0KGdsLCBpZCwgZGF0YSwgd2lkdGgsIGhlaWdodCkge1xuICBsZXQgdGV4dHVyZURhdGE7XG4gIGlmIChnbCkge1xuICAgIGdsLnZpZXdwb3J0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIHRleHR1cmVEYXRhID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmVEYXRhKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgIGdsLnRleEltYWdlMkQoXG4gICAgICBnbC5URVhUVVJFXzJELFxuICAgICAgMCxcbiAgICAgIGdsLkxVTUlOQU5DRSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgMCxcbiAgICAgIGdsLkxVTUlOQU5DRSxcbiAgICAgIGdsLkZMT0FULFxuICAgICAgbmV3IEZsb2F0MzJBcnJheShkYXRhKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHsgdGV4dHVyZURhdGEsIHdpZHRoLCBoZWlnaHQsIGRhdGEsIGlkIH07XG59XG5mdW5jdGlvbiBkZXN0cm95RGF0YXNldChnbCwgZGF0YXNldCkge1xuICBpZiAoZ2wpIHtcbiAgICBnbC5kZWxldGVUZXh0dXJlKGRhdGFzZXQudGV4dHVyZURhdGEpO1xuICB9XG59XG5mdW5jdGlvbiBhZGRDb2xvclNjYWxlKG5hbWUsIGNvbG9ycywgcG9zaXRpb25zKSB7XG4gIGlmIChjb2xvcnMubGVuZ3RoICE9PSBwb3NpdGlvbnMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb2xvciBzY2FsZS5cIik7XG4gIH1cbiAgY29sb3JzY2FsZXNbbmFtZV0gPSB7IGNvbG9ycywgcG9zaXRpb25zIH07XG59XG5mdW5jdGlvbiByZW5kZXJDb2xvclNjYWxlVG9DYW52YXMobmFtZSwgY2FudmFzLCB0eXBlID0gXCJjb250aW51b3VzXCIpIHtcbiAgY29uc3QgY3NEZWYgPSBjb2xvcnNjYWxlc1tuYW1lXTtcbiAgY2FudmFzLmhlaWdodCA9IDE7XG4gIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gIGNvbnN0IHdpZHRoID0gODE5MjtcbiAgaWYgKCFjdHgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZ2V0IGNhbnZhcyBjb250ZXh0LlwiKTtcbiAgfVxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGNzRGVmKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGlmICh0eXBlID09PSBcImNvbnRpbnVvdXNcIikge1xuICAgICAgY29uc3QgZ3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgMCwgd2lkdGgsIDEpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjc0RlZi5jb2xvcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKGNzRGVmLnBvc2l0aW9uc1tpXSwgY3NEZWYuY29sb3JzW2ldKTtcbiAgICAgIH1cbiAgICAgIGN0eC5maWxsU3R5bGUgPSBncmFkaWVudDtcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgMSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcImRpc2NyZXRlXCIpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3NEZWYuY29sb3JzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IG5vd1BvcyA9IGNzRGVmLnBvc2l0aW9uc1tpXSwgbGFzdFBvcyA9IGNzRGVmLnBvc2l0aW9uc1tpICsgMV07XG4gICAgICAgIGNvbnN0IHN0YXJ0UG9zID0gbm93UG9zICogKHdpZHRoIC0gMTApO1xuICAgICAgICBjb25zdCBlbmRQb3MgPSBsYXN0UG9zID8gbGFzdFBvcyAqICh3aWR0aCAtIDEwKSA6IHdpZHRoO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gY3NEZWYuY29sb3JzW2ldO1xuICAgICAgICBjdHguZmlsbFJlY3Qoc3RhcnRQb3MsIDAsIGVuZFBvcyAtIHN0YXJ0UG9zLCAxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb2xvciBzY2FsZSB0eXBlLlwiKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGNzRGVmKSA9PT0gXCJbb2JqZWN0IFVpbnQ4QXJyYXldXCIpIHtcbiAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICBjb25zdCBpbWdEYXRhID0gY3R4LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgMSk7XG4gICAgaW1nRGF0YS5kYXRhLnNldChjc0RlZik7XG4gICAgY3R4LnB1dEltYWdlRGF0YShpbWdEYXRhLCAwLCAwKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb2xvciBzY2FsZSBub3QgZGVmaW5lZC5cIik7XG4gIH1cbn1cbmNvbnN0IHZlcnRleFNoYWRlclNvdXJjZSA9IGBcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247XG5hdHRyaWJ1dGUgdmVjMiBhX3RleENvb3JkO1xudW5pZm9ybSBtYXQzIHVfbWF0cml4O1xudW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjtcbnZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xudm9pZCBtYWluKCkge1xuICAvLyBhcHBseSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcbiAgdmVjMiBwb3NpdGlvbiA9ICh1X21hdHJpeCAqIHZlYzMoYV9wb3NpdGlvbiwgMSkpLnh5O1xuICAvLyBjb252ZXJ0IHRoZSByZWN0YW5nbGUgZnJvbSBwaXhlbHMgdG8gMC4wIHRvIDEuMFxuICB2ZWMyIHplcm9Ub09uZSA9IHBvc2l0aW9uIC8gdV9yZXNvbHV0aW9uO1xuICAvLyBjb252ZXJ0IGZyb20gMC0+MSB0byAwLT4yXG4gIHZlYzIgemVyb1RvVHdvID0gemVyb1RvT25lICogMi4wO1xuICAvLyBjb252ZXJ0IGZyb20gMC0+MiB0byAtMS0+KzEgKGNsaXBzcGFjZSlcbiAgdmVjMiBjbGlwU3BhY2UgPSB6ZXJvVG9Ud28gLSAxLjA7XG4gIGdsX1Bvc2l0aW9uID0gdmVjNChjbGlwU3BhY2UgKiB2ZWMyKDEsIC0xKSwgMCwgMSk7XG4gIC8vIHBhc3MgdGhlIHRleENvb3JkIHRvIHRoZSBmcmFnbWVudCBzaGFkZXJcbiAgLy8gVGhlIEdQVSB3aWxsIGludGVycG9sYXRlIHRoaXMgdmFsdWUgYmV0d2VlbiBwb2ludHMuXG4gIHZfdGV4Q29vcmQgPSBhX3RleENvb3JkO1xufWA7XG5jb25zdCBmcmFnbWVudFNoYWRlclNvdXJjZSA9IGBcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuLy8gb3VyIHRleHR1cmVcbnVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZURhdGE7XG51bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmVTY2FsZTtcbnVuaWZvcm0gdmVjMiB1X3RleHR1cmVTaXplO1xudW5pZm9ybSB2ZWMyIHVfZG9tYWluO1xudW5pZm9ybSB2ZWMyIHVfZGlzcGxheV9yYW5nZTtcbnVuaWZvcm0gYm9vbCB1X2FwcGx5X2Rpc3BsYXlfcmFuZ2U7XG51bmlmb3JtIGZsb2F0IHVfbm9EYXRhVmFsdWU7XG51bmlmb3JtIGJvb2wgdV9jbGFtcExvdztcbnVuaWZvcm0gYm9vbCB1X2NsYW1wSGlnaDtcbi8vIHRoZSB0ZXhDb29yZHMgcGFzc2VkIGluIGZyb20gdGhlIHZlcnRleCBzaGFkZXIuXG52YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcblxuYm9vbCBpc25hbiggZmxvYXQgdmFsICkge1xuICByZXR1cm4gKCB2YWwgPCAwLjAgfHwgMC4wIDwgdmFsIHx8IHZhbCA9PSAwLjAgKSA/IGZhbHNlIDogdHJ1ZTtcbn1cblxudm9pZCBtYWluKCkge1xuICB2ZWMyIG9uZVBpeGVsID0gdmVjMigxLjAsIDEuMCkgLyB1X3RleHR1cmVTaXplO1xuICBmbG9hdCB2YWx1ZSA9IHRleHR1cmUyRCh1X3RleHR1cmVEYXRhLCB2X3RleENvb3JkKVswXTtcbiAgaWYodmFsdWUgPCAtMy40MDI4MjM0NjZlKzM4KSAvLyBDaGVjayBmb3IgcG9zc2libGUgTmFOIHZhbHVlXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsIDAsIDAsIDAuMCk7XG4gIGVsc2UgaWYgKHZhbHVlID09IHVfbm9EYXRhVmFsdWUgfHwgaXNuYW4odmFsdWUpKVxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLCAwLCAwLjApO1xuICBlbHNlIGlmICh1X2FwcGx5X2Rpc3BsYXlfcmFuZ2UgJiYgKHZhbHVlIDwgdV9kaXNwbGF5X3JhbmdlWzBdIHx8IHZhbHVlID49IHVfZGlzcGxheV9yYW5nZVsxXSkpXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLCAwLCAwLjApO1xuICBlbHNlIGlmICgoIXVfY2xhbXBMb3cgJiYgdmFsdWUgPCB1X2RvbWFpblswXSkgfHwgKCF1X2NsYW1wSGlnaCAmJiB2YWx1ZSA+IHVfZG9tYWluWzFdKSlcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAsIDAsIDAsIDApO1xuICBlbHNlIHtcbiAgICBmbG9hdCBub3JtYWxpc2VkVmFsdWUgPSAodmFsdWUgLSB1X2RvbWFpblswXSkgLyAodV9kb21haW5bMV0gLSB1X2RvbWFpblswXSk7XG4gICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVfdGV4dHVyZVNjYWxlLCB2ZWMyKG5vcm1hbGlzZWRWYWx1ZSwgMCkpO1xuICB9XG59YDtcbmNsYXNzIHBsb3Qge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgX19wdWJsaWNGaWVsZCQzKHRoaXMsIFwiY2FudmFzXCIpO1xuICAgIF9fcHVibGljRmllbGQkMyh0aGlzLCBcImN1cnJlbnREYXRhc2V0XCIpO1xuICAgIF9fcHVibGljRmllbGQkMyh0aGlzLCBcImRhdGFzZXRDb2xsZWN0aW9uXCIpO1xuICAgIF9fcHVibGljRmllbGQkMyh0aGlzLCBcImdsXCIpO1xuICAgIF9fcHVibGljRmllbGQkMyh0aGlzLCBcInByb2dyYW1cIik7XG4gICAgX19wdWJsaWNGaWVsZCQzKHRoaXMsIFwidGV4Q29vcmRCdWZmZXJcIik7XG4gICAgX19wdWJsaWNGaWVsZCQzKHRoaXMsIFwiY3R4XCIpO1xuICAgIF9fcHVibGljRmllbGQkMyh0aGlzLCBcImRpc3BsYXlSYW5nZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDModGhpcywgXCJhcHBseURpc3BsYXlSYW5nZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDModGhpcywgXCJtYXRyaXhcIik7XG4gICAgX19wdWJsaWNGaWVsZCQzKHRoaXMsIFwiY29sb3JTY2FsZUltYWdlXCIpO1xuICAgIF9fcHVibGljRmllbGQkMyh0aGlzLCBcImRvbWFpblwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDModGhpcywgXCJjb2xvclNjYWxlQ2FudmFzXCIpO1xuICAgIF9fcHVibGljRmllbGQkMyh0aGlzLCBcIm5hbWVcIik7XG4gICAgX19wdWJsaWNGaWVsZCQzKHRoaXMsIFwiY2xhbXBMb3dcIik7XG4gICAgX19wdWJsaWNGaWVsZCQzKHRoaXMsIFwiY2xhbXBIaWdoXCIpO1xuICAgIF9fcHVibGljRmllbGQkMyh0aGlzLCBcInRleHR1cmVTY2FsZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDModGhpcywgXCJub0RhdGFWYWx1ZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDModGhpcywgXCJleHByZXNzaW9uQXN0XCIpO1xuICAgIF9fcHVibGljRmllbGQkMyh0aGlzLCBcImNvbG9yVHlwZVwiLCBcImNvbnRpbnVvdXNcIik7XG4gICAgX19wdWJsaWNGaWVsZCQzKHRoaXMsIFwicG9zaXRpb25CdWZmZXJcIik7XG4gICAgX19wdWJsaWNGaWVsZCQzKHRoaXMsIFwicHJvZ3JhbUNhY2hlXCIsIHt9KTtcbiAgICB0aGlzLmRhdGFzZXRDb2xsZWN0aW9uID0ge307XG4gICAgdGhpcy5jdXJyZW50RGF0YXNldCA9IG51bGw7XG4gICAgdGhpcy5zZXRDYW52YXMob3B0aW9ucy5jYW52YXMpO1xuICAgIHRoaXMuc2V0Q29sb3JUeXBlKG9wdGlvbnMudHlwZSk7XG4gICAgaWYgKGRlZmF1bHRGb3Iob3B0aW9ucy51c2VXZWJHTCwgdHJ1ZSkpIHtcbiAgICAgIGNvbnN0IGdsID0gY3JlYXRlM0RDb250ZXh0KHRoaXMuY2FudmFzLCB7IHByZW11bHRpcGxpZWRBbHBoYTogZmFsc2UgfSk7XG4gICAgICBpZiAoZ2wgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5nbCA9IGdsO1xuICAgICAgICB0aGlzLnByb2dyYW0gPSBjcmVhdGVQcm9ncmFtKGdsLCB2ZXJ0ZXhTaGFkZXJTb3VyY2UsIGZyYWdtZW50U2hhZGVyU291cmNlKTtcbiAgICAgICAgZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuICAgICAgICBjb25zdCB0ZXhDb29yZExvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5wcm9ncmFtLCBcImFfdGV4Q29vcmRcIik7XG4gICAgICAgIHRoaXMudGV4Q29vcmRCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMudGV4Q29vcmRCdWZmZXIpO1xuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAgICAgMCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIDEsXG4gICAgICAgICAgMCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIDEsXG4gICAgICAgICAgMCxcbiAgICAgICAgICAxLFxuICAgICAgICAgIDEsXG4gICAgICAgICAgMCxcbiAgICAgICAgICAxLFxuICAgICAgICAgIDFcbiAgICAgICAgXSksIGdsLlNUQVRJQ19EUkFXKTtcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGV4Q29vcmRMb2NhdGlvbik7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGV4Q29vcmRMb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbkJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5wb3NpdGlvbkJ1ZmZlcik7XG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KFtcbiAgICAgICAgICAwLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgMSxcbiAgICAgICAgICAwLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgMSxcbiAgICAgICAgICAwLFxuICAgICAgICAgIDEsXG4gICAgICAgICAgMSxcbiAgICAgICAgICAwLFxuICAgICAgICAgIDEsXG4gICAgICAgICAgMVxuICAgICAgICBdKSwgZ2wuU1RBVElDX0RSQVcpO1xuICAgICAgICBjb25zdCBwb3NpdGlvbkxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5wcm9ncmFtLCBcImFfcG9zaXRpb25cIik7XG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uTG9jYXRpb24pO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBvc2l0aW9uTG9jYXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmNvbG9yU2NhbGVJbWFnZSkge1xuICAgICAgdGhpcy5zZXRDb2xvclNjYWxlSW1hZ2Uob3B0aW9ucy5jb2xvclNjYWxlSW1hZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldENvbG9yU2NhbGUoZGVmYXVsdEZvcihvcHRpb25zLmNvbG9yU2NhbGUsIFwidmlyaWRpc1wiKSk7XG4gICAgfVxuICAgIHRoaXMuc2V0RG9tYWluKGRlZmF1bHRGb3Iob3B0aW9ucy5kb21haW4sIFswLCAxXSkpO1xuICAgIHRoaXMuZGlzcGxheVJhbmdlID0gZGVmYXVsdEZvcihvcHRpb25zLmRpc3BsYXlSYW5nZSwgWzAsIDFdKTtcbiAgICB0aGlzLmFwcGx5RGlzcGxheVJhbmdlID0gZGVmYXVsdEZvcihvcHRpb25zLmFwcGx5RGlzcGxheVJhbmdlLCBmYWxzZSk7XG4gICAgdGhpcy5zZXRDbGFtcChkZWZhdWx0Rm9yKG9wdGlvbnMuY2xhbXBMb3csIHRydWUpLCBvcHRpb25zLmNsYW1wSGlnaCk7XG4gICAgdGhpcy5zZXROb0RhdGFWYWx1ZShvcHRpb25zLm5vRGF0YVZhbHVlKTtcbiAgICBpZiAob3B0aW9ucy5kYXRhKSB7XG4gICAgICBjb25zdCBsID0gb3B0aW9ucy5kYXRhLmxlbmd0aDtcbiAgICAgIHRoaXMuc2V0RGF0YShcbiAgICAgICAgb3B0aW9ucy5kYXRhLFxuICAgICAgICBkZWZhdWx0Rm9yKG9wdGlvbnMud2lkdGgsIG9wdGlvbnMuZGF0YVtsIC0gMl0pLFxuICAgICAgICBkZWZhdWx0Rm9yKG9wdGlvbnMuaGVpZ2h0LCBvcHRpb25zLmRhdGFbbCAtIDJdKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZGF0YXNldHMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9ucy5kYXRhc2V0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBkcyA9IG9wdGlvbnMuZGF0YXNldHNbaV07XG4gICAgICAgIHRoaXMuYWRkRGF0YXNldChkcy5pZCwgZHMuZGF0YSwgZHMud2lkdGgsIGRzLmhlaWdodCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm1hdHJpeCkge1xuICAgICAgdGhpcy5tYXRyaXggPSBvcHRpb25zLm1hdHJpeDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tYXRyaXggPSBbXG4gICAgICAgIDEsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDEsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDFcbiAgICAgIF07XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHJhdyBkYXRhIGZyb20gdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBkYXRhc2V0LlxuICAgKiBAcmV0dXJucyB7VHlwZWRBcnJheX0gdGhlIGRhdGEgb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBkYXRhc2V0LlxuICAgKi9cbiAgZ2V0RGF0YSgpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5jdXJyZW50RGF0YXNldDtcbiAgICBpZiAoIWRhdGFzZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGRhdGFzZXQgYXZhaWxhYmxlLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGFzZXQuZGF0YTtcbiAgfVxuICAvKipcbiAgICogUXVlcnkgdGhlIHJhdyByYXN0ZXIgZGF0YSBhdCB0aGUgc3BlY2lmaWVkIGNvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge051bWJlcn0geCB0aGUgeCBjb29yZGluYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5IHRoZSB5IGNvb3JkaW5hdGVcbiAgICogQHJldHVybnMge051bWJlcn0gdGhlIHZhbHVlIGF0IHRoZSBzcGVjaWZpZWQgY29vcmRpbmF0ZXNcbiAgICovXG4gIGF0UG9pbnQoeCwgeSkge1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmN1cnJlbnREYXRhc2V0O1xuICAgIGlmICghZGF0YXNldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZGF0YXNldCBhdmFpbGFibGUuXCIpO1xuICAgIH0gZWxzZSBpZiAoeCA+PSBkYXRhc2V0LndpZHRoIHx8IHkgPj0gZGF0YXNldC5oZWlnaHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvb3JkaW5hdGVzIGFyZSBvdXRzaWRlIG9mIGltYWdlIGJvdW5kcy5cIik7XG4gICAgfVxuICAgIHJldHVybiBkYXRhc2V0LmRhdGFbeSAqIGRhdGFzZXQud2lkdGggKyB4XTtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSByYXcgcmFzdGVyIGRhdGEgdG8gYmUgcmVuZGVyZWQuIFRoaXMgY3JlYXRlcyBhIG5ldyB1bm5hbWVkIGRhdGFzZXQuXG4gICAqIEBwYXJhbSB7VHlwZWRBcnJheX0gZGF0YSB0aGUgcmF3IHJhc3RlciBkYXRhLiBUaGlzIGNhbiBiZSBhIHR5cGVkIGFycmF5IG9mXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBhbnkgdHlwZSwgYnV0IHdpbGwgYmUgY29lcmNlZCB0byBGbG9hdDMyQXJyYXkgd2hlblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgYmVlaW5nIHJlbmRlcmVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggdGhlIHdpZHRoIG9mIHRoZSByYXN0ZXIgaW1hZ2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCB0aGUgaGVpZ2h0IG9mIHRoZSBkYXRhXG4gICAqL1xuICBzZXREYXRhKGRhdGEsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50RGF0YXNldCAmJiB0aGlzLmN1cnJlbnREYXRhc2V0LmlkID09PSBudWxsKSB7XG4gICAgICBkZXN0cm95RGF0YXNldCh0aGlzLmdsLCB0aGlzLmN1cnJlbnREYXRhc2V0KTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50RGF0YXNldCA9IGNyZWF0ZURhdGFzZXQodGhpcy5nbCwgbnVsbCwgZGF0YSwgd2lkdGgsIGhlaWdodCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyBuYW1lZCBkYXRhc2V0LiBUaGUgc2VtYW50aWNzIGFyZSB0aGUgc2FtZSBhcyB3aXRoIEBzZWUgc2V0RGF0YS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIHRoZSBpZGVudGlmaWVyIGZvciB0aGUgZGF0YXNldC5cbiAgICogQHBhcmFtIHtUeXBlZEFycmF5fSBkYXRhIHRoZSByYXcgcmFzdGVyIGRhdGEuIFRoaXMgY2FuIGJlIGEgdHlwZWQgYXJyYXkgb2ZcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGFueSB0eXBlLCBidXQgd2lsbCBiZSBjb2VyY2VkIHRvIEZsb2F0MzJBcnJheSB3aGVuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBiZWVpbmcgcmVuZGVyZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCB0aGUgd2lkdGggb2YgdGhlIHJhc3RlciBpbWFnZVxuICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IHRoZSBoZWlnaHQgb2YgdGhlIGRhdGFcbiAgICovXG4gIGFkZERhdGFzZXQoaWQsIGRhdGEsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAodGhpcy5kYXRhc2V0QXZhaWxhYmxlKGlkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGVyZSBpcyBhbHJlYWR5IGEgZGF0YXNldCByZWdpc3RlcmVkIHdpdGggaWQgJyR7aWR9J2ApO1xuICAgIH1cbiAgICB0aGlzLmRhdGFzZXRDb2xsZWN0aW9uW2lkXSA9IGNyZWF0ZURhdGFzZXQodGhpcy5nbCwgaWQsIGRhdGEsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGlmICghdGhpcy5jdXJyZW50RGF0YXNldCkge1xuICAgICAgdGhpcy5jdXJyZW50RGF0YXNldCA9IHRoaXMuZGF0YXNldENvbGxlY3Rpb25baWRdO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBjdXJyZW50IGRhdGFzZXQgdG8gYmUgcmVuZGVyZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCB0aGUgaWRlbnRpZmllciBvZiB0aGUgZGF0YXNldCB0byBiZSByZW5kZXJlZC5cbiAgICovXG4gIHNldEN1cnJlbnREYXRhc2V0KGlkKSB7XG4gICAgaWYgKCF0aGlzLmRhdGFzZXRBdmFpbGFibGUoaWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHN1Y2ggZGF0YXNldCByZWdpc3RlcmVkOiAnJHtpZH0nYCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmN1cnJlbnREYXRhc2V0ICYmIHRoaXMuY3VycmVudERhdGFzZXQuaWQgPT09IG51bGwpIHtcbiAgICAgIGRlc3Ryb3lEYXRhc2V0KHRoaXMuZ2wsIHRoaXMuY3VycmVudERhdGFzZXQpO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnREYXRhc2V0ID0gdGhpcy5kYXRhc2V0Q29sbGVjdGlvbltpZF07XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZGF0YXNldC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIHRoZSBpZGVudGlmaWVyIG9mIHRoZSBkYXRhc2V0IHRvIGJlIHJlbW92ZWQuXG4gICAqL1xuICByZW1vdmVEYXRhc2V0KGlkKSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZGF0YXNldENvbGxlY3Rpb25baWRdO1xuICAgIGlmICghZGF0YXNldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBzdWNoIGRhdGFzZXQgcmVnaXN0ZXJlZDogJyR7aWR9J2ApO1xuICAgIH1cbiAgICBkZXN0cm95RGF0YXNldCh0aGlzLmdsLCBkYXRhc2V0KTtcbiAgICBpZiAodGhpcy5jdXJyZW50RGF0YXNldCA9PT0gZGF0YXNldCkge1xuICAgICAgdGhpcy5jdXJyZW50RGF0YXNldCA9IG51bGw7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLmRhdGFzZXRDb2xsZWN0aW9uW2lkXTtcbiAgfVxuICByZW1vdmVBbGxEYXRhc2V0KCkge1xuICAgIE9iamVjdC5rZXlzKHRoaXMuZGF0YXNldENvbGxlY3Rpb24pLmZvckVhY2goKGlkKSA9PiB0aGlzLnJlbW92ZURhdGFzZXQoaWQpKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIGRhdGFzZXQgaXMgYXZhaWxhYmxlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgdGhlIGlkZW50aWZpZXIgb2YgdGhlIGRhdGFzZXQgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSB3aGV0aGVyIG9yIG5vdCBhIGRhdGFzZXQgd2l0aCB0aGF0IGlkZW50aWZpZXIgaXMgZGVmaW5lZFxuICAgKi9cbiAgZGF0YXNldEF2YWlsYWJsZShpZCkge1xuICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eSh0aGlzLmRhdGFzZXRDb2xsZWN0aW9uLCBpZCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSByZW5kZXJlZCBjb2xvciBzY2FsZSBpbWFnZS5cbiAgICogQHJldHVybnMgeyhIVE1MQ2FudmFzRWxlbWVudHxIVE1MSW1hZ2VFbGVtZW50KX0gdGhlIGNhbnZhcyBvciBpbWFnZSBlbGVtZW50XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciB0aGUgcmVuZGVyZWQgY29sb3Igc2NhbGVcbiAgICovXG4gIGdldENvbG9yU2NhbGVJbWFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xvclNjYWxlSW1hZ2U7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgY2FudmFzIHRvIGRyYXcgdG8uIFdoZW4gbm8gY2FudmFzIGlzIHN1cHBsaWVkLCBhIG5ldyBjYW52YXMgZWxlbWVudFxuICAgKiBpcyBjcmVhdGVkLlxuICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50IHwgT2Zmc2NyZWVuQ2FudmFzfSBbY2FudmFzXSB0aGUgY2FudmFzIGVsZW1lbnQgdG8gcmVuZGVyIHRvLlxuICAgKi9cbiAgc2V0Q2FudmFzKGNhbnZhcykge1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gIH1cbiAgc2V0Q29sb3JUeXBlKHR5cGUpIHtcbiAgICB0aGlzLmNvbG9yVHlwZSA9IHR5cGUgIT0gbnVsbCA/IHR5cGUgOiBcImNvbnRpbnVvdXNcIjtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBuZXcgdmFsdWUgZG9tYWluIGZvciB0aGUgcmVuZGVyaW5nLlxuICAgKiBAcGFyYW0ge251bWJlcltdfSBkb21haW4gdGhlIHZhbHVlIGRvbWFpbiByYW5nZSBpbiB0aGUgZm9ybSBbbG93LCBoaWdoXVxuICAgKi9cbiAgc2V0RG9tYWluKGRvbWFpbikge1xuICAgIGlmICghZG9tYWluIHx8IGRvbWFpbi5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZG9tYWluIHNwZWNpZmllZC5cIik7XG4gICAgfVxuICAgIHRoaXMuZG9tYWluID0gZG9tYWluO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIGRpc3BsYXkgcmFuZ2UgdGhhdCB3aWxsIGJlIHJlbmRlcmVkLCB2YWx1ZXMgb3V0c2lkZSBvZiB0aGUgcmFuZ2VcbiAgICogd2lsbCBub3QgYmUgcmVuZGVyZWQgKHRyYW5zcGFyZW50KVxuICAgKiBAcGFyYW0ge251bWJlcltdfSBkaXNwbGF5UmFuZ2UgcmFuZ2UgYXJyYXkgaW4gdGhlIGZvcm0gW21pbiwgbWF4XVxuICAgKi9cbiAgc2V0RGlzcGxheVJhbmdlKGRpc3BsYXlSYW5nZSkge1xuICAgIGlmICghZGlzcGxheVJhbmdlIHx8IGRpc3BsYXlSYW5nZS5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmlldyByYW5nZSBzcGVjaWZpZWQuXCIpO1xuICAgIH1cbiAgICB0aGlzLmRpc3BsYXlSYW5nZSA9IGRpc3BsYXlSYW5nZTtcbiAgICB0aGlzLmFwcGx5RGlzcGxheVJhbmdlID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBjYW52YXMgdGhhdCBpcyBjdXJyZW50bHkgcmVuZGVyZWQgdG8uXG4gICAqIEByZXR1cm5zIHtIVE1MQ2FudmFzRWxlbWVudH0gdGhlIGNhbnZhcyB0aGF0IGlzIGN1cnJlbnRseSByZW5kZXJlZCB0by5cbiAgICovXG4gIGdldENhbnZhcygpIHtcbiAgICByZXR1cm4gdGhpcy5jYW52YXM7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGNvbG9yIHNjYWxlLlxuICAgKiBAcGFyYW0ge0NvbG9yU2NhbGVOYW1lc30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgY29sb3JzY2FsZS4gTXVzdCBiZSByZWdpc3RlcmVkLlxuICAgKi9cbiAgc2V0Q29sb3JTY2FsZShuYW1lKSB7XG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShjb2xvcnNjYWxlcywgbmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gc3VjaCBjb2xvciBzY2FsZSAnJHtuYW1lfSdgKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNvbG9yU2NhbGVDYW52YXMpIHtcbiAgICAgIHRoaXMuY29sb3JTY2FsZUNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICB0aGlzLmNvbG9yU2NhbGVDYW52YXMud2lkdGggPSAyNTY7XG4gICAgICB0aGlzLmNvbG9yU2NhbGVDYW52YXMuaGVpZ2h0ID0gMTtcbiAgICB9XG4gICAgcmVuZGVyQ29sb3JTY2FsZVRvQ2FudmFzKG5hbWUsIHRoaXMuY29sb3JTY2FsZUNhbnZhcywgdGhpcy5jb2xvclR5cGUpO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5zZXRDb2xvclNjYWxlSW1hZ2UodGhpcy5jb2xvclNjYWxlQ2FudmFzKTtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBjbGFtcGluZyBmb3IgdGhlIGxvd2VyIGFuZCB0aGUgdXBwZXIgYm9yZGVyIG9mIHRoZSB2YWx1ZXMuIFdoZW5cbiAgICogY2xhbXBpbmcgaXMgZW5hYmxlZCBmb3IgZWl0aGVyIHNpZGUsIHRoZSB2YWx1ZXMgYmVsb3cgb3IgYWJvdmUgd2lsbCBiZVxuICAgKiBjbGFtcGVkIHRvIHRoZSBtaW5pbXVtL21heGltdW0gY29sb3IuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2xhbXBMb3cgd2hldGhlciBvciBub3QgdGhlIG1pbmltdW0gc2hhbGwgYmUgY2xhbXBlZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBjbGFtcEhpZ2ggd2hldGhlciBvciBub3QgdGhlIG1heG1pbXVtIHNoYWxsIGJlIGNsYW1wZWQuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRzIHRvIGNsYW1wTWluLlxuICAgKi9cbiAgc2V0Q2xhbXAoY2xhbXBMb3csIGNsYW1wSGlnaCkge1xuICAgIHRoaXMuY2xhbXBMb3cgPSBjbGFtcExvdztcbiAgICB0aGlzLmNsYW1wSGlnaCA9IHR5cGVvZiBjbGFtcEhpZ2ggIT09IFwidW5kZWZpbmVkXCIgPyBjbGFtcEhpZ2ggOiBjbGFtcExvdztcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgY29sb3Igc2NhbGUgYXMgYW4gaW1hZ2Ugb3IgY2FudmFzLlxuICAgKiBAcGFyYW0geyhIVE1MQ2FudmFzRWxlbWVudHxIVE1MSW1hZ2VFbGVtZW50KX0gY29sb3JTY2FsZUltYWdlIHRoZSBuZXcgY29sb3JcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FsZSBpbWFnZVxuICAgKi9cbiAgc2V0Q29sb3JTY2FsZUltYWdlKGNvbG9yU2NhbGVJbWFnZSkge1xuICAgIHRoaXMuY29sb3JTY2FsZUltYWdlID0gY29sb3JTY2FsZUltYWdlO1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICBpZiAoZ2wpIHtcbiAgICAgIGlmICh0aGlzLnRleHR1cmVTY2FsZSkge1xuICAgICAgICBnbC5kZWxldGVUZXh0dXJlKHRoaXMudGV4dHVyZVNjYWxlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGV4dHVyZVNjYWxlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlU2NhbGUpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgY29sb3JTY2FsZUltYWdlKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgbm8tZGF0YS12YWx1ZTogYSBzcGVjaWFsIHZhbHVlIHRoYXQgd2lsbCBiZSByZW5kZXJlZCB0cmFuc3BhcmVudC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG5vRGF0YVZhbHVlIHRoZSBuby1kYXRhLXZhbHVlLiBVc2UgbnVsbCB0byBjbGVhciBhXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzbHkgc2V0IG5vLWRhdGEtdmFsdWUuXG4gICAqL1xuICBzZXROb0RhdGFWYWx1ZShub0RhdGFWYWx1ZSkge1xuICAgIHRoaXMubm9EYXRhVmFsdWUgPSBub0RhdGFWYWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmVuZGVyIHRoZSBtYXAgdG8gdGhlIHNwZWNpZmllZCBjYW52YXMgd2l0aCB0aGUgZ2l2ZW4gc2V0dGluZ3MuXG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuY3VycmVudERhdGFzZXQ7XG4gICAgY2FudmFzLndpZHRoID0gZGF0YXNldC53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gZGF0YXNldC5oZWlnaHQ7XG4gICAgbGV0IGlkcyA9IHRoaXMuZ2V0RXhwcmVzc2lvbklkcygpO1xuICAgIGlmICh0aGlzLmdsKSB7XG4gICAgICB0aGlzLnJlbmRlcldlYkdMKGRhdGFzZXQsIGlkcyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmN0eCkge1xuICAgICAgdGhpcy5yZW5kZXIyRChkYXRhc2V0KTtcbiAgICB9XG4gIH1cbiAgZ2V0RXhwcmVzc2lvbklkcygpIHtcbiAgICBpZiAoIXRoaXMuZXhwcmVzc2lvbkFzdClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGlkc1NldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3QgZ2V0SWRzID0gKG5vZGUpID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygbm9kZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZHNTZXQuYWRkKG5vZGUucmVwbGFjZSgvWystXS9nLCBcIlwiKSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG5vZGUubGhzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlkc1NldC5hZGQobm9kZS5saHMucmVwbGFjZSgvWystXS9nLCBcIlwiKSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBub2RlLmxocyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBnZXRJZHMobm9kZS5saHMpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBub2RlLnJocyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZHNTZXQuYWRkKG5vZGUucmhzLnJlcGxhY2UoL1srLV0vZywgXCJcIikpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygbm9kZS5yaHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZ2V0SWRzKG5vZGUucmhzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGdldElkcyh0aGlzLmV4cHJlc3Npb25Bc3QpO1xuICAgIHJldHVybiBBcnJheS5mcm9tKGlkc1NldCk7XG4gIH1cbiAgcmVuZGVyV2ViR0woZGF0YXNldCwgaWRzKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIGdsLnZpZXdwb3J0KDAsIDAsIGRhdGFzZXQud2lkdGgsIGRhdGFzZXQuaGVpZ2h0KTtcbiAgICBjb25zdCBwcm9ncmFtID0gdGhpcy5nZXRPckNyZWF0ZVByb2dyYW0oaWRzKTtcbiAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgIHRoaXMuc2V0dXBUZXh0dXJlcyhwcm9ncmFtLCBpZHMsIGRhdGFzZXQpO1xuICAgIHRoaXMuc2V0dXBVbmlmb3Jtcyhwcm9ncmFtKTtcbiAgICB0aGlzLnNldHVwQXR0cmlidXRlcyhwcm9ncmFtKTtcbiAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgMCwgNik7XG4gIH1cbiAgZ2V0T3JDcmVhdGVQcm9ncmFtKGlkcykge1xuICAgIGlmICghdGhpcy5leHByZXNzaW9uQXN0KSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9ncmFtO1xuICAgIH1cbiAgICBjb25zdCBleHByS2V5ID0gSlNPTi5zdHJpbmdpZnkodGhpcy5leHByZXNzaW9uQXN0KTtcbiAgICBpZiAodGhpcy5wcm9ncmFtQ2FjaGVbZXhwcktleV0pIHtcbiAgICAgIHJldHVybiB0aGlzLnByb2dyYW1DYWNoZVtleHByS2V5XTtcbiAgICB9XG4gICAgY29uc3QgdmVydGV4U2hhZGVyID0gdGhpcy5jcmVhdGVWZXJ0ZXhTaGFkZXIoKTtcbiAgICBjb25zdCBmcmFnbWVudFNoYWRlciA9IHRoaXMuY3JlYXRlRnJhZ21lbnRTaGFkZXIoaWRzKTtcbiAgICBjb25zdCBwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbSh0aGlzLmdsLCB2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyKTtcbiAgICB0aGlzLnByb2dyYW1DYWNoZVtleHByS2V5XSA9IHByb2dyYW07XG4gICAgcmV0dXJuIHByb2dyYW07XG4gIH1cbiAgY3JlYXRlVmVydGV4U2hhZGVyKCkge1xuICAgIHJldHVybiBgXG4gICAgICBhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uO1xuICAgICAgYXR0cmlidXRlIHZlYzIgYV90ZXhDb29yZDtcbiAgICAgIHVuaWZvcm0gbWF0MyB1X21hdHJpeDtcbiAgICAgIHVuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247XG4gICAgICB2YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgdmVjMiBwb3NpdGlvbiA9ICh1X21hdHJpeCAqIHZlYzMoYV9wb3NpdGlvbiwgMSkpLnh5O1xuICAgICAgICB2ZWMyIHplcm9Ub09uZSA9IHBvc2l0aW9uIC8gdV9yZXNvbHV0aW9uO1xuICAgICAgICB2ZWMyIHplcm9Ub1R3byA9IHplcm9Ub09uZSAqIDIuMDtcbiAgICAgICAgdmVjMiBjbGlwU3BhY2UgPSB6ZXJvVG9Ud28gLSAxLjA7XG4gICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChjbGlwU3BhY2UgKiB2ZWMyKDEsIC0xKSwgMCwgMSk7XG4gICAgICAgIHZfdGV4Q29vcmQgPSBhX3RleENvb3JkO1xuICAgICAgfVxuICAgIGA7XG4gIH1cbiAgY3JlYXRlRnJhZ21lbnRTaGFkZXIoaWRzKSB7XG4gICAgaWYgKCFpZHMpIHtcbiAgICAgIHJldHVybiBmcmFnbWVudFNoYWRlclNvdXJjZTtcbiAgICB9XG4gICAgY29uc3QgZXhwcmVzc2lvblJlZHVjZXIgPSAobm9kZSkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBub2RlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChub2RlLm9wID09PSBcIioqXCIpIHtcbiAgICAgICAgICByZXR1cm4gYHBvdygke2V4cHJlc3Npb25SZWR1Y2VyKG5vZGUubGhzKX0sICR7ZXhwcmVzc2lvblJlZHVjZXIobm9kZS5yaHMpfSlgO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLmZuKSB7XG4gICAgICAgICAgcmV0dXJuIGAoJHtub2RlLmZufSgke2V4cHJlc3Npb25SZWR1Y2VyKG5vZGUubGhzKX0pKWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAoJHtleHByZXNzaW9uUmVkdWNlcihub2RlLmxocyl9ICR7bm9kZS5vcH0gJHtleHByZXNzaW9uUmVkdWNlcihub2RlLnJocyl9KWA7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBub2RlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBgJHtub2RlfV92YWx1ZWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gYGZsb2F0KCR7bm9kZX0pYDtcbiAgICB9O1xuICAgIGNvbnN0IGNvbXBpbGVkRXhwcmVzc2lvbiA9IGV4cHJlc3Npb25SZWR1Y2VyKHRoaXMuZXhwcmVzc2lvbkFzdCk7XG4gICAgcmV0dXJuIGBcbiAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlU2NhbGU7XG4gICAgICAke2lkcy5tYXAoKGlkKSA9PiBgdW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlXyR7aWR9O2ApLmpvaW4oXCJcXG5cIil9XG4gICAgICB1bmlmb3JtIHZlYzIgdV90ZXh0dXJlU2l6ZTtcbiAgICAgIHVuaWZvcm0gdmVjMiB1X2RvbWFpbjtcbiAgICAgIHVuaWZvcm0gdmVjMiB1X2Rpc3BsYXlfcmFuZ2U7XG4gICAgICB1bmlmb3JtIGJvb2wgdV9hcHBseV9kaXNwbGF5X3JhbmdlO1xuICAgICAgdW5pZm9ybSBmbG9hdCB1X25vRGF0YVZhbHVlO1xuICAgICAgdW5pZm9ybSBib29sIHVfY2xhbXBMb3c7XG4gICAgICB1bmlmb3JtIGJvb2wgdV9jbGFtcEhpZ2g7XG4gICAgICB2YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgJHtpZHMubWFwKChpZCkgPT4gYGZsb2F0ICR7aWR9X3ZhbHVlID0gdGV4dHVyZTJEKHVfdGV4dHVyZV8ke2lkfSwgdl90ZXhDb29yZClbMF07YCkuam9pbihcIlxcblwiKX1cbiAgICAgICAgZmxvYXQgdmFsdWUgPSAke2NvbXBpbGVkRXhwcmVzc2lvbn07XG5cbiAgICAgICAgaWYgKHZhbHVlID09IHVfbm9EYXRhVmFsdWUpXG4gICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsIDAsIDAsIDAuMCk7XG4gICAgICAgIGVsc2UgaWYgKHVfYXBwbHlfZGlzcGxheV9yYW5nZSAmJiAodmFsdWUgPCB1X2Rpc3BsYXlfcmFuZ2VbMF0gfHwgdmFsdWUgPj0gdV9kaXNwbGF5X3JhbmdlWzFdKSlcbiAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCwgMCwgMCwgMC4wKTtcbiAgICAgICAgZWxzZSBpZiAoKCF1X2NsYW1wTG93ICYmIHZhbHVlIDwgdV9kb21haW5bMF0pIHx8ICghdV9jbGFtcEhpZ2ggJiYgdmFsdWUgPiB1X2RvbWFpblsxXSkpXG4gICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLCAwLCAwLCAwKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZmxvYXQgbm9ybWFsaXNlZFZhbHVlID0gKHZhbHVlIC0gdV9kb21haW5bMF0pIC8gKHVfZG9tYWluWzFdIC0gdV9kb21haW5bMF0pO1xuICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1X3RleHR1cmVTY2FsZSwgdmVjMihub3JtYWxpc2VkVmFsdWUsIDApKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGA7XG4gIH1cbiAgc2V0dXBUZXh0dXJlcyhwcm9ncmFtLCBpZHMsIGRhdGFzZXQpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgaWYgKGlkcykge1xuICAgICAgZ2wudW5pZm9ybTFpKGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfdGV4dHVyZVNjYWxlXCIpLCAwKTtcbiAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlU2NhbGUpO1xuICAgICAgaWRzLmZvckVhY2goKGlkLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IGluZGV4ICsgMTtcbiAgICAgICAgY29uc3QgZHMgPSB0aGlzLmRhdGFzZXRDb2xsZWN0aW9uW2lkXTtcbiAgICAgICAgaWYgKCFkcykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gc3VjaCBkYXRhc2V0IHJlZ2lzdGVyZWQ6ICcke2lkfSdgKTtcbiAgICAgICAgfVxuICAgICAgICBnbC51bmlmb3JtMWkoZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIGB1X3RleHR1cmVfJHtpZH1gKSwgbG9jYXRpb24pO1xuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsW2BURVhUVVJFJHtsb2NhdGlvbn1gXSk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGRzLnRleHR1cmVEYXRhKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbC51bmlmb3JtMWkoZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV90ZXh0dXJlRGF0YVwiKSwgMCk7XG4gICAgICBnbC51bmlmb3JtMWkoZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV90ZXh0dXJlU2NhbGVcIiksIDEpO1xuICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBkYXRhc2V0LnRleHR1cmVEYXRhKTtcbiAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTEpO1xuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlU2NhbGUpO1xuICAgIH1cbiAgfVxuICBzZXR1cFVuaWZvcm1zKHByb2dyYW0pIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgZ2wudW5pZm9ybTJmKGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfcmVzb2x1dGlvblwiKSwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBnbC51bmlmb3JtMmZ2KGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfZG9tYWluXCIpLCB0aGlzLmRvbWFpbik7XG4gICAgZ2wudW5pZm9ybTJmdihnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X2Rpc3BsYXlfcmFuZ2VcIiksIHRoaXMuZGlzcGxheVJhbmdlKTtcbiAgICBnbC51bmlmb3JtMWkoZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9hcHBseV9kaXNwbGF5X3JhbmdlXCIpLCArdGhpcy5hcHBseURpc3BsYXlSYW5nZSk7XG4gICAgZ2wudW5pZm9ybTFpKGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfY2xhbXBMb3dcIiksICt0aGlzLmNsYW1wTG93KTtcbiAgICBnbC51bmlmb3JtMWkoZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9jbGFtcEhpZ2hcIiksICt0aGlzLmNsYW1wSGlnaCk7XG4gICAgZ2wudW5pZm9ybTFmKGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfbm9EYXRhVmFsdWVcIiksIHRoaXMubm9EYXRhVmFsdWUpO1xuICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYoZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9tYXRyaXhcIiksIGZhbHNlLCB0aGlzLm1hdHJpeCk7XG4gIH1cbiAgc2V0dXBBdHRyaWJ1dGVzKHByb2dyYW0pIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgY29uc3QgcG9zaXRpb25Mb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIFwiYV9wb3NpdGlvblwiKTtcbiAgICBjb25zdCBwb3NpdGlvbkJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBwb3NpdGlvbkJ1ZmZlcik7XG4gICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25Mb2NhdGlvbik7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwb3NpdGlvbkxvY2F0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICAgIHNldFJlY3RhbmdsZShnbCwgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgfVxuICByZW5kZXIyRChkYXRhc2V0KSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgdyA9IHRoaXMuY2FudmFzLndpZHRoO1xuICAgIGNvbnN0IGggPSB0aGlzLmNhbnZhcy5oZWlnaHQ7XG4gICAgY29uc3QgaW1hZ2VEYXRhID0gY3R4LmNyZWF0ZUltYWdlRGF0YSh3LCBoKTtcbiAgICBjb25zdCB0cmFuZ2UgPSB0aGlzLmRvbWFpblsxXSAtIHRoaXMuZG9tYWluWzBdO1xuICAgIGNvbnN0IHN0ZXBzID0gdGhpcy5jb2xvclNjYWxlQ2FudmFzLndpZHRoO1xuICAgIGNvbnN0IGNzSW1hZ2VEYXRhID0gdGhpcy5jb2xvclNjYWxlQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKS5nZXRJbWFnZURhdGEoMCwgMCwgc3RlcHMsIDEpLmRhdGE7XG4gICAgbGV0IGFscGhhO1xuICAgIGNvbnN0IGRhdGEgPSBkYXRhc2V0LmRhdGE7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoOyB5KyspIHtcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdzsgeCsrKSB7XG4gICAgICAgIGNvbnN0IGkgPSB5ICogdyArIHg7XG4gICAgICAgIGxldCBjID0gTWF0aC5mbG9vcigoZGF0YVtpXSAtIHRoaXMuZG9tYWluWzBdKSAvIHRyYW5nZSAqIChzdGVwcyAtIDEpKTtcbiAgICAgICAgYWxwaGEgPSAyNTU7XG4gICAgICAgIGlmIChjIDwgMCkge1xuICAgICAgICAgIGMgPSAwO1xuICAgICAgICAgIGlmICghdGhpcy5jbGFtcExvdykge1xuICAgICAgICAgICAgYWxwaGEgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjID4gMjU1KSB7XG4gICAgICAgICAgYyA9IDI1NTtcbiAgICAgICAgICBpZiAoIXRoaXMuY2xhbXBIaWdoKSB7XG4gICAgICAgICAgICBhbHBoYSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhW2ldID09PSB0aGlzLm5vRGF0YVZhbHVlIHx8IGRhdGFbaV0gIT09IGRhdGFbaV0pIHtcbiAgICAgICAgICBhbHBoYSA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5hcHBseURpc3BsYXlSYW5nZSAmJiAoZGF0YVtpXSA8IHRoaXMuZGlzcGxheVJhbmdlWzBdIHx8IGRhdGFbaV0gPj0gdGhpcy5kaXNwbGF5UmFuZ2VbMV0pKSB7XG4gICAgICAgICAgYWxwaGEgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGV4ID0gKHkgKiB3ICsgeCkgKiA0O1xuICAgICAgICBpbWFnZURhdGEuZGF0YVtpbmRleCArIDBdID0gY3NJbWFnZURhdGFbYyAqIDRdO1xuICAgICAgICBpbWFnZURhdGEuZGF0YVtpbmRleCArIDFdID0gY3NJbWFnZURhdGFbYyAqIDQgKyAxXTtcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAyXSA9IGNzSW1hZ2VEYXRhW2MgKiA0ICsgMl07XG4gICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgM10gPSBNYXRoLm1pbihhbHBoYSwgY3NJbWFnZURhdGFbYyAqIDQgKyAzXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGN0eC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbiAgfVxuICAvKipcbiAgICogUmVuZGVyIHRoZSBzcGVjaWZpZWQgZGF0YXNldCB3aXRoIHRoZSBjdXJyZW50IHNldHRpbmdzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgdGhlIGlkZW50aWZpZXIgb2YgdGhlIGRhdGFzZXQgdG8gcmVuZGVyLlxuICAgKi9cbiAgcmVuZGVyRGF0YXNldChpZCkge1xuICAgIHRoaXMuc2V0Q3VycmVudERhdGFzZXQoaWQpO1xuICAgIHJldHVybiB0aGlzLnJlbmRlcigpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvbG9yIGZvciB0aGUgc3BlY2lmaWVkIHZhbHVlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIHRoZSB2YWx1ZSB0byBxdWVyeSB0aGUgY29sb3IgZm9yLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IHRoZSA0LXR1cGxlOiByZWQsIGdyZWVuLCBibHVlLCBhbHBoYSBpbiB0aGUgcmFuZ2UgMC0yNTUuXG4gICAqL1xuICBnZXRDb2xvcih2YWwpIHtcbiAgICBjb25zdCBzdGVwcyA9IHRoaXMuY29sb3JTY2FsZUNhbnZhcy53aWR0aDtcbiAgICBjb25zdCBjc0ltYWdlRGF0YSA9IHRoaXMuY29sb3JTY2FsZUNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikuZ2V0SW1hZ2VEYXRhKDAsIDAsIHN0ZXBzLCAxKS5kYXRhO1xuICAgIGNvbnN0IHRyYW5nZSA9IHRoaXMuZG9tYWluWzFdIC0gdGhpcy5kb21haW5bMF07XG4gICAgbGV0IGMgPSBNYXRoLnJvdW5kKCh2YWwgLSB0aGlzLmRvbWFpblswXSkgLyB0cmFuZ2UgKiBzdGVwcyk7XG4gICAgbGV0IGFscGhhID0gMjU1O1xuICAgIGlmIChjIDwgMCkge1xuICAgICAgYyA9IDA7XG4gICAgICBpZiAoIXRoaXMuY2xhbXBMb3cpIHtcbiAgICAgICAgYWxwaGEgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYyA+IDI1NSkge1xuICAgICAgYyA9IDI1NTtcbiAgICAgIGlmICghdGhpcy5jbGFtcEhpZ2gpIHtcbiAgICAgICAgYWxwaGEgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgY3NJbWFnZURhdGFbYyAqIDRdLFxuICAgICAgY3NJbWFnZURhdGFbYyAqIDQgKyAxXSxcbiAgICAgIGNzSW1hZ2VEYXRhW2MgKiA0ICsgMl0sXG4gICAgICBhbHBoYVxuICAgIF07XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgYSBtYXRoZW1hdGljYWwgZXhwcmVzc2lvbiB0byBiZSBldmFsdWF0ZWQgb24gdGhlIHBsb3QuIEV4cHJlc3Npb24gY2FuIGNvbnRhaW4gbWF0aGVtYXRpY2FsIG9wZXJhdGlvbnMgd2l0aCBpbnRlZ2VyL2Zsb2F0IHZhbHVlcywgZGF0YXNldCBpZGVudGlmaWVycyBvciBHTFNMIHN1cHBvcnRlZCBmdW5jdGlvbnMgd2l0aCBhIHNpbmdsZSBwYXJhbWV0ZXIuXG4gICAqIFN1cHBvcnRlZCBtYXRoZW1hdGljYWwgb3BlcmF0aW9ucyBhcmU6IGFkZCAnKycsIHN1YnRyYWN0ICctJywgbXVsdGlwbHkgJyonLCBkaXZpZGUgJy8nLCBwb3dlciAnKionLCB1bmFyeSBwbHVzICcrYScsIHVuYXJ5IG1pbnVzICctYScuXG4gICAqIFVzZWZ1bCBHTFNMIGZ1bmN0aW9ucyBhcmUgZm9yIGV4YW1wbGU6IHJhZGlhbnMsIGRlZ3JlZXMsIHNpbiwgYXNpbiwgY29zLCBhY29zLCB0YW4sIGF0YW4sIGxvZzIsIGxvZywgc3FydCwgZXhwMiwgZXhwLCBhYnMsIHNpZ24sIGZsb29yLCBjZWlsLCBmcmFjdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV4cHJlc3Npb24gTWF0aGVtYXRpY2FsIGV4cHJlc3Npb24uIEV4YW1wbGU6ICctMiAqIHNpbigzLjE0MTUgLSBkYXRhc2V0MSkgKiogMidcbiAgICovXG4gIHNldEV4cHJlc3Npb24oZXhwcmVzc2lvbikge1xuICAgIGlmICghZXhwcmVzc2lvbiB8fCAhZXhwcmVzc2lvbi5sZW5ndGgpIHtcbiAgICAgIHRoaXMuZXhwcmVzc2lvbkFzdCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXhwcmVzc2lvbkFzdCA9IHBlZyRwYXJzZShleHByZXNzaW9uKTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB2YXIgX2E7XG4gICAgKF9hID0gdGhpcy5nbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmRlbGV0ZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcbiAgICB0aGlzLnJlbW92ZUFsbERhdGFzZXQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRNaW5NYXgoZGF0YSwgbm9kYXRhKSB7XG4gIGxldCBtaW4sIG1heDtcbiAgZm9yIChsZXQgaiA9IDA7IGogPCBkYXRhLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgY29uc3QgdmFsID0gZGF0YVtqXTtcbiAgICBpZiAodmFsID09PSBub2RhdGEpXG4gICAgICBjb250aW51ZTtcbiAgICBpZiAobWluID09PSB2b2lkIDAgJiYgbWF4ID09PSB2b2lkIDApIHtcbiAgICAgIG1pbiA9IG1heCA9IHZhbDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAodmFsIDwgbWluKSB7XG4gICAgICBtaW4gPSB2YWw7XG4gICAgfSBlbHNlIGlmICh2YWwgPiBtYXgpIHtcbiAgICAgIG1heCA9IHZhbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBtaW4sXG4gICAgbWF4XG4gIH07XG59XG5mdW5jdGlvbiBkZWNpbWFsMnJnYihudW1iZXIpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQobnVtYmVyICogMjU1KTtcbn1cbmZ1bmN0aW9uIGdldFJhbmdlKGJhbmRzLCBvcHRzKSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IGJhbmQgPSBiYW5kc1tvcHRzLmJhbmRdO1xuICBpZiAoIWJhbmQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYmFuZCR7b3B0cy5iYW5kfWApO1xuICB9XG4gIGNvbnN0IG1pbiA9IChfYSA9IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMubWluKSAhPSBudWxsID8gX2EgOiArYmFuZC5taW47XG4gIGNvbnN0IG1heCA9IChfYiA9IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMubWF4KSAhPSBudWxsID8gX2IgOiArYmFuZC5tYXg7XG4gIGNvbnN0IHJhbmdlID0gbWF4IC0gbWluO1xuICByZXR1cm4geyBtaW4sIG1heCwgcmFuZ2UgfTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlQ29sb3JTY2FsZShjb2xvcnMsIG1pbk1heCkge1xuICBsZXQgc3RvcHM7XG4gIGlmICh0eXBlb2YgY29sb3JzWzBdID09PSBcInN0cmluZ1wiKSB7XG4gICAgc3RvcHMgPSBjb2xvcnMubWFwKChjb2xvciwgaW5kZXgpID0+IFtpbmRleCAvIGNvbG9ycy5sZW5ndGgsIGNvbG9yXSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgW21pbiwgbWF4XSA9IG1pbk1heDtcbiAgICBzdG9wcyA9IGNvbG9ycy5tYXAoKGl0ZW0pID0+IFsoaXRlbVswXSAtIG1pbikgLyAobWF4IC0gbWluKSwgaXRlbVsxXV0pO1xuICB9XG4gIHN0b3BzLnNvcnQoKGEsIGIpID0+IGFbMF0gLSBiWzBdKTtcbiAgbGV0IGkgPSBzdG9wcy5sZW5ndGggLSAxO1xuICB3aGlsZSAoaSA+IDEgJiYgc3RvcHNbaV1bMF0gPj0gMSAmJiBzdG9wc1tpIC0gMV1bMF0gPj0gMSkge1xuICAgIHN0b3BzLnBvcCgpO1xuICAgIGktLTtcbiAgfVxuICBpZiAoc3RvcHNbMF1bMF0gPiAwKSB7XG4gICAgc3RvcHMgPSBbWzAsIHN0b3BzWzBdWzFdXSwgLi4uc3RvcHNdO1xuICB9XG4gIGNvbnN0IGNvbG9yU2NhbGUgPSB7XG4gICAgY29sb3JzOiBzdG9wcy5tYXAoKHN0b3ApID0+IHN0b3BbMV0pLFxuICAgIHBvc2l0aW9uczogc3RvcHMubWFwKChzdG9wKSA9PiB7XG4gICAgICBsZXQgcyA9IHN0b3BbMF07XG4gICAgICBpZiAocyA8IDApXG4gICAgICAgIHJldHVybiAwO1xuICAgICAgaWYgKHMgPiAxKVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIHJldHVybiBzO1xuICAgIH0pXG4gIH07XG4gIHJldHVybiBjb2xvclNjYWxlO1xufVxuZnVuY3Rpb24gZmluZEFuZFNvcnRCYW5kTnVtYmVycyhzdHIpIHtcbiAgY29uc3QgcmVnZXggPSAvYihcXGQrKS9nO1xuICBjb25zdCBiYW5kTnVtYmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGxldCBtYXRjaDtcbiAgd2hpbGUgKChtYXRjaCA9IHJlZ2V4LmV4ZWMoc3RyKSkgIT09IG51bGwpIHtcbiAgICBiYW5kTnVtYmVycy5hZGQocGFyc2VJbnQobWF0Y2hbMV0pIC0gMSk7XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20oYmFuZE51bWJlcnMpLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ0NvbG9yVG9SZ2JhKGNvbG9yKSB7XG4gIGNvbnN0IG5ld0NvbG9yID0gQ29sb3IuZnJvbUNzc0NvbG9yU3RyaW5nKGNvbG9yKTtcbiAgY29uc3QgeyByZWQsIGdyZWVuLCBibHVlLCBhbHBoYSB9ID0gbmV3Q29sb3I7XG4gIHJldHVybiBbcmVkLCBncmVlbiwgYmx1ZSwgYWxwaGFdLm1hcCgodmFsKSA9PiBNYXRoLnJvdW5kKHZhbCAqIDI1NSkpO1xufVxuZnVuY3Rpb24gcmV2ZXJzZUFycmF5KG9wdGlvbnMpIHtcbiAgY29uc3QgeyBhcnJheSwgd2lkdGgsIGhlaWdodCB9ID0gb3B0aW9ucztcbiAgY29uc3QgcmV2ZXJzZWRBcnJheSA9IFtdO1xuICBmb3IgKGxldCByb3cgPSBoZWlnaHQgLSAxOyByb3cgPj0gMDsgcm93LS0pIHtcbiAgICBjb25zdCBzdGFydEluZGV4ID0gcm93ICogd2lkdGg7XG4gICAgY29uc3QgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgd2lkdGg7XG4gICAgY29uc3Qgcm93QXJyYXkgPSBhcnJheS5zbGljZShzdGFydEluZGV4LCBlbmRJbmRleCk7XG4gICAgcmV2ZXJzZWRBcnJheS5wdXNoKC4uLnJvd0FycmF5KTtcbiAgfVxuICByZXR1cm4gcmV2ZXJzZWRBcnJheTtcbn1cblxudmFyIF9fZGVmUHJvcCQyID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCQyID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcCQyKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkJDIgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcCQyKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNsYXNzIFRJRkZJbWFnZXJ5UHJvdmlkZXJUaWxpbmdTY2hlbWUgZXh0ZW5kcyBXZWJNZXJjYXRvclRpbGluZ1NjaGVtZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihvcHRpb25zKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDIodGhpcywgXCJuYXRpdmVSZWN0YW5nbGVcIik7XG4gICAgY29uc3QgeyBwcm9qZWN0LCB1bnByb2plY3QgfSA9IG9wdGlvbnM7XG4gICAgdGhpcy5uYXRpdmVSZWN0YW5nbGUgPSBuZXcgUmVjdGFuZ2xlKG9wdGlvbnMucmVjdGFuZ2xlU291dGh3ZXN0SW5NZXRlcnMueCwgb3B0aW9ucy5yZWN0YW5nbGVTb3V0aHdlc3RJbk1ldGVycy55LCBvcHRpb25zLnJlY3RhbmdsZU5vcnRoZWFzdEluTWV0ZXJzLngsIG9wdGlvbnMucmVjdGFuZ2xlTm9ydGhlYXN0SW5NZXRlcnMueSk7XG4gICAgdGhpcy5fcHJvamVjdGlvbiA9IHtcbiAgICAgIGVsbGlwc29pZDogdGhpcy5lbGxpcHNvaWQsXG4gICAgICBwcm9qZWN0KGNhcnRvZ3JhcGhpYywgcmVzdWx0KSB7XG4gICAgICAgIGNvbnN0IFt4LCB5XSA9IHByb2plY3QoW2NhcnRvZ3JhcGhpYy5sb25naXR1ZGUsIGNhcnRvZ3JhcGhpYy5sYXRpdHVkZV0ubWFwKENlc2l1bU1hdGgudG9EZWdyZWVzKSk7XG4gICAgICAgIGNvbnN0IHogPSBjYXJ0b2dyYXBoaWMuaGVpZ2h0O1xuICAgICAgICByZXR1cm4gQ2FydGVzaWFuMy5mcm9tRWxlbWVudHMoeCwgeSwgeiwgcmVzdWx0KTtcbiAgICAgIH0sXG4gICAgICB1bnByb2plY3QoY2FydGVzaWFuLCByZXN1bHQpIHtcbiAgICAgICAgY29uc3QgW2xvbmdpdHVkZSwgbGF0aXR1ZGVdID0gdW5wcm9qZWN0KFtjYXJ0ZXNpYW4ueCwgY2FydGVzaWFuLnldKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gY2FydGVzaWFuLno7XG4gICAgICAgIHJldHVybiBDYXJ0b2dyYXBoaWMuZnJvbURlZ3JlZXMobG9uZ2l0dWRlLCBsYXRpdHVkZSwgaGVpZ2h0LCByZXN1bHQpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc3dNZXRlcnMgPSBuZXcgQ2FydGVzaWFuMygpO1xuICAgIG9wdGlvbnMucmVjdGFuZ2xlU291dGh3ZXN0SW5NZXRlcnMuY2xvbmUoc3dNZXRlcnMpO1xuICAgIGNvbnN0IG5lTWV0ZXJzID0gbmV3IENhcnRlc2lhbjMoKTtcbiAgICBvcHRpb25zLnJlY3RhbmdsZU5vcnRoZWFzdEluTWV0ZXJzLmNsb25lKG5lTWV0ZXJzKTtcbiAgICBjb25zdCBzZU1ldGVycyA9IG5ldyBDYXJ0ZXNpYW4zKG5lTWV0ZXJzLngsIHN3TWV0ZXJzLnkpO1xuICAgIGNvbnN0IG53TWV0ZXJzID0gbmV3IENhcnRlc2lhbjMoc3dNZXRlcnMueCwgbmVNZXRlcnMueSk7XG4gICAgY29uc3Qgc291dGh3ZXN0ID0gdGhpcy5wcm9qZWN0aW9uLnVucHJvamVjdChzd01ldGVycyk7XG4gICAgY29uc3Qgc291dGhlYXN0ID0gdGhpcy5wcm9qZWN0aW9uLnVucHJvamVjdChzZU1ldGVycyk7XG4gICAgY29uc3Qgbm9ydGh3ZXN0ID0gdGhpcy5wcm9qZWN0aW9uLnVucHJvamVjdChud01ldGVycyk7XG4gICAgY29uc3Qgbm9ydGhlYXN0ID0gdGhpcy5wcm9qZWN0aW9uLnVucHJvamVjdChuZU1ldGVycyk7XG4gICAgdGhpcy5fcmVjdGFuZ2xlID0gUmVjdGFuZ2xlLmZyb21DYXJ0b2dyYXBoaWNBcnJheShbc291dGh3ZXN0LCBzb3V0aGVhc3QsIG5vcnRod2VzdCwgbm9ydGhlYXN0XSk7XG4gIH1cbiAgdGlsZVhZVG9OYXRpdmVSZWN0YW5nbGUyKHgsIHksIGxldmVsKSB7XG4gICAgY29uc3QgcmVjdCA9IHRoaXMudGlsZVhZVG9SZWN0YW5nbGUoeCwgeSwgbGV2ZWwpO1xuICAgIGNvbnN0IHByb2plY3Rpb24gPSB0aGlzLnByb2plY3Rpb247XG4gICAgY29uc3Qgd3MgPSBwcm9qZWN0aW9uLnByb2plY3QobmV3IENhcnRvZ3JhcGhpYyhyZWN0Lndlc3QsIHJlY3Quc291dGgpKTtcbiAgICBjb25zdCB3biA9IHByb2plY3Rpb24ucHJvamVjdChuZXcgQ2FydG9ncmFwaGljKHJlY3Qud2VzdCwgcmVjdC5ub3J0aCkpO1xuICAgIGNvbnN0IGVuID0gcHJvamVjdGlvbi5wcm9qZWN0KG5ldyBDYXJ0b2dyYXBoaWMocmVjdC5lYXN0LCByZWN0Lm5vcnRoKSk7XG4gICAgY29uc3QgZXMgPSBwcm9qZWN0aW9uLnByb2plY3QobmV3IENhcnRvZ3JhcGhpYyhyZWN0LmVhc3QsIHJlY3Quc291dGgpKTtcbiAgICBjb25zdCBwb3NpdGlvbnMgPSBbd3MsIHduLCBlbiwgZXNdO1xuICAgIGNvbnN0IHh4ID0gcG9zaXRpb25zLm1hcCgocG9zKSA9PiBwb3MueCk7XG4gICAgY29uc3QgeXkgPSBwb3NpdGlvbnMubWFwKChwb3MpID0+IHBvcy55KTtcbiAgICByZXR1cm4gbmV3IFJlY3RhbmdsZShcbiAgICAgIE1hdGgubWluKC4uLnh4KSxcbiAgICAgIE1hdGgubWluKC4uLnl5KSxcbiAgICAgIE1hdGgubWF4KC4uLnh4KSxcbiAgICAgIE1hdGgubWF4KC4uLnl5KVxuICAgICk7XG4gIH1cbiAgdGlsZVhZVG9SZWN0YW5nbGUoeCwgeSwgbGV2ZWwpIHtcbiAgICBjb25zdCByZWN0ID0gdGhpcy50aWxlWFlUb05hdGl2ZVJlY3RhbmdsZSh4LCB5LCBsZXZlbCk7XG4gICAgY29uc3QgcHJvamVjdGlvbiA9IHRoaXMucHJvamVjdGlvbjtcbiAgICBjb25zdCB3cyA9IHByb2plY3Rpb24udW5wcm9qZWN0KG5ldyBDYXJ0ZXNpYW4zKHJlY3Qud2VzdCwgcmVjdC5zb3V0aCkpO1xuICAgIGNvbnN0IHduID0gcHJvamVjdGlvbi51bnByb2plY3QobmV3IENhcnRlc2lhbjMocmVjdC53ZXN0LCByZWN0Lm5vcnRoKSk7XG4gICAgY29uc3QgZW4gPSBwcm9qZWN0aW9uLnVucHJvamVjdChuZXcgQ2FydGVzaWFuMyhyZWN0LmVhc3QsIHJlY3Qubm9ydGgpKTtcbiAgICBjb25zdCBlcyA9IHByb2plY3Rpb24udW5wcm9qZWN0KG5ldyBDYXJ0ZXNpYW4zKHJlY3QuZWFzdCwgcmVjdC5zb3V0aCkpO1xuICAgIGNvbnN0IG5ld1JlY3QgPSBSZWN0YW5nbGUuZnJvbUNhcnRvZ3JhcGhpY0FycmF5KFt3cywgd24sIGVuLCBlc10pO1xuICAgIGlmIChuZXdSZWN0LmVhc3QgPCBuZXdSZWN0Lndlc3QpIHtcbiAgICAgIG5ld1JlY3QuZWFzdCArPSBDZXNpdW1NYXRoLlRXT19QSTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1JlY3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzYW1wbGVOZWFyZXN0KGRhdGEsIG9wdGlvbnMpIHtcbiAgY29uc3QgeyBzb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0LCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0LCB3aW5kb3csIGJ1ZmZlciA9IDAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IFt4MCwgeTAsIHgxLCB5MV0gPSB3aW5kb3c7XG4gIGNvbnN0IGVmZmVjdGl2ZVNvdXJjZVdpZHRoID0gc291cmNlV2lkdGggLSAyICogYnVmZmVyO1xuICBjb25zdCBlZmZlY3RpdmVTb3VyY2VIZWlnaHQgPSBzb3VyY2VIZWlnaHQgLSAyICogYnVmZmVyO1xuICBjb25zdCByZXNhbXBsZWREYXRhID0gY29weU5ld1NpemUoZGF0YSwgdGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCk7XG4gIGZvciAobGV0IHkgPSAwOyB5IDwgdGFyZ2V0SGVpZ2h0OyB5KyspIHtcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRhcmdldFdpZHRoOyB4KyspIHtcbiAgICAgIGNvbnN0IGNvbCA9IGJ1ZmZlciArIChlZmZlY3RpdmVTb3VyY2VXaWR0aCAqICh4MCArIHggLyB0YXJnZXRXaWR0aCAqICh4MSAtIHgwKSkgPj4+IDApO1xuICAgICAgY29uc3Qgcm93ID0gYnVmZmVyICsgKGVmZmVjdGl2ZVNvdXJjZUhlaWdodCAqICh5MCArIHkgLyB0YXJnZXRIZWlnaHQgKiAoeTEgLSB5MCkpID4+PiAwKTtcbiAgICAgIHJlc2FtcGxlZERhdGFbeSAqIHRhcmdldFdpZHRoICsgeF0gPSBkYXRhW3JvdyAqIHNvdXJjZVdpZHRoICsgY29sXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc2FtcGxlZERhdGE7XG59XG5mdW5jdGlvbiByZXNhbXBsZURhdGEoZGF0YSwgb3B0aW9ucykge1xuICBjb25zdCB7IG1ldGhvZCA9IFwibmVhcmVzdFwiIH0gPSBvcHRpb25zO1xuICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgIGNhc2UgXCJuZWFyZXN0XCI6XG4gICAgICByZXR1cm4gcmVzYW1wbGVOZWFyZXN0KGRhdGEsIG9wdGlvbnMpO1xuICAgIGNhc2UgXCJiaWxpbmVhclwiOlxuICAgICAgcmV0dXJuIHJlc2FtcGxlQmlsaW5lYXIoZGF0YSwgb3B0aW9ucyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvcHlOZXdTaXplKGFycmF5LCB3aWR0aCwgaGVpZ2h0LCBzYW1wbGVzUGVyUGl4ZWwgPSAxKSB7XG4gIHJldHVybiBuZXcgKE9iamVjdC5nZXRQcm90b3R5cGVPZihhcnJheSkpLmNvbnN0cnVjdG9yKHdpZHRoICogaGVpZ2h0ICogc2FtcGxlc1BlclBpeGVsKTtcbn1cbmZ1bmN0aW9uIGxlcnAodjAsIHYxLCB0KSB7XG4gIHJldHVybiAoMSAtIHQpICogdjAgKyB0ICogdjE7XG59XG5mdW5jdGlvbiByZXNhbXBsZUJpbGluZWFyKGRhdGEsIG9wdGlvbnMpIHtcbiAgY29uc3QgeyBzb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0LCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0LCB3aW5kb3csIGJ1ZmZlciA9IDAsIG5vZGF0YSB9ID0gb3B0aW9ucztcbiAgY29uc3QgW3gwLCB5MCwgeDEsIHkxXSA9IHdpbmRvdztcbiAgY29uc3Qgd2luZG93V2lkdGggPSB4MSAtIHgwO1xuICBjb25zdCB3aW5kb3dIZWlnaHQgPSB5MSAtIHkwO1xuICBjb25zdCBuZXdBcnJheSA9IGNvcHlOZXdTaXplKGRhdGEsIHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQpO1xuICBjb25zdCBlZmZlY3RpdmVTb3VyY2VXaWR0aCA9IHNvdXJjZVdpZHRoIC0gMiAqIGJ1ZmZlcjtcbiAgY29uc3QgZWZmZWN0aXZlU291cmNlSGVpZ2h0ID0gc291cmNlSGVpZ2h0IC0gMiAqIGJ1ZmZlcjtcbiAgY29uc3QgaW52VGFyZ2V0V2lkdGggPSAxIC8gdGFyZ2V0V2lkdGg7XG4gIGNvbnN0IGludlRhcmdldEhlaWdodCA9IDEgLyB0YXJnZXRIZWlnaHQ7XG4gIGNvbnN0IGlzTm9kYXRhID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKG5vZGF0YSA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChub2RhdGEgPT09IDApXG4gICAgICByZXR1cm4gdmFsdWUgPT09IDA7XG4gICAgcmV0dXJuIE1hdGguYWJzKCh2YWx1ZSAtIG5vZGF0YSkgLyBub2RhdGEpIDwgMWUtNjtcbiAgfTtcbiAgZm9yIChsZXQgeSA9IDA7IHkgPCB0YXJnZXRIZWlnaHQ7IHkrKykge1xuICAgIGNvbnN0IHlSYXRpbyA9IHkgKiBpbnZUYXJnZXRIZWlnaHQ7XG4gICAgY29uc3QgeU1hcHBlZCA9IHkwICsgeVJhdGlvICogd2luZG93SGVpZ2h0O1xuICAgIGNvbnN0IHJhd1kgPSBlZmZlY3RpdmVTb3VyY2VIZWlnaHQgKiB5TWFwcGVkICsgYnVmZmVyO1xuICAgIGNvbnN0IHlsID0gTWF0aC5mbG9vcihyYXdZKTtcbiAgICBjb25zdCB5aCA9IE1hdGgubWluKE1hdGguY2VpbChyYXdZKSwgc291cmNlSGVpZ2h0IC0gYnVmZmVyIC0gMSk7XG4gICAgY29uc3QgdHkgPSByYXdZIC0geWw7XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCB0YXJnZXRXaWR0aDsgeCsrKSB7XG4gICAgICBjb25zdCB4UmF0aW8gPSB4ICogaW52VGFyZ2V0V2lkdGg7XG4gICAgICBjb25zdCB4TWFwcGVkID0geDAgKyB4UmF0aW8gKiB3aW5kb3dXaWR0aDtcbiAgICAgIGNvbnN0IHJhd1ggPSBlZmZlY3RpdmVTb3VyY2VXaWR0aCAqIHhNYXBwZWQgKyBidWZmZXI7XG4gICAgICBjb25zdCB4bCA9IE1hdGguZmxvb3IocmF3WCk7XG4gICAgICBjb25zdCB4aCA9IE1hdGgubWluKE1hdGguY2VpbChyYXdYKSwgc291cmNlV2lkdGggLSBidWZmZXIgLSAxKTtcbiAgICAgIGNvbnN0IHR4RnJhY3Rpb24gPSByYXdYIC0geGw7XG4gICAgICBjb25zdCBjZW50ZXIgPSBkYXRhW3lsICogc291cmNlV2lkdGggKyB4bF07XG4gICAgICBjb25zdCBuZWlnaGJvcnMgPSBbXG4gICAgICAgIGRhdGFbeWwgKiBzb3VyY2VXaWR0aCArIHhsXSxcbiAgICAgICAgZGF0YVt5bCAqIHNvdXJjZVdpZHRoICsgeGhdLFxuICAgICAgICBkYXRhW3loICogc291cmNlV2lkdGggKyB4bF0sXG4gICAgICAgIGRhdGFbeWggKiBzb3VyY2VXaWR0aCArIHhoXVxuICAgICAgXTtcbiAgICAgIG5laWdoYm9ycy5mb3JFYWNoKChuZWlnaGJvciwgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKGlzTm9kYXRhKG5laWdoYm9yKSkge1xuICAgICAgICAgIG5laWdoYm9yc1tpbmRleF0gPSBjZW50ZXI7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKGlzTm9kYXRhKGNlbnRlcikpIHtcbiAgICAgICAgbmV3QXJyYXlbeSAqIHRhcmdldFdpZHRoICsgeF0gPSBub2RhdGE7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgW2xsLCBobCwgbGgsIGhoXSA9IG5laWdoYm9ycztcbiAgICAgIGNvbnN0IHYwID0gbGVycChsbCwgaGwsIHR4RnJhY3Rpb24pO1xuICAgICAgY29uc3QgdjEgPSBsZXJwKGxoLCBoaCwgdHhGcmFjdGlvbik7XG4gICAgICBjb25zdCB2YWx1ZSA9IGxlcnAodjAsIHYxLCB0eSk7XG4gICAgICBuZXdBcnJheVt5ICogdGFyZ2V0V2lkdGggKyB4XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3QXJyYXk7XG59XG5cbmZ1bmN0aW9uIGluUmFuZ2UodmFsLCByYW5nZSkge1xuICBpZiAodmFsIDwgcmFuZ2VbMF0gJiYgdmFsIDwgcmFuZ2VbMV0gfHwgdmFsID4gcmFuZ2VbMF0gJiYgdmFsID4gcmFuZ2VbMV0pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlcHJvamVjdGlvbihvcHRpb25zKSB7XG4gIGNvbnN0IHsgZGF0YSwgc291cmNlQkJveCwgdGFyZ2V0QkJveCwgcHJvamVjdCwgc291cmNlV2lkdGgsIHNvdXJjZUhlaWdodCwgbm9kYXRhIH0gPSBvcHRpb25zO1xuICBjb25zdCB7IHRhcmdldFdpZHRoID0gc291cmNlV2lkdGgsIHRhcmdldEhlaWdodCA9IHNvdXJjZUhlaWdodCB9ID0gb3B0aW9ucztcbiAgY29uc3QgW21pblgsIG1pblksIG1heFgsIG1heFldID0gc291cmNlQkJveDtcbiAgY29uc3QgW21pbkxvbiwgbWluTGF0LCBtYXhMb24sIG1heExhdF0gPSB0YXJnZXRCQm94O1xuICBjb25zdCBzdGVwWCA9IE1hdGguYWJzKG1heFggLSBtaW5YKSAvIHNvdXJjZVdpZHRoO1xuICBjb25zdCBzdGVwWSA9IE1hdGguYWJzKG1heFkgLSBtaW5ZKSAvIHNvdXJjZUhlaWdodDtcbiAgY29uc3Qgc3RlcExvbiA9IE1hdGguYWJzKG1heExvbiAtIG1pbkxvbikgLyB0YXJnZXRXaWR0aDtcbiAgY29uc3Qgc3RlcExhdCA9IE1hdGguYWJzKG1heExhdCAtIG1pbkxhdCkgLyB0YXJnZXRIZWlnaHQ7XG4gIGNvbnN0IHJlc3VsdCA9IGNvcHlOZXdTaXplKGRhdGEsIHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQpLmZpbGwobm9kYXRhKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YXJnZXRIZWlnaHQ7IGkrKykge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGFyZ2V0V2lkdGg7IGorKykge1xuICAgICAgY29uc3QgbG9uID0gbWluTG9uICsgc3RlcExvbiAqIChqICsgMC41KTtcbiAgICAgIGNvbnN0IGxhdCA9IG1heExhdCAtIHN0ZXBMYXQgKiAoaSArIDAuNSk7XG4gICAgICBjb25zdCBbeCwgeV0gPSBwcm9qZWN0KFtsb24sIGxhdF0pO1xuICAgICAgaWYgKCFpblJhbmdlKHgsIFttaW5YLCBtYXhYXSkgfHwgIWluUmFuZ2UoeSwgW21pblgsIG1heFldKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGluZGV4WCA9IH5+KCh4IC0gbWluWCkgLyBzdGVwWCk7XG4gICAgICBjb25zdCBpbmRleFkgPSB+figobWF4WSAtIHkpIC8gc3RlcFkpO1xuICAgICAgY29uc3Qgc291cmNlVmFsID0gZGF0YVtpbmRleFkgKiBzb3VyY2VXaWR0aCArIGluZGV4WF07XG4gICAgICBjb25zdCBpbmRleCA9IGkgKiB0YXJnZXRXaWR0aCArIGo7XG4gICAgICByZXN1bHRbaW5kZXhdID0gc291cmNlVmFsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX19hc3luYyQyID0gKF9fdGhpcywgX19hcmd1bWVudHMsIGdlbmVyYXRvcikgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHZhciBmdWxmaWxsZWQgPSAodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHJlamVjdGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci50aHJvdyh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgc3RlcCA9ICh4KSA9PiB4LmRvbmUgPyByZXNvbHZlKHgudmFsdWUpIDogUHJvbWlzZS5yZXNvbHZlKHgudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG4gICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KF9fdGhpcywgX19hcmd1bWVudHMpKS5uZXh0KCkpO1xuICB9KTtcbn07XG5mdW5jdGlvbiBnZW5lcmF0ZUltYWdlKG9wdHMpIHtcbiAgcmV0dXJuIF9fYXN5bmMkMih0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IHsgZGF0YSwgd2lkdGgsIGhlaWdodCwgcmVuZGVyT3B0aW9ucywgYmFuZHMsIG5vRGF0YSwgY29sb3JNYXBwaW5nIH0gPSBvcHRzO1xuICAgIGNvbnN0IGltYWdlRGF0YSA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgIGZ1bmN0aW9uIGlmTm9EYXRhRnVuYyguLi52YWxzKSB7XG4gICAgICBpZiAodmFscy5zb21lKCh2YWwpID0+IGlzTmFOKHZhbCkgfHwgdmFsID09PSBub0RhdGEpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgeyByLCBnLCBiIH0gPSByZW5kZXJPcHRpb25zICE9IG51bGwgPyByZW5kZXJPcHRpb25zIDoge307XG4gICAgY29uc3QgcmFuZ2VzID0gW3IsIGcsIGJdLm1hcCgoaXRlbSkgPT4gZ2V0UmFuZ2UoYmFuZHMsIGl0ZW0pKTtcbiAgICBjb25zdCByZWREYXRhID0gZGF0YVswXTtcbiAgICBjb25zdCBncmVlbkRhdGEgPSBkYXRhWzFdO1xuICAgIGNvbnN0IGJsdWVEYXRhID0gZGF0YVsyXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFbMF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCByZWQgPSBkZWNpbWFsMnJnYigocmVkRGF0YVtpXSAtIHJhbmdlc1swXS5taW4pIC8gcmFuZ2VzWzBdLnJhbmdlKTtcbiAgICAgIGxldCBncmVlbiA9IGRlY2ltYWwycmdiKChncmVlbkRhdGFbaV0gLSByYW5nZXNbMV0ubWluKSAvIHJhbmdlc1sxXS5yYW5nZSk7XG4gICAgICBsZXQgYmx1ZSA9IGRlY2ltYWwycmdiKChibHVlRGF0YVtpXSAtIHJhbmdlc1syXS5taW4pIC8gcmFuZ2VzWzJdLnJhbmdlKTtcbiAgICAgIGxldCBhbHBoYSA9IGlmTm9EYXRhRnVuYyhyZWREYXRhW2ldLCBncmVlbkRhdGFbaV0sIGJsdWVEYXRhW2ldKSA/IDAgOiAyNTU7XG4gICAgICBjb2xvck1hcHBpbmcubWFwKChbY29sb3JGcm9tLCBjb2xvclRvXSkgPT4ge1xuICAgICAgICBpZiAocmVkID09PSBjb2xvckZyb21bMF0gJiYgZ3JlZW4gPT09IGNvbG9yRnJvbVsxXSAmJiBibHVlID09PSBjb2xvckZyb21bMl0pIHtcbiAgICAgICAgICByZWQgPSBjb2xvclRvWzBdO1xuICAgICAgICAgIGdyZWVuID0gY29sb3JUb1sxXTtcbiAgICAgICAgICBibHVlID0gY29sb3JUb1syXTtcbiAgICAgICAgICBhbHBoYSA9IGNvbG9yVG9bM107XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaW1hZ2VEYXRhW2kgKiA0XSA9IHJlZDtcbiAgICAgIGltYWdlRGF0YVtpICogNCArIDFdID0gZ3JlZW47XG4gICAgICBpbWFnZURhdGFbaSAqIDQgKyAyXSA9IGJsdWU7XG4gICAgICBpbWFnZURhdGFbaSAqIDQgKyAzXSA9IGFscGhhO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBuZXcgSW1hZ2VEYXRhKGltYWdlRGF0YSwgd2lkdGgsIGhlaWdodCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNhbmF2YXMod2lkdGgsIGhlaWdodCkge1xuICBpZiAoXCJPZmZzY3JlZW5DYW52YXNcIiBpbiB3aW5kb3cpIHtcbiAgICByZXR1cm4gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjYW52ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBjYW52LndpZHRoID0gd2lkdGg7XG4gICAgY2Fudi5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgcmV0dXJuIGNhbnY7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVjb2RlQmFzZTY0KGJhc2U2NCwgZW5hYmxlVW5pY29kZSkge1xuICAgIHZhciBiaW5hcnlTdHJpbmcgPSBhdG9iKGJhc2U2NCk7XG4gICAgaWYgKGVuYWJsZVVuaWNvZGUpIHtcbiAgICAgICAgdmFyIGJpbmFyeVZpZXcgPSBuZXcgVWludDhBcnJheShiaW5hcnlTdHJpbmcubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBiaW5hcnlTdHJpbmcubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBiaW5hcnlWaWV3W2ldID0gYmluYXJ5U3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQxNkFycmF5KGJpbmFyeVZpZXcuYnVmZmVyKSk7XG4gICAgfVxuICAgIHJldHVybiBiaW5hcnlTdHJpbmc7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVVSTChiYXNlNjQsIHNvdXJjZW1hcEFyZywgZW5hYmxlVW5pY29kZUFyZykge1xuICAgIHZhciBzb3VyY2VtYXAgPSBzb3VyY2VtYXBBcmcgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBzb3VyY2VtYXBBcmc7XG4gICAgdmFyIGVuYWJsZVVuaWNvZGUgPSBlbmFibGVVbmljb2RlQXJnID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGVuYWJsZVVuaWNvZGVBcmc7XG4gICAgdmFyIHNvdXJjZSA9IGRlY29kZUJhc2U2NChiYXNlNjQsIGVuYWJsZVVuaWNvZGUpO1xuICAgIHZhciBzdGFydCA9IHNvdXJjZS5pbmRleE9mKCdcXG4nLCAxMCkgKyAxO1xuICAgIHZhciBib2R5ID0gc291cmNlLnN1YnN0cmluZyhzdGFydCkgKyAoc291cmNlbWFwID8gJ1xcL1xcLyMgc291cmNlTWFwcGluZ1VSTD0nICsgc291cmNlbWFwIDogJycpO1xuICAgIHZhciBibG9iID0gbmV3IEJsb2IoW2JvZHldLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JyB9KTtcbiAgICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQmFzZTY0V29ya2VyRmFjdG9yeShiYXNlNjQsIHNvdXJjZW1hcEFyZywgZW5hYmxlVW5pY29kZUFyZykge1xuICAgIHZhciB1cmw7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIFdvcmtlckZhY3Rvcnkob3B0aW9ucykge1xuICAgICAgICB1cmwgPSB1cmwgfHwgY3JlYXRlVVJMKGJhc2U2NCwgc291cmNlbWFwQXJnLCBlbmFibGVVbmljb2RlQXJnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBXb3JrZXIodXJsLCBvcHRpb25zKTtcbiAgICB9O1xufVxuXG52YXIgV29ya2VyRmFjdG9yeSA9IGNyZWF0ZUJhc2U2NFdvcmtlckZhY3RvcnkoJ0x5b2djbTlzYkhWd0xYQnNkV2RwYmkxM1pXSXRkMjl5YTJWeUxXeHZZV1JsY2lBcUx3b29ablZ1WTNScGIyNGdLQ2tnZXdvZ0lDZDFjMlVnYzNSeWFXTjBKenNLQ2lBZ1puVnVZM1JwYjI0Z2NtVnpZVzF3YkdWT1pXRnlaWE4wS0dSaGRHRXNJRzl3ZEdsdmJuTXBJSHNLSUNBZ0lHTnZibk4wSUhzZ2MyOTFjbU5sVjJsa2RHZ3NJSE52ZFhKalpVaGxhV2RvZEN3Z2RHRnlaMlYwVjJsa2RHZ3NJSFJoY21kbGRFaGxhV2RvZEN3Z2QybHVaRzkzTENCaWRXWm1aWElnUFNBd0lIMGdQU0J2Y0hScGIyNXpPd29nSUNBZ1kyOXVjM1FnVzNnd0xDQjVNQ3dnZURFc0lIa3hYU0E5SUhkcGJtUnZkenNLSUNBZ0lHTnZibk4wSUdWbVptVmpkR2wyWlZOdmRYSmpaVmRwWkhSb0lEMGdjMjkxY21ObFYybGtkR2dnTFNBeUlDb2dZblZtWm1WeU93b2dJQ0FnWTI5dWMzUWdaV1ptWldOMGFYWmxVMjkxY21ObFNHVnBaMmgwSUQwZ2MyOTFjbU5sU0dWcFoyaDBJQzBnTWlBcUlHSjFabVpsY2pzS0lDQWdJR052Ym5OMElISmxjMkZ0Y0d4bFpFUmhkR0VnUFNCamIzQjVUbVYzVTJsNlpTaGtZWFJoTENCMFlYSm5aWFJYYVdSMGFDd2dkR0Z5WjJWMFNHVnBaMmgwS1RzS0lDQWdJR1p2Y2lBb2JHVjBJSGtnUFNBd095QjVJRHdnZEdGeVoyVjBTR1ZwWjJoME95QjVLeXNwSUhzS0lDQWdJQ0FnWm05eUlDaHNaWFFnZUNBOUlEQTdJSGdnUENCMFlYSm5aWFJYYVdSMGFEc2dlQ3NyS1NCN0NpQWdJQ0FnSUNBZ1kyOXVjM1FnWTI5c0lEMGdZblZtWm1WeUlDc2dLR1ZtWm1WamRHbDJaVk52ZFhKalpWZHBaSFJvSUNvZ0tIZ3dJQ3NnZUNBdklIUmhjbWRsZEZkcFpIUm9JQ29nS0hneElDMGdlREFwS1NBK1BqNGdNQ2s3Q2lBZ0lDQWdJQ0FnWTI5dWMzUWdjbTkzSUQwZ1luVm1abVZ5SUNzZ0tHVm1abVZqZEdsMlpWTnZkWEpqWlVobGFXZG9kQ0FxSUNoNU1DQXJJSGtnTHlCMFlYSm5aWFJJWldsbmFIUWdLaUFvZVRFZ0xTQjVNQ2twSUQ0K1BpQXdLVHNLSUNBZ0lDQWdJQ0J5WlhOaGJYQnNaV1JFWVhSaFcza2dLaUIwWVhKblpYUlhhV1IwYUNBcklIaGRJRDBnWkdGMFlWdHliM2NnS2lCemIzVnlZMlZYYVdSMGFDQXJJR052YkYwN0NpQWdJQ0FnSUgwS0lDQWdJSDBLSUNBZ0lISmxkSFZ5YmlCeVpYTmhiWEJzWldSRVlYUmhPd29nSUgwS0lDQm1kVzVqZEdsdmJpQnlaWE5oYlhCc1pVUmhkR0VvWkdGMFlTd2diM0IwYVc5dWN5a2dld29nSUNBZ1kyOXVjM1FnZXlCdFpYUm9iMlFnUFNBaWJtVmhjbVZ6ZENJZ2ZTQTlJRzl3ZEdsdmJuTTdDaUFnSUNCemQybDBZMmdnS0cxbGRHaHZaQ2tnZXdvZ0lDQWdJQ0JqWVhObElDSnVaV0Z5WlhOMElqb0tJQ0FnSUNBZ0lDQnlaWFIxY200Z2NtVnpZVzF3YkdWT1pXRnlaWE4wS0dSaGRHRXNJRzl3ZEdsdmJuTXBPd29nSUNBZ0lDQmpZWE5sSUNKaWFXeHBibVZoY2lJNkNpQWdJQ0FnSUNBZ2NtVjBkWEp1SUhKbGMyRnRjR3hsUW1sc2FXNWxZWElvWkdGMFlTd2diM0IwYVc5dWN5azdDaUFnSUNCOUNpQWdmUW9nSUdaMWJtTjBhVzl1SUdOdmNIbE9aWGRUYVhwbEtHRnljbUY1TENCM2FXUjBhQ3dnYUdWcFoyaDBMQ0J6WVcxd2JHVnpVR1Z5VUdsNFpXd2dQU0F4S1NCN0NpQWdJQ0J5WlhSMWNtNGdibVYzSUNoUFltcGxZM1F1WjJWMFVISnZkRzkwZVhCbFQyWW9ZWEp5WVhrcEtTNWpiMjV6ZEhKMVkzUnZjaWgzYVdSMGFDQXFJR2hsYVdkb2RDQXFJSE5oYlhCc1pYTlFaWEpRYVhobGJDazdDaUFnZlFvZ0lHWjFibU4wYVc5dUlHeGxjbkFvZGpBc0lIWXhMQ0IwS1NCN0NpQWdJQ0J5WlhSMWNtNGdLREVnTFNCMEtTQXFJSFl3SUNzZ2RDQXFJSFl4T3dvZ0lIMEtJQ0JtZFc1amRHbHZiaUJ5WlhOaGJYQnNaVUpwYkdsdVpXRnlLR1JoZEdFc0lHOXdkR2x2Ym5NcElIc0tJQ0FnSUdOdmJuTjBJSHNnYzI5MWNtTmxWMmxrZEdnc0lITnZkWEpqWlVobGFXZG9kQ3dnZEdGeVoyVjBWMmxrZEdnc0lIUmhjbWRsZEVobGFXZG9kQ3dnZDJsdVpHOTNMQ0JpZFdabVpYSWdQU0F3TENCdWIyUmhkR0VnZlNBOUlHOXdkR2x2Ym5NN0NpQWdJQ0JqYjI1emRDQmJlREFzSUhrd0xDQjRNU3dnZVRGZElEMGdkMmx1Wkc5M093b2dJQ0FnWTI5dWMzUWdkMmx1Wkc5M1YybGtkR2dnUFNCNE1TQXRJSGd3T3dvZ0lDQWdZMjl1YzNRZ2QybHVaRzkzU0dWcFoyaDBJRDBnZVRFZ0xTQjVNRHNLSUNBZ0lHTnZibk4wSUc1bGQwRnljbUY1SUQwZ1kyOXdlVTVsZDFOcGVtVW9aR0YwWVN3Z2RHRnlaMlYwVjJsa2RHZ3NJSFJoY21kbGRFaGxhV2RvZENrN0NpQWdJQ0JqYjI1emRDQmxabVpsWTNScGRtVlRiM1Z5WTJWWGFXUjBhQ0E5SUhOdmRYSmpaVmRwWkhSb0lDMGdNaUFxSUdKMVptWmxjanNLSUNBZ0lHTnZibk4wSUdWbVptVmpkR2wyWlZOdmRYSmpaVWhsYVdkb2RDQTlJSE52ZFhKalpVaGxhV2RvZENBdElESWdLaUJpZFdabVpYSTdDaUFnSUNCamIyNXpkQ0JwYm5aVVlYSm5aWFJYYVdSMGFDQTlJREVnTHlCMFlYSm5aWFJYYVdSMGFEc0tJQ0FnSUdOdmJuTjBJR2x1ZGxSaGNtZGxkRWhsYVdkb2RDQTlJREVnTHlCMFlYSm5aWFJJWldsbmFIUTdDaUFnSUNCamIyNXpkQ0JwYzA1dlpHRjBZU0E5SUNoMllXeDFaU2tnUFQ0Z2V3b2dJQ0FnSUNCcFppQW9ibTlrWVhSaElEMDlQU0IyYjJsa0lEQXBDaUFnSUNBZ0lDQWdjbVYwZFhKdUlHWmhiSE5sT3dvZ0lDQWdJQ0JwWmlBb2JtOWtZWFJoSUQwOVBTQXdLUW9nSUNBZ0lDQWdJSEpsZEhWeWJpQjJZV3gxWlNBOVBUMGdNRHNLSUNBZ0lDQWdjbVYwZFhKdUlFMWhkR2d1WVdKektDaDJZV3gxWlNBdElHNXZaR0YwWVNrZ0x5QnViMlJoZEdFcElEd2dNV1V0TmpzS0lDQWdJSDA3Q2lBZ0lDQm1iM0lnS0d4bGRDQjVJRDBnTURzZ2VTQThJSFJoY21kbGRFaGxhV2RvZERzZ2VTc3JLU0I3Q2lBZ0lDQWdJR052Ym5OMElIbFNZWFJwYnlBOUlIa2dLaUJwYm5aVVlYSm5aWFJJWldsbmFIUTdDaUFnSUNBZ0lHTnZibk4wSUhsTllYQndaV1FnUFNCNU1DQXJJSGxTWVhScGJ5QXFJSGRwYm1SdmQwaGxhV2RvZERzS0lDQWdJQ0FnWTI5dWMzUWdjbUYzV1NBOUlHVm1abVZqZEdsMlpWTnZkWEpqWlVobGFXZG9kQ0FxSUhsTllYQndaV1FnS3lCaWRXWm1aWEk3Q2lBZ0lDQWdJR052Ym5OMElIbHNJRDBnVFdGMGFDNW1iRzl2Y2loeVlYZFpLVHNLSUNBZ0lDQWdZMjl1YzNRZ2VXZ2dQU0JOWVhSb0xtMXBiaWhOWVhSb0xtTmxhV3dvY21GM1dTa3NJSE52ZFhKalpVaGxhV2RvZENBdElHSjFabVpsY2lBdElERXBPd29nSUNBZ0lDQmpiMjV6ZENCMGVTQTlJSEpoZDFrZ0xTQjViRHNLSUNBZ0lDQWdabTl5SUNoc1pYUWdlQ0E5SURBN0lIZ2dQQ0IwWVhKblpYUlhhV1IwYURzZ2VDc3JLU0I3Q2lBZ0lDQWdJQ0FnWTI5dWMzUWdlRkpoZEdsdklEMGdlQ0FxSUdsdWRsUmhjbWRsZEZkcFpIUm9Pd29nSUNBZ0lDQWdJR052Ym5OMElIaE5ZWEJ3WldRZ1BTQjRNQ0FySUhoU1lYUnBieUFxSUhkcGJtUnZkMWRwWkhSb093b2dJQ0FnSUNBZ0lHTnZibk4wSUhKaGQxZ2dQU0JsWm1abFkzUnBkbVZUYjNWeVkyVlhhV1IwYUNBcUlIaE5ZWEJ3WldRZ0t5QmlkV1ptWlhJN0NpQWdJQ0FnSUNBZ1kyOXVjM1FnZUd3Z1BTQk5ZWFJvTG1ac2IyOXlLSEpoZDFncE93b2dJQ0FnSUNBZ0lHTnZibk4wSUhob0lEMGdUV0YwYUM1dGFXNG9UV0YwYUM1alpXbHNLSEpoZDFncExDQnpiM1Z5WTJWWGFXUjBhQ0F0SUdKMVptWmxjaUF0SURFcE93b2dJQ0FnSUNBZ0lHTnZibk4wSUhSNFJuSmhZM1JwYjI0Z1BTQnlZWGRZSUMwZ2VHdzdDaUFnSUNBZ0lDQWdZMjl1YzNRZ1kyVnVkR1Z5SUQwZ1pHRjBZVnQ1YkNBcUlITnZkWEpqWlZkcFpIUm9JQ3NnZUd4ZE93b2dJQ0FnSUNBZ0lHTnZibk4wSUc1bGFXZG9ZbTl5Y3lBOUlGc0tJQ0FnSUNBZ0lDQWdJR1JoZEdGYmVXd2dLaUJ6YjNWeVkyVlhhV1IwYUNBcklIaHNYU3dLSUNBZ0lDQWdJQ0FnSUdSaGRHRmJlV3dnS2lCemIzVnlZMlZYYVdSMGFDQXJJSGhvWFN3S0lDQWdJQ0FnSUNBZ0lHUmhkR0ZiZVdnZ0tpQnpiM1Z5WTJWWGFXUjBhQ0FySUhoc1hTd0tJQ0FnSUNBZ0lDQWdJR1JoZEdGYmVXZ2dLaUJ6YjNWeVkyVlhhV1IwYUNBcklIaG9YUW9nSUNBZ0lDQWdJRjA3Q2lBZ0lDQWdJQ0FnYm1WcFoyaGliM0p6TG1admNrVmhZMmdvS0c1bGFXZG9ZbTl5TENCcGJtUmxlQ2tnUFQ0Z2V3b2dJQ0FnSUNBZ0lDQWdhV1lnS0dselRtOWtZWFJoS0c1bGFXZG9ZbTl5S1NrZ2V3b2dJQ0FnSUNBZ0lDQWdJQ0J1WldsbmFHSnZjbk5iYVc1a1pYaGRJRDBnWTJWdWRHVnlPd29nSUNBZ0lDQWdJQ0FnZlFvZ0lDQWdJQ0FnSUgwcE93b2dJQ0FnSUNBZ0lHbG1JQ2hwYzA1dlpHRjBZU2hqWlc1MFpYSXBLU0I3Q2lBZ0lDQWdJQ0FnSUNCdVpYZEJjbkpoZVZ0NUlDb2dkR0Z5WjJWMFYybGtkR2dnS3lCNFhTQTlJRzV2WkdGMFlUc0tJQ0FnSUNBZ0lDQWdJR052Ym5ScGJuVmxPd29nSUNBZ0lDQWdJSDBLSUNBZ0lDQWdJQ0JqYjI1emRDQmJiR3dzSUdoc0xDQnNhQ3dnYUdoZElEMGdibVZwWjJoaWIzSnpPd29nSUNBZ0lDQWdJR052Ym5OMElIWXdJRDBnYkdWeWNDaHNiQ3dnYUd3c0lIUjRSbkpoWTNScGIyNHBPd29nSUNBZ0lDQWdJR052Ym5OMElIWXhJRDBnYkdWeWNDaHNhQ3dnYUdnc0lIUjRSbkpoWTNScGIyNHBPd29nSUNBZ0lDQWdJR052Ym5OMElIWmhiSFZsSUQwZ2JHVnljQ2gyTUN3Z2RqRXNJSFI1S1RzS0lDQWdJQ0FnSUNCdVpYZEJjbkpoZVZ0NUlDb2dkR0Z5WjJWMFYybGtkR2dnS3lCNFhTQTlJSFpoYkhWbE93b2dJQ0FnSUNCOUNpQWdJQ0I5Q2lBZ0lDQnlaWFIxY200Z2JtVjNRWEp5WVhrN0NpQWdmUW9LSUNCdmJtMWxjM05oWjJVZ1BTQm1kVzVqZEdsdmJpaGxLU0I3Q2lBZ0lDQmpiMjV6ZENCN0lHUmhkR0VzSUc5d2RHbHZibk1zSUdsa0lIMGdQU0JsTG1SaGRHRTdDaUFnSUNCamIyNXpkQ0J5WlhOMWJIUWdQU0J5WlhOaGJYQnNaVVJoZEdFb1pHRjBZU3dnYjNCMGFXOXVjeWs3Q2lBZ0lDQndiM04wVFdWemMyRm5aU2g3SUdSaGRHRTZJSEpsYzNWc2RDd2dhV1FnZlNrN0NpQWdmVHNLQ24wcEtDazdDaTh2SXlCemIzVnlZMlZOWVhCd2FXNW5WVkpNUFhkdmNtdGxjaTVxY3k1dFlYQUtDZz09JywgbnVsbCwgZmFsc2UpO1xuLyogZXNsaW50LWVuYWJsZSAqL1xuXG52YXIgX19kZWZQcm9wJDEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wJDEgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDEob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQkMSA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wJDEob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xudmFyIF9fYXN5bmMkMSA9IChfX3RoaXMsIF9fYXJndW1lbnRzLCBnZW5lcmF0b3IpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB2YXIgZnVsZmlsbGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZWplY3RlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IudGhyb3codmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHN0ZXAgPSAoeCkgPT4geC5kb25lID8gcmVzb2x2ZSh4LnZhbHVlKSA6IFByb21pc2UucmVzb2x2ZSh4LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseShfX3RoaXMsIF9fYXJndW1lbnRzKSkubmV4dCgpKTtcbiAgfSk7XG59O1xuY29uc3QgZGVmYXVsdFBvb2xTaXplID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiA/IG5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5IHx8IDIgOiAyO1xuY2xhc3MgV29ya2VyUG9vbCB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtzaXplXSBUaGUgc2l6ZSBvZiB0aGUgcG9vbC4gRGVmYXVsdHMgdG8gdGhlIG51bWJlciBvZiBDUFVzXG4gICAqICAgICAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZS4gV2hlbiB0aGlzIHBhcmFtZXRlciBpcyBgbnVsbGAgb3IgMCwgdGhlbiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgZGVjb2Rpbmcgd2lsbCBiZSBkb25lIGluIHRoZSBtYWluIHRocmVhZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHNpemUgPSBkZWZhdWx0UG9vbFNpemUpIHtcbiAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJ3b3JrZXJzXCIpO1xuICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcInNpemVcIik7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwibWVzc2FnZUlkXCIpO1xuICAgIHRoaXMud29ya2VycyA9IG51bGw7XG4gICAgdGhpcy5zaXplID0gc2l6ZSAhPSBudWxsID8gc2l6ZSA6IDA7XG4gICAgdGhpcy5tZXNzYWdlSWQgPSAwO1xuICAgIGlmIChzaXplKSB7XG4gICAgICB0aGlzLndvcmtlcnMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIHRoaXMud29ya2Vycy5wdXNoKHsgd29ya2VyOiBXb3JrZXJGYWN0b3J5KCksIGlkbGU6IHRydWUgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlc2FtcGxlKGRhdGEsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hc3luYyQxKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaXplID09PSAwID8gcmVzYW1wbGVEYXRhKGRhdGEsIG9wdGlvbnMpIDogbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgY29uc3Qgd29ya2VyID0gdGhpcy53b3JrZXJzLmZpbmQoKGNhbmRpZGF0ZSkgPT4gY2FuZGlkYXRlLmlkbGUpIHx8IHRoaXMud29ya2Vyc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB0aGlzLnNpemUpXTtcbiAgICAgICAgd29ya2VyLmlkbGUgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgaWQgPSB0aGlzLm1lc3NhZ2VJZCsrO1xuICAgICAgICBjb25zdCBvbk1lc3NhZ2UgPSAoZSkgPT4ge1xuICAgICAgICAgIGlmIChlLmRhdGEuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICB3b3JrZXIuaWRsZSA9IHRydWU7XG4gICAgICAgICAgICByZXNvbHZlKGUuZGF0YS5kYXRhKTtcbiAgICAgICAgICAgIHdvcmtlci53b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25NZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHdvcmtlci53b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25NZXNzYWdlKTtcbiAgICAgICAgd29ya2VyLndvcmtlci5wb3N0TWVzc2FnZSh7IGRhdGEsIG9wdGlvbnMsIGlkIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy53b3JrZXJzKSB7XG4gICAgICB0aGlzLndvcmtlcnMuZm9yRWFjaCgod29ya2VyKSA9PiB7XG4gICAgICAgIHdvcmtlci53b3JrZXIudGVybWluYXRlKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMud29ya2VycyA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG52YXIgX19hc3luYyA9IChfX3RoaXMsIF9fYXJndW1lbnRzLCBnZW5lcmF0b3IpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB2YXIgZnVsZmlsbGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZWplY3RlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IudGhyb3codmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHN0ZXAgPSAoeCkgPT4geC5kb25lID8gcmVzb2x2ZSh4LnZhbHVlKSA6IFByb21pc2UucmVzb2x2ZSh4LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseShfX3RoaXMsIF9fYXJndW1lbnRzKSkubmV4dCgpKTtcbiAgfSk7XG59O1xuY29uc3QgY2FudmFzID0gY3JlYXRlQ2FuYXZhcygyNTYsIDI1Nik7XG5jbGFzcyBUSUZGSW1hZ2VyeVByb3ZpZGVyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJlYWR5XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ0aWxpbmdTY2hlbWVcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJlY3RhbmdsZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidGlsZVNpemVcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInRpbGVXaWR0aFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidGlsZUhlaWdodFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWF4aW11bUxldmVsXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtaW5pbXVtTGV2ZWxcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNyZWRpdFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZXJyb3JFdmVudFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVhZHlQcm9taXNlXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJiYW5kc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibm9EYXRhXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJoYXNBbHBoYUNoYW5uZWxcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInBsb3RcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJlbmRlck9wdGlvbnNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJlYWRTYW1wbGVzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyZXF1ZXN0TGV2ZWxzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJiYm94XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfZGVzdHJveWVkXCIsIGZhbHNlKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3NvdXJjZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2ltYWdlQ291bnRcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9pbWFnZXNcIiwgW10pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfaW1hZ2VzQ2FjaGVcIiwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9jYWNoZVNpemVcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9pc1RpbGVkXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfcHJvalwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwib3JpZ2luXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyZXZlcnNlWVwiLCBmYWxzZSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNhbXBsZXNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIndvcmtlclBvb2xcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdlb3RpZmZXb3JrZXJQb29sXCIpO1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICB0aGlzLmhhc0FscGhhQ2hhbm5lbCA9IChfYSA9IG9wdGlvbnMuaGFzQWxwaGFDaGFubmVsKSAhPSBudWxsID8gX2EgOiB0cnVlO1xuICAgIHRoaXMubWF4aW11bUxldmVsID0gKF9iID0gb3B0aW9ucy5tYXhpbXVtTGV2ZWwpICE9IG51bGwgPyBfYiA6IDE4O1xuICAgIHRoaXMubWluaW11bUxldmVsID0gKF9jID0gb3B0aW9ucy5taW5pbXVtTGV2ZWwpICE9IG51bGwgPyBfYyA6IDA7XG4gICAgdGhpcy5jcmVkaXQgPSBuZXcgQ3JlZGl0KG9wdGlvbnMuY3JlZGl0IHx8IFwiXCIsIGZhbHNlKTtcbiAgICB0aGlzLmVycm9yRXZlbnQgPSBuZXcgRXZlbnQoKTtcbiAgICB0aGlzLl9jYWNoZVNpemUgPSAoX2QgPSBvcHRpb25zLmNhY2hlU2l6ZSkgIT0gbnVsbCA/IF9kIDogMTAwO1xuICAgIHRoaXMud29ya2VyUG9vbCA9IG5ldyBXb3JrZXJQb29sKG9wdGlvbnMud29ya2VyUG9vbFNpemUpO1xuICAgIHRoaXMuZ2VvdGlmZldvcmtlclBvb2wgPSBuZXcgUG9vbChvcHRpb25zLndvcmtlclBvb2xTaXplKTtcbiAgICB0aGlzLnJlYWR5ID0gZmFsc2U7XG4gICAgaWYgKGRlZmluZWQob3B0aW9ucy51cmwpKSB7XG4gICAgICB0aGlzLnJlYWR5UHJvbWlzZSA9IHRoaXMuX2J1aWxkKG9wdGlvbnMudXJsLCBvcHRpb25zKS50aGVuKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0IGlzRGVzdHJveWVkKCkge1xuICAgIHJldHVybiB0aGlzLl9kZXN0cm95ZWQ7XG4gIH1cbiAgX2J1aWxkKF8wKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKHVybCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XG4gICAgICBjb25zdCB7IHRpbGVTaXplLCByZW5kZXJPcHRpb25zLCBwcm9qRnVuYywgcmVxdWVzdE9wdGlvbnMgfSA9IG9wdGlvbnM7XG4gICAgICBsZXQgc291cmNlID0geWllbGQgdXJsIGluc3RhbmNlb2YgRmlsZSB8fCB1cmwgaW5zdGFuY2VvZiBCbG9iID8gZnJvbUJsb2IodXJsKSA6IGZyb21VcmwodXJsLCByZXF1ZXN0T3B0aW9ucyk7XG4gICAgICBsZXQgaW1hZ2UgPSB5aWVsZCBzb3VyY2UuZ2V0SW1hZ2UoKTtcbiAgICAgIHRoaXMuX2lzVGlsZWQgPSBpbWFnZS5pc1RpbGVkO1xuICAgICAgaWYgKCF0aGlzLl9pc1RpbGVkICYmIHR5cGVvZiB1cmwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgc291cmNlID0geWllbGQgZnJvbUJsb2IoeWllbGQgKHlpZWxkIGZldGNoKHVybCkpLmJsb2IoKSk7XG4gICAgICAgIGltYWdlID0geWllbGQgc291cmNlLmdldEltYWdlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aGlzLm9yaWdpbiA9IHRoaXMuX2dldE9yaWdpbihpbWFnZSk7XG4gICAgICB0aGlzLmJib3ggPSBpbWFnZS5nZXRCb3VuZGluZ0JveCgpO1xuICAgICAgdGhpcy5yZXZlcnNlWSA9IHRoaXMuX2NoZWNrSWZSZXZlcnNlZChpbWFnZSk7XG4gICAgICBjb25zdCBbd2VzdCwgc291dGgsIGVhc3QsIG5vcnRoXSA9IHRoaXMuYmJveDtcbiAgICAgIGNvbnN0IHByakNvZGUgPSArKChfYSA9IGltYWdlLmdlb0tleXMuUHJvamVjdGVkQ1NUeXBlR2VvS2V5KSAhPSBudWxsID8gX2EgOiBpbWFnZS5nZW9LZXlzLkdlb2dyYXBoaWNUeXBlR2VvS2V5KTtcbiAgICAgIHRoaXMuX3Byb2ogPSBwcm9qRnVuYyA9PSBudWxsID8gdm9pZCAwIDogcHJvakZ1bmMocHJqQ29kZSk7XG4gICAgICBpZiAocHJqQ29kZSA9PT0gMzg1NyB8fCBwcmpDb2RlID09PSA5MDA5MTMpIHtcbiAgICAgICAgdGhpcy50aWxpbmdTY2hlbWUgPSBuZXcgV2ViTWVyY2F0b3JUaWxpbmdTY2hlbWUoe1xuICAgICAgICAgIHJlY3RhbmdsZU5vcnRoZWFzdEluTWV0ZXJzOiBuZXcgQ2FydGVzaWFuMihlYXN0LCBub3J0aCksXG4gICAgICAgICAgcmVjdGFuZ2xlU291dGh3ZXN0SW5NZXRlcnM6IG5ldyBDYXJ0ZXNpYW4yKHdlc3QsIHNvdXRoKVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAocHJqQ29kZSA9PT0gNDMyNikge1xuICAgICAgICB0aGlzLnRpbGluZ1NjaGVtZSA9IG5ldyBHZW9ncmFwaGljVGlsaW5nU2NoZW1lKHtcbiAgICAgICAgICByZWN0YW5nbGU6IFJlY3RhbmdsZS5mcm9tRGVncmVlcyguLi50aGlzLmJib3gpLFxuICAgICAgICAgIG51bWJlck9mTGV2ZWxaZXJvVGlsZXNYOiAxLFxuICAgICAgICAgIG51bWJlck9mTGV2ZWxaZXJvVGlsZXNZOiAxXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgKChfYiA9IHRoaXMuX3Byb2opID09IG51bGwgPyB2b2lkIDAgOiBfYi5wcm9qZWN0KSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiAoKF9jID0gdGhpcy5fcHJvaikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnVucHJvamVjdCkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zb2xlLndhcm4oYFtFeHBlcmltZW50YWxdIFJlcHJvamVjdGlvbiBFUFNHOiR7cHJqQ29kZX1gKTtcbiAgICAgICAgdGhpcy50aWxpbmdTY2hlbWUgPSBuZXcgVElGRkltYWdlcnlQcm92aWRlclRpbGluZ1NjaGVtZShfX3NwcmVhZFZhbHVlcyh7XG4gICAgICAgICAgcmVjdGFuZ2xlTm9ydGhlYXN0SW5NZXRlcnM6IG5ldyBDYXJ0ZXNpYW4yKGVhc3QsIG5vcnRoKSxcbiAgICAgICAgICByZWN0YW5nbGVTb3V0aHdlc3RJbk1ldGVyczogbmV3IENhcnRlc2lhbjIod2VzdCwgc291dGgpXG4gICAgICAgIH0sIHRoaXMuX3Byb2opKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IERldmVsb3BlckVycm9yKGBVbnNwcG9ydGVkIHByb2plY3Rpb24gdHlwZTogRVBTRzoke3ByakNvZGV9LCBwbGVhc2UgYWRkIHByb2pGdW5jIHBhcmFtZXRlciB0byBoYW5kbGUgcHJvamVjdGlvbmApO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVjdGFuZ2xlID0gdGhpcy50aWxpbmdTY2hlbWUucmVjdGFuZ2xlO1xuICAgICAgaWYgKHRoaXMucmVjdGFuZ2xlLmVhc3QgPCB0aGlzLnJlY3RhbmdsZS53ZXN0KSB7XG4gICAgICAgIHRoaXMucmVjdGFuZ2xlLmVhc3QgKz0gQ2VzaXVtTWF0aC5UV09fUEk7XG4gICAgICB9XG4gICAgICB0aGlzLl9pbWFnZUNvdW50ID0geWllbGQgc291cmNlLmdldEltYWdlQ291bnQoKTtcbiAgICAgIHRoaXMudGlsZVNpemUgPSB0aGlzLnRpbGVXaWR0aCA9IHRpbGVTaXplIHx8ICh0aGlzLl9pc1RpbGVkID8gaW1hZ2UuZ2V0VGlsZVdpZHRoKCkgOiBpbWFnZS5nZXRXaWR0aCgpKSB8fCAyNTY7XG4gICAgICB0aGlzLnRpbGVIZWlnaHQgPSB0aWxlU2l6ZSB8fCAodGhpcy5faXNUaWxlZCA/IGltYWdlLmdldFRpbGVIZWlnaHQoKSA6IGltYWdlLmdldEhlaWdodCgpKSB8fCAyNTY7XG4gICAgICBjb25zb2xlLmxvZyh0aGlzLnRpbGVXaWR0aCwgdGhpcy50aWxlSGVpZ2h0KTtcbiAgICAgIHRoaXMucmVxdWVzdExldmVscyA9IHRoaXMuX2lzVGlsZWQgPyB5aWVsZCB0aGlzLl9nZXRDb2dMZXZlbHMoKSA6IFswXTtcbiAgICAgIHRoaXMuX2ltYWdlcyA9IG5ldyBBcnJheSh0aGlzLl9pbWFnZUNvdW50KS5maWxsKG51bGwpO1xuICAgICAgY29uc3Qgc2FtcGxlcyA9IGltYWdlLmdldFNhbXBsZXNQZXJQaXhlbCgpO1xuICAgICAgdGhpcy5zYW1wbGVzID0gc2FtcGxlcztcbiAgICAgIHRoaXMucmVuZGVyT3B0aW9ucyA9IHJlbmRlck9wdGlvbnMgIT0gbnVsbCA/IHJlbmRlck9wdGlvbnMgOiB7fTtcbiAgICAgIGNvbnN0IG5vRGF0YSA9IGltYWdlLmdldEdEQUxOb0RhdGEoKTtcbiAgICAgIHRoaXMubm9EYXRhID0gKF9kID0gdGhpcy5yZW5kZXJPcHRpb25zLm5vZGF0YSkgIT0gbnVsbCA/IF9kIDogbm9EYXRhO1xuICAgICAgaWYgKHNhbXBsZXMgPCAzICYmIHRoaXMucmVuZGVyT3B0aW9ucy5jb252ZXJ0VG9SR0IpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRGV2ZWxvcGVyRXJyb3IoXCJDYW4gbm90IHJlbmRlciB0aGUgaW1hZ2UgYXMgUkdCLCBwbGVhc2UgY2hlY2sgdGhlIGNvbnZlcnRUb1JHQiBwYXJhbWV0ZXJcIik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnJlbmRlck9wdGlvbnMuc2luZ2xlICYmICF0aGlzLnJlbmRlck9wdGlvbnMubXVsdGkgJiYgIXRoaXMucmVuZGVyT3B0aW9ucy5jb252ZXJ0VG9SR0IpIHtcbiAgICAgICAgaWYgKHNhbXBsZXMgPiAyKSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJPcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgICAgICAgY29udmVydFRvUkdCOiB0cnVlXG4gICAgICAgICAgfSwgdGhpcy5yZW5kZXJPcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlbmRlck9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICAgICAgICBzaW5nbGU6IHtcbiAgICAgICAgICAgICAgYmFuZDogMVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRoaXMucmVuZGVyT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJlbmRlck9wdGlvbnMuc2luZ2xlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyT3B0aW9ucy5zaW5nbGUuYmFuZCA9IChfZSA9IHRoaXMucmVuZGVyT3B0aW9ucy5zaW5nbGUuYmFuZCkgIT0gbnVsbCA/IF9lIDogMTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgc2luZ2xlLCBtdWx0aSwgY29udmVydFRvUkdCIH0gPSB0aGlzLnJlbmRlck9wdGlvbnM7XG4gICAgICB0aGlzLnJlYWRTYW1wbGVzID0gbXVsdGkgPyBbbXVsdGkuci5iYW5kIC0gMSwgbXVsdGkuZy5iYW5kIC0gMSwgbXVsdGkuYi5iYW5kIC0gMV0gOiBjb252ZXJ0VG9SR0IgPyBbMCwgMSwgMl0gOiBbc2luZ2xlLmJhbmQgLSAxXTtcbiAgICAgIGlmIChzaW5nbGUgPT0gbnVsbCA/IHZvaWQgMCA6IHNpbmdsZS5leHByZXNzaW9uKSB7XG4gICAgICAgIHRoaXMucmVhZFNhbXBsZXMgPSBmaW5kQW5kU29ydEJhbmROdW1iZXJzKHNpbmdsZS5leHByZXNzaW9uKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJhbmRzID0ge307XG4gICAgICB5aWVsZCBQcm9taXNlLmFsbCh0aGlzLnJlYWRTYW1wbGVzLm1hcCgoaSkgPT4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gaW1hZ2UuZ2V0R0RBTE1ldGFkYXRhKGkpO1xuICAgICAgICBjb25zdCBiYW5kTnVtID0gaSArIDE7XG4gICAgICAgIGlmICgoZWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogZWxlbWVudC5TVEFUSVNUSUNTX01JTklNVU0pICYmIChlbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBlbGVtZW50LlNUQVRJU1RJQ1NfTUFYSU1VTSkpIHtcbiAgICAgICAgICBiYW5kc1tiYW5kTnVtXSA9IHtcbiAgICAgICAgICAgIG1pbjogK2VsZW1lbnQuU1RBVElTVElDU19NSU5JTVVNLFxuICAgICAgICAgICAgbWF4OiArZWxlbWVudC5TVEFUSVNUSUNTX01BWElNVU1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjb252ZXJ0VG9SR0IpIHtcbiAgICAgICAgICAgIGJhbmRzW2JhbmROdW1dID0ge1xuICAgICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICAgIG1heDogMjU1XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobXVsdGkpIHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0QmFuZCA9IG11bHRpW09iamVjdC5rZXlzKG11bHRpKS5maW5kKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgICAgICAgcmV0dXJuICgoX2EyID0gbXVsdGlba2V5XSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5iYW5kKSA9PT0gYmFuZE51bTtcbiAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIGlmICgoaW5wdXRCYW5kID09IG51bGwgPyB2b2lkIDAgOiBpbnB1dEJhbmQubWluKSAhPT0gdm9pZCAwICYmIChpbnB1dEJhbmQgPT0gbnVsbCA/IHZvaWQgMCA6IGlucHV0QmFuZC5tYXgpICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgY29uc3QgeyBtaW4sIG1heCB9ID0gaW5wdXRCYW5kO1xuICAgICAgICAgICAgICBiYW5kc1tiYW5kTnVtXSA9IHtcbiAgICAgICAgICAgICAgICBtaW4sXG4gICAgICAgICAgICAgICAgbWF4XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzaW5nbGUgJiYgIXNpbmdsZS5leHByZXNzaW9uICYmIHNpbmdsZS5iYW5kID09PSBiYW5kTnVtICYmIHNpbmdsZS5kb21haW4pIHtcbiAgICAgICAgICAgIGJhbmRzW2JhbmROdW1dID0ge1xuICAgICAgICAgICAgICBtaW46IHNpbmdsZS5kb21haW5bMF0sXG4gICAgICAgICAgICAgIG1heDogc2luZ2xlLmRvbWFpblsxXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCEoc2luZ2xlID09IG51bGwgPyB2b2lkIDAgOiBzaW5nbGUuZXhwcmVzc2lvbikgJiYgIWJhbmRzW2JhbmROdW1dKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYENhbiBub3QgZ2V0IGJhbmQke2JhbmROdW19IG1pbi9tYXgsIHRyeSB0byBjYWxjdWxhdGUgbWluL21heCB2YWx1ZXMsIG9yIHNldHRpbmcgJHtzaW5nbGUgPyBcImRvbWFpblwiIDogXCJtaW4gLyBtYXhcIn1gKTtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpZXdJbWFnZSA9IHlpZWxkIHNvdXJjZS5nZXRJbWFnZSh0aGlzLnJlcXVlc3RMZXZlbHNbMF0pO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9ICh5aWVsZCBwcmV2aWV3SW1hZ2UucmVhZFJhc3RlcnMoe1xuICAgICAgICAgICAgICBzYW1wbGVzOiBbaV0sXG4gICAgICAgICAgICAgIHBvb2w6IHRoaXMuZ2VvdGlmZldvcmtlclBvb2xcbiAgICAgICAgICAgIH0pKVswXS5maWx0ZXIoKGl0ZW0pID0+ICFpc05hTihpdGVtKSk7XG4gICAgICAgICAgICBiYW5kc1tiYW5kTnVtXSA9IGdldE1pbk1heChkYXRhLCBub0RhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSkpKTtcbiAgICAgIHRoaXMuYmFuZHMgPSBiYW5kcztcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLnJlbmRlck9wdGlvbnMuc2luZ2xlKSB7XG4gICAgICAgICAgY29uc3QgYmFuZCA9IHRoaXMuYmFuZHNbc2luZ2xlLmJhbmRdO1xuICAgICAgICAgIGlmICghc2luZ2xlLmV4cHJlc3Npb24gJiYgIWJhbmQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcihgSW52YWxpZCBiYW5kJHtzaW5nbGUuYmFuZH1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZG9tYWluID0gKF9mID0gc2luZ2xlLmRvbWFpbikgIT0gbnVsbCA/IF9mIDogW2JhbmQubWluLCBiYW5kLm1heF07XG4gICAgICAgICAgdGhpcy5wbG90ID0gbmV3IHBsb3QoX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7XG4gICAgICAgICAgICBjYW52YXNcbiAgICAgICAgICB9LCBzaW5nbGUpLCB7XG4gICAgICAgICAgICBkb21haW5cbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgdGhpcy5wbG90LnNldE5vRGF0YVZhbHVlKHRoaXMubm9EYXRhKTtcbiAgICAgICAgICBjb25zdCB7IGV4cHJlc3Npb24sIGNvbG9ycywgY29sb3JTY2FsZUltYWdlIH0gPSBzaW5nbGU7XG4gICAgICAgICAgdGhpcy5wbG90LnNldEV4cHJlc3Npb24oZXhwcmVzc2lvbik7XG4gICAgICAgICAgaWYgKGNvbG9ycykge1xuICAgICAgICAgICAgY29uc3QgY29sb3JTY2FsZSA9IGdlbmVyYXRlQ29sb3JTY2FsZShjb2xvcnMsIChzaW5nbGUgPT0gbnVsbCA/IHZvaWQgMCA6IHNpbmdsZS51c2VSZWFsVmFsdWUpID8gZG9tYWluIDogWzAsIDFdKTtcbiAgICAgICAgICAgIGFkZENvbG9yU2NhbGUoXCJ0ZW1wXCIsIGNvbG9yU2NhbGUuY29sb3JzLCBjb2xvclNjYWxlLnBvc2l0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLnBsb3Quc2V0Q29sb3JTY2FsZShcInRlbXBcIik7XG4gICAgICAgICAgfSBlbHNlIGlmICghY29sb3JTY2FsZUltYWdlKSB7XG4gICAgICAgICAgICB0aGlzLnBsb3Quc2V0Q29sb3JTY2FsZSgoX2cgPSBzaW5nbGUgPT0gbnVsbCA/IHZvaWQgMCA6IHNpbmdsZS5jb2xvclNjYWxlKSAhPSBudWxsID8gX2cgOiBcImJsYWNrd2hpdGVcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIHRoaXMuZXJyb3JFdmVudC5yYWlzZUV2ZW50KGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZWFkeVByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICB0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZnJvbVVybChfMCkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qICh1cmwsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgVElGRkltYWdlcnlQcm92aWRlcihvcHRpb25zKTtcbiAgICAgIHlpZWxkIHByb3ZpZGVyLl9idWlsZCh1cmwsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7XG4gICAgICAgIHVybDogdm9pZCAwXG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gcHJvdmlkZXI7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgb3JpZ2luIG9mIGFuIGltYWdlLiAgSWYgdGhlIGltYWdlIGRvZXMgbm90IGhhdmUgYW4gYWZmaW5lIHRyYW5zZm9ybSxcbiAgICogdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgcGl4ZWwgYm91bmRzIGlzIHJldHVybmVkLlxuICAgKiBAcGFyYW0ge0dlb1RJRkZJbWFnZX0gaW1hZ2UgVGhlIGltYWdlLlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUaGUgaW1hZ2Ugb3JpZ2luLlxuICAgKi9cbiAgX2dldE9yaWdpbihpbWFnZSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gaW1hZ2UuZ2V0T3JpZ2luKCkuc2xpY2UoMCwgMik7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgcmV0dXJuIFswLCBpbWFnZS5maWxlRGlyZWN0b3J5LkltYWdlTGVuZ3RoXTtcbiAgICB9XG4gIH1cbiAgX2NoZWNrSWZSZXZlcnNlZChpbWFnZSkge1xuICAgIGNvbnN0IHBpeGVsU2NhbGUgPSBpbWFnZS5nZXRGaWxlRGlyZWN0b3J5KCkuTW9kZWxQaXhlbFNjYWxlO1xuICAgIGlmIChwaXhlbFNjYWxlKSB7XG4gICAgICBjb25zdCBwaXhlbFNjYWxlWSA9IHBpeGVsU2NhbGVbMV07XG4gICAgICBpZiAocGl4ZWxTY2FsZVkgPCAwKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgdHJhbnNmb3JtYXRpb24gPSBpbWFnZS5nZXRGaWxlRGlyZWN0b3J5KCkuTW9kZWxUcmFuc2Zvcm1hdGlvbjtcbiAgICBpZiAodHJhbnNmb3JtYXRpb24pIHtcbiAgICAgIGNvbnN0IG9yaWdpblggPSB0cmFuc2Zvcm1hdGlvblszXTtcbiAgICAgIGNvbnN0IG9yaWdpblkgPSB0cmFuc2Zvcm1hdGlvbls3XTtcbiAgICAgIGlmIChvcmlnaW5ZID4gb3JpZ2luWClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogZ2V0IHN1aXRhYmxlIGNvZyBsZXZlbHNcbiAgICovXG4gIF9nZXRDb2dMZXZlbHMoKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGxldmVscyA9IFtdO1xuICAgICAgbGV0IG1heGltdW1MZXZlbCA9IHRoaXMuX2ltYWdlQ291bnQgLSAxO1xuICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX2ltYWdlQ291bnQgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBpbWFnZSA9IHRoaXMuX2ltYWdlc1tpXSA9IHlpZWxkIHRoaXMuX3NvdXJjZS5nZXRJbWFnZShpKTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBpbWFnZS5nZXRXaWR0aCgpO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBpbWFnZS5nZXRIZWlnaHQoKTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBpZiAoaSA9PT0gdGhpcy5faW1hZ2VDb3VudCAtIDEpIHtcbiAgICAgICAgICBjb25zdCBmaXJzdEltYWdlTGV2ZWwgPSBNYXRoLmNlaWwoKHNpemUgLSB0aGlzLnRpbGVTaXplKSAvIHRoaXMudGlsZVNpemUpO1xuICAgICAgICAgIGxldmVscy5wdXNoKC4uLm5ldyBBcnJheShmaXJzdEltYWdlTGV2ZWwpLmZpbGwoaSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaXplID4gdGhpcy50aWxlU2l6ZSAqIDAuNSkge1xuICAgICAgICAgIG1heGltdW1MZXZlbCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBub3dDb2dMZXZlbCA9IG1heGltdW1MZXZlbDtcbiAgICAgIHdoaWxlIChub3dDb2dMZXZlbCA+PSAwKSB7XG4gICAgICAgIGxldmVscy5wdXNoKG5vd0NvZ0xldmVsLS0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxldmVscztcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRpbGUgZGF0YVxuICAgKiBAcGFyYW0geCBcbiAgICogQHBhcmFtIHkgXG4gICAqIEBwYXJhbSB6IFxuICAgKi9cbiAgX2xvYWRUaWxlKHJlcXgsIHJlcXksIHJlcXopIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgbGV0IHggPSByZXF4LCB5ID0gcmVxeSwgeiA9IHJlcXosIHN0YXJ0WCA9IHJlcXgsIHN0YXJ0WSA9IHJlcXk7XG4gICAgICBjb25zdCBtYXhDb2dMZXZlbCA9IHRoaXMucmVxdWVzdExldmVscy5sZW5ndGggLSAxO1xuICAgICAgaWYgKHogPiBtYXhDb2dMZXZlbCkge1xuICAgICAgICB6ID0gbWF4Q29nTGV2ZWw7XG4gICAgICAgIHggPSB4ID4+IHJlcXogLSBtYXhDb2dMZXZlbDtcbiAgICAgICAgeSA9IHkgPj4gcmVxeiAtIG1heENvZ0xldmVsO1xuICAgICAgICBzdGFydFggPSB4IDw8IHJlcXogLSB6O1xuICAgICAgICBzdGFydFkgPSB5IDw8IHJlcXogLSB6O1xuICAgICAgfVxuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnJlcXVlc3RMZXZlbHNbel07XG4gICAgICBsZXQgaW1hZ2UgPSB0aGlzLl9pbWFnZXNbaW5kZXhdO1xuICAgICAgaWYgKCFpbWFnZSkge1xuICAgICAgICBpbWFnZSA9IHRoaXMuX2ltYWdlc1tpbmRleF0gPSB5aWVsZCB0aGlzLl9zb3VyY2UuZ2V0SW1hZ2UoaW5kZXgpO1xuICAgICAgfVxuICAgICAgY29uc3Qgd2lkdGggPSBpbWFnZS5nZXRXaWR0aCgpO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2UuZ2V0SGVpZ2h0KCk7XG4gICAgICBjb25zdCB0aWxlWE51bSA9IHRoaXMudGlsaW5nU2NoZW1lLmdldE51bWJlck9mWFRpbGVzQXRMZXZlbCh6KTtcbiAgICAgIGNvbnN0IHRpbGVZTnVtID0gdGhpcy50aWxpbmdTY2hlbWUuZ2V0TnVtYmVyT2ZZVGlsZXNBdExldmVsKHopO1xuICAgICAgY29uc3QgdGlsZVBpeGVsID0ge1xuICAgICAgICB4V2lkdGg6IHdpZHRoIC8gdGlsZVhOdW0sXG4gICAgICAgIHlXaWR0aDogaGVpZ2h0IC8gdGlsZVlOdW1cbiAgICAgIH07XG4gICAgICBsZXQgd2luZG93ID0gW1xuICAgICAgICBNYXRoLnJvdW5kKHggKiB0aWxlUGl4ZWwueFdpZHRoKSxcbiAgICAgICAgTWF0aC5yb3VuZCh5ICogdGlsZVBpeGVsLnlXaWR0aCksXG4gICAgICAgIE1hdGgucm91bmQoKHggKyAxKSAqIHRpbGVQaXhlbC54V2lkdGgpLFxuICAgICAgICBNYXRoLnJvdW5kKCh5ICsgMSkgKiB0aWxlUGl4ZWwueVdpZHRoKVxuICAgICAgXTtcbiAgICAgIGlmICh0aGlzLl9wcm9qICYmIHRoaXMudGlsaW5nU2NoZW1lIGluc3RhbmNlb2YgVElGRkltYWdlcnlQcm92aWRlclRpbGluZ1NjaGVtZSkge1xuICAgICAgICBjb25zdCB0YXJnZXRSZWN0ID0gdGhpcy50aWxpbmdTY2hlbWUudGlsZVhZVG9OYXRpdmVSZWN0YW5nbGUyKHgsIHksIHopO1xuICAgICAgICBjb25zdCBuYXRpdmVSZWN0ID0gdGhpcy50aWxpbmdTY2hlbWUubmF0aXZlUmVjdGFuZ2xlO1xuICAgICAgICB0YXJnZXRSZWN0Lndlc3QgLT0gbmF0aXZlUmVjdC53aWR0aCAvIHdpZHRoO1xuICAgICAgICB0YXJnZXRSZWN0LmVhc3QgKz0gbmF0aXZlUmVjdC53aWR0aCAvIHdpZHRoO1xuICAgICAgICB0YXJnZXRSZWN0LnNvdXRoIC09IG5hdGl2ZVJlY3QuaGVpZ2h0IC8gaGVpZ2h0O1xuICAgICAgICB0YXJnZXRSZWN0Lm5vcnRoICs9IG5hdGl2ZVJlY3QuaGVpZ2h0IC8gaGVpZ2h0O1xuICAgICAgICB3aW5kb3cgPSBbXG4gICAgICAgICAgfn4oKHRhcmdldFJlY3Qud2VzdCAtIG5hdGl2ZVJlY3Qud2VzdCkgLyBuYXRpdmVSZWN0LndpZHRoICogd2lkdGgpLFxuICAgICAgICAgIH5+KChuYXRpdmVSZWN0Lm5vcnRoIC0gdGFyZ2V0UmVjdC5ub3J0aCkgLyBuYXRpdmVSZWN0LmhlaWdodCAqIGhlaWdodCksXG4gICAgICAgICAgfn4oKHRhcmdldFJlY3QuZWFzdCAtIG5hdGl2ZVJlY3Qud2VzdCkgLyBuYXRpdmVSZWN0LndpZHRoICogd2lkdGgpLFxuICAgICAgICAgIH5+KChuYXRpdmVSZWN0Lm5vcnRoIC0gdGFyZ2V0UmVjdC5zb3V0aCkgLyBuYXRpdmVSZWN0LmhlaWdodCAqIGhlaWdodClcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJldmVyc2VZKSB7XG4gICAgICAgIHdpbmRvdyA9IFt3aW5kb3dbMF0sIGhlaWdodCAtIHdpbmRvd1szXSwgd2luZG93WzJdLCBoZWlnaHQgLSB3aW5kb3dbMV1dO1xuICAgICAgfVxuICAgICAgY29uc3QgYnVmZmVyID0gMTtcbiAgICAgIHdpbmRvdyA9IFt3aW5kb3dbMF0gLSBidWZmZXIsIHdpbmRvd1sxXSAtIGJ1ZmZlciwgd2luZG93WzJdICsgYnVmZmVyLCB3aW5kb3dbM10gKyBidWZmZXJdO1xuICAgICAgY29uc3Qgc291cmNlV2lkdGggPSB3aW5kb3dbMl0gLSB3aW5kb3dbMF0sIHNvdXJjZUhlaWdodCA9IHdpbmRvd1szXSAtIHdpbmRvd1sxXTtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIHdpbmRvdyxcbiAgICAgICAgcG9vbDogdGhpcy5nZW90aWZmV29ya2VyUG9vbCxcbiAgICAgICAgc2FtcGxlczogdGhpcy5yZWFkU2FtcGxlcyxcbiAgICAgICAgZmlsbFZhbHVlOiB0aGlzLm5vRGF0YSxcbiAgICAgICAgaW50ZXJsZWF2ZTogZmFsc2VcbiAgICAgIH07XG4gICAgICBsZXQgcmVzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyT3B0aW9ucy5jb252ZXJ0VG9SR0IpIHtcbiAgICAgICAgICByZXMgPSB5aWVsZCBpbWFnZS5yZWFkUkdCKG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcyA9IHlpZWxkIGltYWdlLnJlYWRSYXN0ZXJzKG9wdGlvbnMpO1xuICAgICAgICAgIGlmICh0aGlzLnJldmVyc2VZKSB7XG4gICAgICAgICAgICByZXMgPSB5aWVsZCBQcm9taXNlLmFsbChyZXMubWFwKChhcnJheSkgPT4gcmV2ZXJzZUFycmF5KHsgYXJyYXksIHdpZHRoOiByZXMud2lkdGgsIGhlaWdodDogcmVzLmhlaWdodCB9KSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoKChfYSA9IHRoaXMuX3Byb2opID09IG51bGwgPyB2b2lkIDAgOiBfYS5wcm9qZWN0KSAmJiB0aGlzLnRpbGluZ1NjaGVtZSBpbnN0YW5jZW9mIFRJRkZJbWFnZXJ5UHJvdmlkZXJUaWxpbmdTY2hlbWUpIHtcbiAgICAgICAgICBjb25zdCBzb3VyY2VSZWN0ID0gdGhpcy50aWxpbmdTY2hlbWUudGlsZVhZVG9OYXRpdmVSZWN0YW5nbGUyKHgsIHksIHopO1xuICAgICAgICAgIGNvbnN0IHRhcmdldFJlY3QgPSB0aGlzLnRpbGluZ1NjaGVtZS50aWxlWFlUb1JlY3RhbmdsZSh4LCB5LCB6KTtcbiAgICAgICAgICBjb25zdCBzb3VyY2VCQm94ID0gW3NvdXJjZVJlY3Qud2VzdCwgc291cmNlUmVjdC5zb3V0aCwgc291cmNlUmVjdC5lYXN0LCBzb3VyY2VSZWN0Lm5vcnRoXTtcbiAgICAgICAgICBjb25zdCB0YXJnZXRCQm94ID0gW3RhcmdldFJlY3Qud2VzdCwgdGFyZ2V0UmVjdC5zb3V0aCwgdGFyZ2V0UmVjdC5lYXN0LCB0YXJnZXRSZWN0Lm5vcnRoXS5tYXAoQ2VzaXVtTWF0aC50b0RlZ3JlZXMpO1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwcmpEYXRhID0gcmVwcm9qZWN0aW9uKHtcbiAgICAgICAgICAgICAgZGF0YTogcmVzW2ldLFxuICAgICAgICAgICAgICBzb3VyY2VXaWR0aCxcbiAgICAgICAgICAgICAgc291cmNlSGVpZ2h0LFxuICAgICAgICAgICAgICBub2RhdGE6IHRoaXMubm9EYXRhLFxuICAgICAgICAgICAgICBwcm9qZWN0OiB0aGlzLl9wcm9qLnByb2plY3QsXG4gICAgICAgICAgICAgIHNvdXJjZUJCb3gsXG4gICAgICAgICAgICAgIHRhcmdldEJCb3hcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocHJqRGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlcyA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aWxlTnVtID0gMSA8PCByZXF6IC0gejtcbiAgICAgICAgY29uc3QgeDAgPSAocmVxeCAtIHN0YXJ0WCkgLyB0aWxlTnVtO1xuICAgICAgICBjb25zdCB5MCA9IChyZXF5IC0gc3RhcnRZKSAvIHRpbGVOdW07XG4gICAgICAgIGNvbnN0IHN0ZXAgPSAxIC8gKDEgPDwgcmVxeiAtIHopO1xuICAgICAgICBjb25zdCB4MSA9IHgwICsgc3RlcDtcbiAgICAgICAgY29uc3QgeTEgPSB5MCArIHN0ZXA7XG4gICAgICAgIHJlcyA9IHlpZWxkIFByb21pc2UuYWxsKHJlcy5tYXAoKGRhdGEpID0+IF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy53b3JrZXJQb29sLnJlc2FtcGxlKGRhdGEsIHtcbiAgICAgICAgICAgIHNvdXJjZVdpZHRoLFxuICAgICAgICAgICAgc291cmNlSGVpZ2h0LFxuICAgICAgICAgICAgdGFyZ2V0V2lkdGg6IHRoaXMudGlsZVdpZHRoLFxuICAgICAgICAgICAgdGFyZ2V0SGVpZ2h0OiB0aGlzLnRpbGVIZWlnaHQsXG4gICAgICAgICAgICB3aW5kb3c6IFt4MCwgeTAsIHgxLCB5MV0sXG4gICAgICAgICAgICBtZXRob2Q6IHRoaXMucmVuZGVyT3B0aW9ucy5yZXNhbXBsZU1ldGhvZCxcbiAgICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICAgIG5vZGF0YTogdGhpcy5ub0RhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiByZXMsXG4gICAgICAgICAgd2lkdGg6IHRoaXMudGlsZVdpZHRoLFxuICAgICAgICAgIGhlaWdodDogdGhpcy50aWxlSGVpZ2h0XG4gICAgICAgIH07XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aGlzLmVycm9yRXZlbnQucmFpc2VFdmVudChlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJlcXVlc3RJbWFnZSh4LCB5LCB6KSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmICghdGhpcy5yZWFkeSkge1xuICAgICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXG4gICAgICAgICAgXCJyZXF1ZXN0SW1hZ2UgbXVzdCBub3QgYmUgY2FsbGVkIGJlZm9yZSB0aGUgaW1hZ2VyeSBwcm92aWRlciBpcyByZWFkeS5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHogPCB0aGlzLm1pbmltdW1MZXZlbCB8fCB6ID4gdGhpcy5tYXhpbXVtTGV2ZWwpXG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICBjb25zdCBjYWNoZUtleSA9IGAke3h9XyR7eX1fJHt6fWA7XG4gICAgICBpZiAodGhpcy5faW1hZ2VzQ2FjaGUuaGFzKGNhY2hlS2V5KSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW1hZ2VzQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgc2luZ2xlLCBtdWx0aSwgY29udmVydFRvUkdCIH0gPSB0aGlzLnJlbmRlck9wdGlvbnM7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIGRhdGEgfSA9IHlpZWxkIHRoaXMuX2xvYWRUaWxlKHgsIHksIHopO1xuICAgICAgICBpZiAodGhpcy5fZGVzdHJveWVkIHx8ICF3aWR0aCB8fCAhaGVpZ2h0KSB7XG4gICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBpZiAobXVsdGkgfHwgY29udmVydFRvUkdCKSB7XG4gICAgICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIHJlbmRlck9wdGlvbnM6IG11bHRpICE9IG51bGwgPyBtdWx0aSA6IFtcInJcIiwgXCJnXCIsIFwiYlwiXS5yZWR1Y2UoKHByZSwgdmFsLCBpbmRleCkgPT4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgcHJlKSwge1xuICAgICAgICAgICAgICBbdmFsXToge1xuICAgICAgICAgICAgICAgIGJhbmQ6IGluZGV4ICsgMSxcbiAgICAgICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICAgICAgbWF4OiAyNTVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksIHt9KSxcbiAgICAgICAgICAgIGJhbmRzOiB0aGlzLmJhbmRzLFxuICAgICAgICAgICAgbm9EYXRhOiB0aGlzLm5vRGF0YSxcbiAgICAgICAgICAgIGNvbG9yTWFwcGluZzogT2JqZWN0LmVudHJpZXMoKF9hID0gdGhpcy5yZW5kZXJPcHRpb25zLmNvbG9yTWFwcGluZykgIT0gbnVsbCA/IF9hIDogeyBcImJsYWNrXCI6IFwidHJhbnNwYXJlbnRcIiB9KS5tYXAoKHZhbCkgPT4gdmFsLm1hcChzdHJpbmdDb2xvclRvUmdiYSkpXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXN1bHQgPSB5aWVsZCBnZW5lcmF0ZUltYWdlKG9wdHMpO1xuICAgICAgICB9IGVsc2UgaWYgKHNpbmdsZSAmJiB0aGlzLnBsb3QpIHtcbiAgICAgICAgICBjb25zdCB7IGJhbmQgPSAxIH0gPSBzaW5nbGU7XG4gICAgICAgICAgdGhpcy5wbG90LnJlbW92ZUFsbERhdGFzZXQoKTtcbiAgICAgICAgICB0aGlzLnJlYWRTYW1wbGVzLmZvckVhY2goKHNhbXBsZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGxvdC5hZGREYXRhc2V0KGBiJHtzYW1wbGUgKyAxfWAsIGRhdGFbaW5kZXhdLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoc2luZ2xlLmV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIHRoaXMucGxvdC5yZW5kZXIoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wbG90LnJlbmRlckRhdGFzZXQoYGIke2JhbmR9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGNhbnYgPSBjcmVhdGVDYW5hdmFzKHRoaXMudGlsZVdpZHRoLCB0aGlzLnRpbGVIZWlnaHQpO1xuICAgICAgICAgIGNvbnN0IGN0eCA9IGNhbnYuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5wbG90LmNhbnZhcywgMCwgMCk7XG4gICAgICAgICAgcmVzdWx0ID0gY2FudjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2ltYWdlc0NhY2hlLnNpemUgPj0gdGhpcy5fY2FjaGVTaXplKSB7XG4gICAgICAgICAgICBjb25zdCBvbGRlc3RLZXkgPSB0aGlzLl9pbWFnZXNDYWNoZS5rZXlzKCkubmV4dCgpLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5faW1hZ2VzQ2FjaGUuZGVsZXRlKG9sZGVzdEtleSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2ltYWdlc0NhY2hlLnNldChjYWNoZUtleSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB0aGlzLmVycm9yRXZlbnQucmFpc2VFdmVudChlKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBwaWNrRmVhdHVyZXMoeCwgeSwgem9vbSwgbG9uZ2l0dWRlLCBsYXRpdHVkZSkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5lbmFibGVQaWNrRmVhdHVyZXMpXG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICBjb25zdCB6ID0gem9vbSA+IHRoaXMubWF4aW11bUxldmVsID8gdGhpcy5tYXhpbXVtTGV2ZWwgOiB6b29tO1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnJlcXVlc3RMZXZlbHNbel07XG4gICAgICBsZXQgaW1hZ2UgPSB0aGlzLl9pbWFnZXNbaW5kZXhdO1xuICAgICAgaWYgKCFpbWFnZSkge1xuICAgICAgICBpbWFnZSA9IHRoaXMuX2ltYWdlc1tpbmRleF0gPSB5aWVsZCB0aGlzLl9zb3VyY2UuZ2V0SW1hZ2UoaW5kZXgpO1xuICAgICAgfVxuICAgICAgY29uc3Qgd2lkdGggPSBpbWFnZS5nZXRXaWR0aCgpO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2UuZ2V0SGVpZ2h0KCk7XG4gICAgICBsZXQgcG9zWCwgcG9zWSwgd2luZG93O1xuICAgICAgY29uc3QgeyB3ZXN0LCBzb3V0aCwgbm9ydGgsIHdpZHRoOiBsb25XaWR0aCB9ID0gdGhpcy5yZWN0YW5nbGU7XG4gICAgICBsZXQgbG9uR2FwID0gbG9uZ2l0dWRlIC0gd2VzdDtcbiAgICAgIGlmIChsb25naXR1ZGUgPCB3ZXN0KSB7XG4gICAgICAgIGxvbkdhcCArPSBDZXNpdW1NYXRoLlRXT19QSTtcbiAgICAgIH1cbiAgICAgIHBvc1ggPSB+fihNYXRoLmFicyhsb25HYXAgLyBsb25XaWR0aCkgKiB3aWR0aCk7XG4gICAgICBwb3NZID0gfn4oTWF0aC5hYnMoKG5vcnRoIC0gbGF0aXR1ZGUpIC8gKG5vcnRoIC0gc291dGgpKSAqIGhlaWdodCk7XG4gICAgICB3aW5kb3cgPSBbcG9zWCwgcG9zWSwgcG9zWCArIDEsIHBvc1kgKyAxXTtcbiAgICAgIGlmICh0aGlzLnJldmVyc2VZKSB7XG4gICAgICAgIHBvc1kgPSBoZWlnaHQgLSBwb3NZO1xuICAgICAgICB3aW5kb3cgPSBbcG9zWCwgcG9zWSAtIDEsIHBvc1ggKyAxLCBwb3NZXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIHdpbmRvdyxcbiAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgcG9vbDogdGhpcy5nZW90aWZmV29ya2VyUG9vbCxcbiAgICAgICAgaW50ZXJsZWF2ZTogZmFsc2VcbiAgICAgIH07XG4gICAgICBsZXQgcmVzO1xuICAgICAgaWYgKHRoaXMucmVuZGVyT3B0aW9ucy5jb252ZXJ0VG9SR0IpIHtcbiAgICAgICAgcmVzID0geWllbGQgaW1hZ2UucmVhZFJHQihvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcyA9IHlpZWxkIGltYWdlLnJlYWRSYXN0ZXJzKG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgY29uc3QgZmVhdHVyZUluZm8gPSBuZXcgSW1hZ2VyeUxheWVyRmVhdHVyZUluZm8oKTtcbiAgICAgIGZlYXR1cmVJbmZvLm5hbWUgPSBgbG9uOiR7KGxvbmdpdHVkZSAvIE1hdGguUEkgKiAxODApLnRvRml4ZWQoNil9LCBsYXQ6JHsobGF0aXR1ZGUgLyBNYXRoLlBJICogMTgwKS50b0ZpeGVkKDYpfWA7XG4gICAgICBjb25zdCBkYXRhID0ge307XG4gICAgICByZXMgPT0gbnVsbCA/IHZvaWQgMCA6IHJlcy5mb3JFYWNoKChpdGVtLCBpbmRleDIpID0+IHtcbiAgICAgICAgZGF0YVtpbmRleDJdID0gaXRlbSA9PSBudWxsID8gdm9pZCAwIDogaXRlbVswXTtcbiAgICAgIH0pO1xuICAgICAgZmVhdHVyZUluZm8uZGF0YSA9IGRhdGE7XG4gICAgICBpZiAocmVzKSB7XG4gICAgICAgIGZlYXR1cmVJbmZvLmNvbmZpZ3VyZURlc2NyaXB0aW9uRnJvbVByb3BlcnRpZXMoZGF0YSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW2ZlYXR1cmVJbmZvXTtcbiAgICB9KTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAodGhpcy5faW1hZ2VzQ2FjaGUpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuX2ltYWdlc0NhY2hlKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9pbWFnZXNDYWNoZVtrZXldO1xuICAgICAgfVxuICAgICAgdGhpcy5faW1hZ2VzQ2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMud29ya2VyUG9vbCkge1xuICAgICAgdGhpcy53b3JrZXJQb29sLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucGxvdCAmJiB0aGlzLnBsb3QuZ2wpIHtcbiAgICAgIGZvciAoY29uc3QgcHJvZ3JhbUtleSBpbiB0aGlzLnBsb3QucHJvZ3JhbUNhY2hlKSB7XG4gICAgICAgIHRoaXMucGxvdC5nbC5kZWxldGVQcm9ncmFtKHRoaXMucGxvdC5wcm9ncmFtQ2FjaGVbcHJvZ3JhbUtleV0pO1xuICAgICAgfVxuICAgICAgdGhpcy5wbG90LmdsLmRlbGV0ZUJ1ZmZlcih0aGlzLnBsb3QucG9zaXRpb25CdWZmZXIpO1xuICAgIH1cbiAgICAoX2EgPSB0aGlzLnBsb3QpID09IG51bGwgPyB2b2lkIDAgOiBfYS5kZXN0cm95KCk7XG4gICAgdGhpcy5faW1hZ2VzID0gW107XG4gICAgdGhpcy5fc291cmNlID0gdm9pZCAwO1xuICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gIH1cbn1cblxuZXhwb3J0IHsgVElGRkltYWdlcnlQcm92aWRlciwgY29sb3JzY2FsZXMsIFRJRkZJbWFnZXJ5UHJvdmlkZXIgYXMgZGVmYXVsdCwgcmVuZGVyQ29sb3JTY2FsZVRvQ2FudmFzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/terriajs-tiff-imagery-provider/dist/index.js\n");

/***/ }),

/***/ "./node_modules/xml-utils/count-substring.js":
/*!***************************************************!*\
  !*** ./node_modules/xml-utils/count-substring.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function countSubstring(string, substring) {\n  const pattern = new RegExp(substring, \"g\");\n  const match = string.match(pattern);\n  return match ? match.length : 0;\n}\n\nmodule.exports = countSubstring;\nmodule.exports.default = countSubstring;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveG1sLXV0aWxzL2NvdW50LXN1YnN0cmluZy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy94bWwtdXRpbHMvY291bnQtc3Vic3RyaW5nLmpzP2RkZWMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gY291bnRTdWJzdHJpbmcoc3RyaW5nLCBzdWJzdHJpbmcpIHtcbiAgY29uc3QgcGF0dGVybiA9IG5ldyBSZWdFeHAoc3Vic3RyaW5nLCBcImdcIik7XG4gIGNvbnN0IG1hdGNoID0gc3RyaW5nLm1hdGNoKHBhdHRlcm4pO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaC5sZW5ndGggOiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvdW50U3Vic3RyaW5nO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGNvdW50U3Vic3RyaW5nO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/xml-utils/count-substring.js\n");

/***/ }),

/***/ "./node_modules/xml-utils/find-tag-by-name.js":
/*!****************************************************!*\
  !*** ./node_modules/xml-utils/find-tag-by-name.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const indexOfMatch = __webpack_require__(/*! ./index-of-match.js */ \"./node_modules/xml-utils/index-of-match.js\");\nconst indexOfMatchEnd = __webpack_require__(/*! ./index-of-match-end.js */ \"./node_modules/xml-utils/index-of-match-end.js\");\nconst countSubstring = __webpack_require__(/*! ./count-substring.js */ \"./node_modules/xml-utils/count-substring.js\");\n\nfunction findTagByName(xml, tagName, options) {\n  const debug = (options && options.debug) || false;\n  const nested = !(options && typeof options.nested === false);\n\n  const startIndex = (options && options.startIndex) || 0;\n\n  if (debug) console.log(\"[xml-utils] starting findTagByName with\", tagName, \" and \", options);\n\n  const start = indexOfMatch(xml, `\\<${tagName}[ \\n\\>\\/]`, startIndex);\n  if (debug) console.log(\"[xml-utils] start:\", start);\n  if (start === -1) return undefined;\n\n  const afterStart = xml.slice(start + tagName.length);\n\n  let relativeEnd = indexOfMatchEnd(afterStart, \"^[^<]*[ /]>\", 0);\n\n  const selfClosing = relativeEnd !== -1 && afterStart[relativeEnd - 1] === \"/\";\n  if (debug) console.log(\"[xml-utils] selfClosing:\", selfClosing);\n\n  if (selfClosing === false) {\n    // check if tag has subtags with the same name\n    if (nested) {\n      let startIndex = 0;\n      let openings = 1;\n      let closings = 0;\n      while ((relativeEnd = indexOfMatchEnd(afterStart, \"[ /]\" + tagName + \">\", startIndex)) !== -1) {\n        const clip = afterStart.substring(startIndex, relativeEnd + 1);\n        openings += countSubstring(clip, \"<\" + tagName + \"[ \\n\\t>]\");\n        closings += countSubstring(clip, \"</\" + tagName + \">\");\n        // we can't have more openings than closings\n        if (closings >= openings) break;\n        startIndex = relativeEnd;\n      }\n    } else {\n      relativeEnd = indexOfMatchEnd(afterStart, \"[ /]\" + tagName + \">\", 0);\n    }\n  }\n\n  const end = start + tagName.length + relativeEnd + 1;\n  if (debug) console.log(\"[xml-utils] end:\", end);\n  if (end === -1) return undefined;\n\n  const outer = xml.slice(start, end);\n  // tag is like <gml:identifier codeSpace=\"OGP\">urn:ogc:def:crs:EPSG::32617</gml:identifier>\n\n  let inner;\n  if (selfClosing) {\n    inner = null;\n  } else {\n    inner = outer.slice(outer.indexOf(\">\") + 1, outer.lastIndexOf(\"<\"));\n  }\n\n  return { inner, outer, start, end };\n}\n\nmodule.exports = findTagByName;\nmodule.exports.default = findTagByName;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveG1sLXV0aWxzL2ZpbmQtdGFnLWJ5LW5hbWUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveG1sLXV0aWxzL2ZpbmQtdGFnLWJ5LW5hbWUuanM/ZWJlYSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBpbmRleE9mTWF0Y2ggPSByZXF1aXJlKFwiLi9pbmRleC1vZi1tYXRjaC5qc1wiKTtcbmNvbnN0IGluZGV4T2ZNYXRjaEVuZCA9IHJlcXVpcmUoXCIuL2luZGV4LW9mLW1hdGNoLWVuZC5qc1wiKTtcbmNvbnN0IGNvdW50U3Vic3RyaW5nID0gcmVxdWlyZShcIi4vY291bnQtc3Vic3RyaW5nLmpzXCIpO1xuXG5mdW5jdGlvbiBmaW5kVGFnQnlOYW1lKHhtbCwgdGFnTmFtZSwgb3B0aW9ucykge1xuICBjb25zdCBkZWJ1ZyA9IChvcHRpb25zICYmIG9wdGlvbnMuZGVidWcpIHx8IGZhbHNlO1xuICBjb25zdCBuZXN0ZWQgPSAhKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubmVzdGVkID09PSBmYWxzZSk7XG5cbiAgY29uc3Qgc3RhcnRJbmRleCA9IChvcHRpb25zICYmIG9wdGlvbnMuc3RhcnRJbmRleCkgfHwgMDtcblxuICBpZiAoZGVidWcpIGNvbnNvbGUubG9nKFwiW3htbC11dGlsc10gc3RhcnRpbmcgZmluZFRhZ0J5TmFtZSB3aXRoXCIsIHRhZ05hbWUsIFwiIGFuZCBcIiwgb3B0aW9ucyk7XG5cbiAgY29uc3Qgc3RhcnQgPSBpbmRleE9mTWF0Y2goeG1sLCBgXFw8JHt0YWdOYW1lfVsgXFxuXFw+XFwvXWAsIHN0YXJ0SW5kZXgpO1xuICBpZiAoZGVidWcpIGNvbnNvbGUubG9nKFwiW3htbC11dGlsc10gc3RhcnQ6XCIsIHN0YXJ0KTtcbiAgaWYgKHN0YXJ0ID09PSAtMSkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICBjb25zdCBhZnRlclN0YXJ0ID0geG1sLnNsaWNlKHN0YXJ0ICsgdGFnTmFtZS5sZW5ndGgpO1xuXG4gIGxldCByZWxhdGl2ZUVuZCA9IGluZGV4T2ZNYXRjaEVuZChhZnRlclN0YXJ0LCBcIl5bXjxdKlsgL10+XCIsIDApO1xuXG4gIGNvbnN0IHNlbGZDbG9zaW5nID0gcmVsYXRpdmVFbmQgIT09IC0xICYmIGFmdGVyU3RhcnRbcmVsYXRpdmVFbmQgLSAxXSA9PT0gXCIvXCI7XG4gIGlmIChkZWJ1ZykgY29uc29sZS5sb2coXCJbeG1sLXV0aWxzXSBzZWxmQ2xvc2luZzpcIiwgc2VsZkNsb3NpbmcpO1xuXG4gIGlmIChzZWxmQ2xvc2luZyA9PT0gZmFsc2UpIHtcbiAgICAvLyBjaGVjayBpZiB0YWcgaGFzIHN1YnRhZ3Mgd2l0aCB0aGUgc2FtZSBuYW1lXG4gICAgaWYgKG5lc3RlZCkge1xuICAgICAgbGV0IHN0YXJ0SW5kZXggPSAwO1xuICAgICAgbGV0IG9wZW5pbmdzID0gMTtcbiAgICAgIGxldCBjbG9zaW5ncyA9IDA7XG4gICAgICB3aGlsZSAoKHJlbGF0aXZlRW5kID0gaW5kZXhPZk1hdGNoRW5kKGFmdGVyU3RhcnQsIFwiWyAvXVwiICsgdGFnTmFtZSArIFwiPlwiLCBzdGFydEluZGV4KSkgIT09IC0xKSB7XG4gICAgICAgIGNvbnN0IGNsaXAgPSBhZnRlclN0YXJ0LnN1YnN0cmluZyhzdGFydEluZGV4LCByZWxhdGl2ZUVuZCArIDEpO1xuICAgICAgICBvcGVuaW5ncyArPSBjb3VudFN1YnN0cmluZyhjbGlwLCBcIjxcIiArIHRhZ05hbWUgKyBcIlsgXFxuXFx0Pl1cIik7XG4gICAgICAgIGNsb3NpbmdzICs9IGNvdW50U3Vic3RyaW5nKGNsaXAsIFwiPC9cIiArIHRhZ05hbWUgKyBcIj5cIik7XG4gICAgICAgIC8vIHdlIGNhbid0IGhhdmUgbW9yZSBvcGVuaW5ncyB0aGFuIGNsb3NpbmdzXG4gICAgICAgIGlmIChjbG9zaW5ncyA+PSBvcGVuaW5ncykgYnJlYWs7XG4gICAgICAgIHN0YXJ0SW5kZXggPSByZWxhdGl2ZUVuZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVsYXRpdmVFbmQgPSBpbmRleE9mTWF0Y2hFbmQoYWZ0ZXJTdGFydCwgXCJbIC9dXCIgKyB0YWdOYW1lICsgXCI+XCIsIDApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGVuZCA9IHN0YXJ0ICsgdGFnTmFtZS5sZW5ndGggKyByZWxhdGl2ZUVuZCArIDE7XG4gIGlmIChkZWJ1ZykgY29uc29sZS5sb2coXCJbeG1sLXV0aWxzXSBlbmQ6XCIsIGVuZCk7XG4gIGlmIChlbmQgPT09IC0xKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gIGNvbnN0IG91dGVyID0geG1sLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAvLyB0YWcgaXMgbGlrZSA8Z21sOmlkZW50aWZpZXIgY29kZVNwYWNlPVwiT0dQXCI+dXJuOm9nYzpkZWY6Y3JzOkVQU0c6OjMyNjE3PC9nbWw6aWRlbnRpZmllcj5cblxuICBsZXQgaW5uZXI7XG4gIGlmIChzZWxmQ2xvc2luZykge1xuICAgIGlubmVyID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICBpbm5lciA9IG91dGVyLnNsaWNlKG91dGVyLmluZGV4T2YoXCI+XCIpICsgMSwgb3V0ZXIubGFzdEluZGV4T2YoXCI8XCIpKTtcbiAgfVxuXG4gIHJldHVybiB7IGlubmVyLCBvdXRlciwgc3RhcnQsIGVuZCB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbmRUYWdCeU5hbWU7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZmluZFRhZ0J5TmFtZTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/xml-utils/find-tag-by-name.js\n");

/***/ }),

/***/ "./node_modules/xml-utils/find-tags-by-name.js":
/*!*****************************************************!*\
  !*** ./node_modules/xml-utils/find-tags-by-name.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const findTagByName = __webpack_require__(/*! ./find-tag-by-name.js */ \"./node_modules/xml-utils/find-tag-by-name.js\");\n\nfunction findTagsByName(xml, tagName, options) {\n  const tags = [];\n  const debug = (options && options.debug) || false;\n  const nested = options && typeof options.nested === \"boolean\" ? options.nested : true;\n  let startIndex = (options && options.startIndex) || 0;\n  let tag;\n  while ((tag = findTagByName(xml, tagName, { debug, startIndex }))) {\n    if (nested) {\n      startIndex = tag.start + 1 + tagName.length;\n    } else {\n      startIndex = tag.end;\n    }\n    tags.push(tag);\n  }\n  if (debug) console.log(\"findTagsByName found\", tags.length, \"tags\");\n  return tags;\n}\n\nmodule.exports = findTagsByName;\nmodule.exports.default = findTagsByName;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveG1sLXV0aWxzL2ZpbmQtdGFncy1ieS1uYW1lLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3htbC11dGlscy9maW5kLXRhZ3MtYnktbmFtZS5qcz81ZWRmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGZpbmRUYWdCeU5hbWUgPSByZXF1aXJlKFwiLi9maW5kLXRhZy1ieS1uYW1lLmpzXCIpO1xuXG5mdW5jdGlvbiBmaW5kVGFnc0J5TmFtZSh4bWwsIHRhZ05hbWUsIG9wdGlvbnMpIHtcbiAgY29uc3QgdGFncyA9IFtdO1xuICBjb25zdCBkZWJ1ZyA9IChvcHRpb25zICYmIG9wdGlvbnMuZGVidWcpIHx8IGZhbHNlO1xuICBjb25zdCBuZXN0ZWQgPSBvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm5lc3RlZCA9PT0gXCJib29sZWFuXCIgPyBvcHRpb25zLm5lc3RlZCA6IHRydWU7XG4gIGxldCBzdGFydEluZGV4ID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5zdGFydEluZGV4KSB8fCAwO1xuICBsZXQgdGFnO1xuICB3aGlsZSAoKHRhZyA9IGZpbmRUYWdCeU5hbWUoeG1sLCB0YWdOYW1lLCB7IGRlYnVnLCBzdGFydEluZGV4IH0pKSkge1xuICAgIGlmIChuZXN0ZWQpIHtcbiAgICAgIHN0YXJ0SW5kZXggPSB0YWcuc3RhcnQgKyAxICsgdGFnTmFtZS5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0SW5kZXggPSB0YWcuZW5kO1xuICAgIH1cbiAgICB0YWdzLnB1c2godGFnKTtcbiAgfVxuICBpZiAoZGVidWcpIGNvbnNvbGUubG9nKFwiZmluZFRhZ3NCeU5hbWUgZm91bmRcIiwgdGFncy5sZW5ndGgsIFwidGFnc1wiKTtcbiAgcmV0dXJuIHRhZ3M7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZFRhZ3NCeU5hbWU7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZmluZFRhZ3NCeU5hbWU7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/xml-utils/find-tags-by-name.js\n");

/***/ }),

/***/ "./node_modules/xml-utils/get-attribute.js":
/*!*************************************************!*\
  !*** ./node_modules/xml-utils/get-attribute.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function getAttribute(tag, attributeName, options) {\n  const debug = (options && options.debug) || false;\n  if (debug) console.log(\"[xml-utils] getting \" + attributeName + \" in \" + tag);\n\n  const xml = typeof tag === \"object\" ? tag.outer : tag;\n\n  // only search for attributes in the opening tag\n  const opening = xml.slice(0, xml.indexOf(\">\") + 1);\n\n  const quotechars = ['\"', \"'\"];\n  for (let i = 0; i < quotechars.length; i++) {\n    const char = quotechars[i];\n    const pattern = attributeName + \"\\\\=\" + char + \"([^\" + char + \"]*)\" + char;\n    if (debug) console.log(\"[xml-utils] pattern:\", pattern);\n\n    const re = new RegExp(pattern);\n    const match = re.exec(opening);\n    if (debug) console.log(\"[xml-utils] match:\", match);\n    if (match) return match[1];\n  }\n}\n\nmodule.exports = getAttribute;\nmodule.exports.default = getAttribute;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveG1sLXV0aWxzL2dldC1hdHRyaWJ1dGUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveG1sLXV0aWxzL2dldC1hdHRyaWJ1dGUuanM/OTRkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBnZXRBdHRyaWJ1dGUodGFnLCBhdHRyaWJ1dGVOYW1lLCBvcHRpb25zKSB7XG4gIGNvbnN0IGRlYnVnID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5kZWJ1ZykgfHwgZmFsc2U7XG4gIGlmIChkZWJ1ZykgY29uc29sZS5sb2coXCJbeG1sLXV0aWxzXSBnZXR0aW5nIFwiICsgYXR0cmlidXRlTmFtZSArIFwiIGluIFwiICsgdGFnKTtcblxuICBjb25zdCB4bWwgPSB0eXBlb2YgdGFnID09PSBcIm9iamVjdFwiID8gdGFnLm91dGVyIDogdGFnO1xuXG4gIC8vIG9ubHkgc2VhcmNoIGZvciBhdHRyaWJ1dGVzIGluIHRoZSBvcGVuaW5nIHRhZ1xuICBjb25zdCBvcGVuaW5nID0geG1sLnNsaWNlKDAsIHhtbC5pbmRleE9mKFwiPlwiKSArIDEpO1xuXG4gIGNvbnN0IHF1b3RlY2hhcnMgPSBbJ1wiJywgXCInXCJdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHF1b3RlY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGFyID0gcXVvdGVjaGFyc1tpXTtcbiAgICBjb25zdCBwYXR0ZXJuID0gYXR0cmlidXRlTmFtZSArIFwiXFxcXD1cIiArIGNoYXIgKyBcIihbXlwiICsgY2hhciArIFwiXSopXCIgKyBjaGFyO1xuICAgIGlmIChkZWJ1ZykgY29uc29sZS5sb2coXCJbeG1sLXV0aWxzXSBwYXR0ZXJuOlwiLCBwYXR0ZXJuKTtcblxuICAgIGNvbnN0IHJlID0gbmV3IFJlZ0V4cChwYXR0ZXJuKTtcbiAgICBjb25zdCBtYXRjaCA9IHJlLmV4ZWMob3BlbmluZyk7XG4gICAgaWYgKGRlYnVnKSBjb25zb2xlLmxvZyhcIlt4bWwtdXRpbHNdIG1hdGNoOlwiLCBtYXRjaCk7XG4gICAgaWYgKG1hdGNoKSByZXR1cm4gbWF0Y2hbMV07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBdHRyaWJ1dGU7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0QXR0cmlidXRlO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/xml-utils/get-attribute.js\n");

/***/ }),

/***/ "./node_modules/xml-utils/index-of-match-end.js":
/*!******************************************************!*\
  !*** ./node_modules/xml-utils/index-of-match-end.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function indexOfMatchEnd(xml, pattern, startIndex) {\n  const re = new RegExp(pattern);\n  const match = re.exec(xml.slice(startIndex));\n  if (match) return startIndex + match.index + match[0].length - 1;\n  else return -1;\n}\n\nmodule.exports = indexOfMatchEnd;\nmodule.exports.default = indexOfMatchEnd;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveG1sLXV0aWxzL2luZGV4LW9mLW1hdGNoLWVuZC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy94bWwtdXRpbHMvaW5kZXgtb2YtbWF0Y2gtZW5kLmpzPzY1OGUiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gaW5kZXhPZk1hdGNoRW5kKHhtbCwgcGF0dGVybiwgc3RhcnRJbmRleCkge1xuICBjb25zdCByZSA9IG5ldyBSZWdFeHAocGF0dGVybik7XG4gIGNvbnN0IG1hdGNoID0gcmUuZXhlYyh4bWwuc2xpY2Uoc3RhcnRJbmRleCkpO1xuICBpZiAobWF0Y2gpIHJldHVybiBzdGFydEluZGV4ICsgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGggLSAxO1xuICBlbHNlIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbmRleE9mTWF0Y2hFbmQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gaW5kZXhPZk1hdGNoRW5kO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/xml-utils/index-of-match-end.js\n");

/***/ }),

/***/ "./node_modules/xml-utils/index-of-match.js":
/*!**************************************************!*\
  !*** ./node_modules/xml-utils/index-of-match.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function indexOfMatch(xml, pattern, startIndex) {\n  const re = new RegExp(pattern);\n  const match = re.exec(xml.slice(startIndex));\n  if (match) return startIndex + match.index;\n  else return -1;\n}\n\nmodule.exports = indexOfMatch;\nmodule.exports.default = indexOfMatch;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveG1sLXV0aWxzL2luZGV4LW9mLW1hdGNoLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3htbC11dGlscy9pbmRleC1vZi1tYXRjaC5qcz9mNDYwIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGluZGV4T2ZNYXRjaCh4bWwsIHBhdHRlcm4sIHN0YXJ0SW5kZXgpIHtcbiAgY29uc3QgcmUgPSBuZXcgUmVnRXhwKHBhdHRlcm4pO1xuICBjb25zdCBtYXRjaCA9IHJlLmV4ZWMoeG1sLnNsaWNlKHN0YXJ0SW5kZXgpKTtcbiAgaWYgKG1hdGNoKSByZXR1cm4gc3RhcnRJbmRleCArIG1hdGNoLmluZGV4O1xuICBlbHNlIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbmRleE9mTWF0Y2g7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gaW5kZXhPZk1hdGNoO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/xml-utils/index-of-match.js\n");

/***/ })

}]);